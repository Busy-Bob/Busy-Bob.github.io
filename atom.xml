<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Busy-Bob.github.io</id>
    <title>勺海的博客</title>
    <updated>2020-12-01T08:15:22.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Busy-Bob.github.io"/>
    <link rel="self" href="https://Busy-Bob.github.io/atom.xml"/>
    <subtitle>尽应尽之事，做让自己开心的事。</subtitle>
    <logo>https://Busy-Bob.github.io/images/avatar.png</logo>
    <icon>https://Busy-Bob.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 勺海的博客</rights>
    <entry>
        <title type="html"><![CDATA[Rust 错误处理中多种类型Error传播的处理方式]]></title>
        <id>https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/</id>
        <link href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/">
        </link>
        <updated>2020-12-01T07:27:56.000Z</updated>
        <summary type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
<!-- more -->
<p>主要参考：<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a> 和 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html">Result 与可恢复的错误</a>.</p>
<h1 id="tl-dr">TL; DR</h1>
<ul>
<li><code>Box&lt;dyn std::error::Error&gt;</code> 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）</li>
<li>自定义一个<code>enum</code>通常用在需要对错误进行恢复的时候。（容易检测类型）</li>
</ul>
<h1 id="boxdyn-error-方式来聚合error"><code>Box&lt;dyn Error&gt;</code> 方式来聚合Error</h1>
<pre><code class="language-rust">fn do_something() -&gt; std::result::Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{
    let path = &quot;./dat&quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&lt;u32&gt;()?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}
</code></pre>
<p>三者分别返回不同的错误类型，但是都可以用<code>Box&lt;dyn std::error::Error&gt;</code>来装。</p>
<ul>
<li><strong>优点</strong>： 方便书写。</li>
<li><strong>缺点</strong>： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“<strong>反射</strong>”( <code>Any</code> trait)才能够确定。而不能直接match。</li>
</ul>
<h1 id="利用-enum-来聚合error">利用 <code>enum</code> 来聚合Error</h1>
<blockquote>
<p>内容来自<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a></p>
</blockquote>
<p>自定义一个<code>error</code>需要实现如下几步：</p>
<ul>
<li>手动实现impl <code>std::fmt::Display</code>的trait,并<strong>实现</strong> <code>fmt(...)</code>方法。</li>
<li>手动实现impl <code>std::fmt::Debug</code>的<code>trait</code>，一般直接添加注解即可：<code>#[derive(Debug)]</code></li>
<li>手动实现impl <code>std::error::Error</code>的<code>trait</code>,并根据自身<code>error</code>级别是否<strong>覆盖</strong><code>std::error::Error</code>中的<code>source()</code>方法。</li>
</ul>
<p>下面的内容中：</p>
<ul>
<li><code>CustomError</code>为我们实现的<strong>自定义Error</strong></li>
<li><code>CustomError</code>有三个<strong>子类型Error</strong></li>
<li><code>CustomError</code>分别实现了三个<strong>子类型Error</strong> <code>From</code>的trait,将其类型包装为<strong>自定义Error</strong>的子类型</li>
</ul>
<p>好了，有了自定义的<code>CustomError</code>，那怎么使用呢? 我们看代码：</p>
<pre><code class="language-rust">use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&gt; std::result::Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 基于回调的异步方法分析]]></title>
        <id>https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/">
        </link>
        <updated>2020-11-30T08:57:43.000Z</updated>
        <summary type="html"><![CDATA[<p>基于<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>文中的回调代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>基于<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>文中的回调代码。</p>
<!-- more -->
<h1 id="原作者的一些分析">原作者的一些分析</h1>
<p>基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(<strong>指针</strong>)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。</p>
<ul>
<li><strong>优势：</strong>
<ul>
<li>易于在大多数语言中实现</li>
<li>没有上下文切换</li>
<li>相对较低的内存开销(在大多数情况下)</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。</li>
<li>很难理解。许多人已经知道这是“回调地狱”。</li>
<li>这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。</li>
<li>由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。</li>
</ul>
</li>
</ul>
<h1 id="代码">代码</h1>
<p>通过代码，学习到了一些新东西，主要包括：</p>
<ul>
<li><code>thread_local!</code> ：用来对每一个线程初始化同一个变量的一个新的副本。</li>
<li>trait 对象： <code>Box&lt;dyn FnOnce() -&gt; ()&gt;</code>,  <code>dyn Trait</code>表示一个类型，强调是动态分发，并且必须是一个<code>impl</code>了<code>Trait</code>的类型。</li>
<li>传递闭包可以使用<code>impl Trait</code>，这也是一个类型，并且该类型是<code>impl</code>了<code>Trait</code>的类型。</li>
<li><code>thread::spawn</code>会直接新开一个子线程运行，不会造成主线程阻塞。</li>
<li><code>std::sync::mpsc::Receiver.iter()</code> 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的<code>.next()</code> 才会变成<code>None</code>，否则会一直等待。</li>
</ul>
<blockquote>
<p>回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。</p>
</blockquote>
<pre><code class="language-rust">
fn program_main() {
    // 第一个输出
    println!(&quot;So we start the program here!&quot;);
    // 运行到这儿的时候， 0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(200, || {
        // 第五个输出
        println!(&quot;We create tasks with a callback that runs once the task finished!&quot;);
    });
    // 运行到这儿的时候， 仍然是0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(100, || {
        // 第三个输出
        println!(&quot;We can even chain sub-tasks...&quot;);
        set_timeout(50, || {
            // 第四个输出
            println!(&quot;...like this!&quot;);
        })
    });
    // 运行到这儿的时候， 仍然是0ms
    // 第二个输出
    println!(&quot;While our tasks are executing we can do other stuff instead of waiting.&quot;);
}

fn main() {
    RT.with(|rt| rt.run(program_main));
}

use std::sync::mpsc::{channel, Receiver, Sender};
use std::{cell::RefCell, collections::HashMap, thread};


// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本
// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&lt;Runtime&gt;
// 这儿好像只用到了一个副本
thread_local! {
    static RT: Runtime = Runtime::new();
}

struct Runtime {
    // callbacks 中的Box&lt;dyn FnOnce() -&gt; ()&gt; 是一个 trait 对象。 
    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&gt; u32。 
    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。
    callbacks: RefCell&lt;HashMap&lt;usize, Box&lt;dyn FnOnce() -&gt; ()&gt;&gt;&gt;,
    // 储存下一个闭包的id
    next_id: RefCell&lt;usize&gt;,
    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id
    evt_sender: Sender&lt;usize&gt;,
    // 接受下一个该运行的闭包的id
    evt_reciever: Receiver&lt;usize&gt;,
}

// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. 
// Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.
// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait
// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html
fn set_timeout(ms: u64, cb: impl FnOnce() + 'static) {
    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。
    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。
    // 相当于用.with()就是在使用该变量的函数。
    RT.with(|rt| {
        let id = *rt.next_id.borrow();
        // next_id递增
        *rt.next_id.borrow_mut() += 1;
        // callbacks存 (id: usize, Box&lt;dyn FnOnce() -&gt; ()&gt;)
        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知
        // cb 在输入参数中用的impl FnOnce() + 'static 来限定。
        rt.callbacks.borrow_mut().insert(id, Box::new(cb));
        // The sending-half of Rust's asynchronous channel type. 
        // This half can only be owned by one thread, but it can be cloned to send to other threads.
        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个
        let evt_sender = rt.evt_sender.clone();
        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去
        thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(ms));
            // 在延时结束后，发送当前延时结束的任务id
            evt_sender.send(id).unwrap();
        });
    });
}


impl Runtime {
    fn new() -&gt; Self {
        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver
        let (evt_sender, evt_reciever) = channel();
        Runtime {
            callbacks: RefCell::new(HashMap::new()),
            next_id: RefCell::new(1),
            evt_sender,
            evt_reciever,
        }
    }

    // 这儿是在运行一个函数.
    fn run(&amp;self, program: fn()) {
        // 直接运行， 
        program();
        // 0ms 运行到这儿
        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。
        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.
        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None
        for evt_id in &amp;self.evt_reciever {
            // 这儿直接从HashMap里remove出对应编号的闭包。
            let cb = self.callbacks.borrow_mut().remove(&amp;evt_id).unwrap();
            cb();
            // 是不是也不需要这句话？
            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了
            if self.callbacks.borrow().is_empty() {
                break;
            }
        }
    }
}

</code></pre>
<h1 id="总结">总结</h1>
<ul>
<li>如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&quot;学歌&quot;。所以，在回调逻辑中 <code>sing_song()</code>作为闭包， <code>learn_song()</code> 作为子线程，主线程运行<code>dance()</code> 。子线程结束后再运行这个闭包。运行顺序是 <code>learn_song()</code> （子线程）和 <code>dance()</code>  （主线程）同时运行，在两个任务均完成后， 再回调<code>sing_song()</code>这个闭包。</li>
<li><strong>子线程</strong>对应 <strong>“等待资源”</strong> ； <strong>闭包</strong>对应“<strong>接收到等待资源后的操作”</strong>。</li>
</ul>
<pre><code class="language-rust">async fn learn_and_sing() {
    // 在唱歌之前等待学歌完成
    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。
    let song = learn_song().await;
    sing_song(song).await;
}
 async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成
     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞
     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，
     // 这个‘async_main'函数就会变成阻塞状态，并生成一个执行器
    futures::join!(f1, f2)
}
 fn main() {
    block_on(async_main());
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc]]></title>
        <id>https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/">
        </link>
        <updated>2020-11-23T12:15:59.000Z</updated>
        <summary type="html"><![CDATA[<p>对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)</p>
<!-- more -->
<h2 id="const_unit_poc-利用const-generics实现的物理单位库"><code>const_unit_poc</code> ：利用const generics实现的物理单位库</h2>
<p><code>const_unit_poc</code>  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked)]
use const_unit_poc::values::{m, kg, s, N};

let distance = 1.0 * m;
let mass = 18.0 * kg;
let force = distance * mass / (1.8 * s * 2.0 * s);
assert_eq!(force, 5.0 * N);

let mut mutable_distance = 3.2 * m;
mutable_distance -= 0.2 * m;
mutable_distance += 2.0 * m;

assert_eq!(mutable_distance, 5.0 * m);
</code></pre>
<p>代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。</p>
<h2 id="const_unit_poc-源码分析"><code>const_unit_poc</code> 源码分析</h2>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked, doc_cfg)]
#![allow(incomplete_features)]
#![cfg_attr(feature = &quot;non_ascii&quot;, feature(non_ascii_idents))]

use std::ops;

pub mod units;
pub mod values;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_snake_case)]
pub struct SiUnit {
    m: i8,
    kg: i8,
    s: i8,
    A: i8,
    K: i8,
    mol: i8,
    cd: i8,
}

// 后面还有内容
</code></pre>
<p>这里引入了<code>units</code>, <code>values</code>两个mod，并且声明了<code>SiUnit</code> 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。</p>
<p>看到这儿，笔者推测应该是使用 <code>SiUnit</code> 这个结构体来实例化各种常用的单位（如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>），其中成员的值表示该单位表示成基本单位后的指数的值（如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>m</mi><mo>∗</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N=m*s^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>， 则<code>N.m == 1; N.s == -2</code>）。</p>
<p>再看一下引入的模块<code>units</code>的内容</p>
<h3 id="units的实现">units的实现</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs"><code>./src/units.rs</code></a>：</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use super::SiUnit;
const NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };
/// meter
pub const m: SiUnit = SiUnit { m: 1, ..NONE };
/// 中间内容省略
/// lux
pub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };
/// square meter
pub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };
/// cubic meter
pub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };
</code></pre>
<p>的确和猜想一致！注意结构体实例化时候这儿使用了<code>..NONE</code>，这是用已经创建的实例None上<strong>更新部分参数</strong>，创建新的实例，见<a href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">使用结构体更新语法从其他实例创建实例</a>。这儿使用了const使得各个单位全局可见且不可变。</p>
<p>现在已经有了单位，但是我们注意到代码中<code>assert_eq!(mutable_distance, 5.0 * m);</code>不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。</p>
<h3 id="对单位系数的包装">对单位系数的包装</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs"><code>./src/values.rs</code></a>：</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use crate::{units, Quantity};
// base
/// 1 meter
pub const m: Quantity&lt;{ units::m }&gt; = Quantity { raw_value: 1.0 };
/// 1 kilogram
pub const kg: Quantity&lt;{ units::kg }&gt; = Quantity { raw_value: 1.0 };
/// 1 second
pub const s: Quantity&lt;{ units::s }&gt; = Quantity { raw_value: 1.0 };
/// 后面还有
</code></pre>
<p><strong>注意</strong>：<code>use crate::{units, Quantity}</code>, 代表的是导入的当前<code>crate</code>中的<code>units</code>和<code>Quantity</code>。<br>
<strong>const 泛型</strong>: 从这儿的可以大概可以看出，<code>Quantity</code>的泛型参数是一个const常量，包装每一个<code>units.rs</code>中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：<code>Quantity&lt;{ units::m }&gt; { raw_value: 1.0 }</code>。 所以是用<code>raw_value</code>来表示每一个单位的系数。</p>
<p>所以再来看看<code>Quantity</code>的定义吧。</p>
<p>###结构体 <code>Quantity</code>的定义</p>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Quantity&lt;const U: SiUnit&gt; {
    pub raw_value: f64,
}
</code></pre>
<p>简单干脆的使用const 类型作为泛型参数。</p>
<h3 id="加减运算">加减运算</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Add for Quantity&lt;U&gt; {
    type Output = Self;

    fn add(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value + rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::AddAssign for Quantity&lt;U&gt; {
    fn add_assign(&amp;mut self, rhs: Self) {
        self.raw_value += rhs.raw_value;
    }
}

impl&lt;const U: SiUnit&gt; ops::Sub for Quantity&lt;U&gt; {
    type Output = Self;

    fn sub(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value - rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::SubAssign for Quantity&lt;U&gt; {
    fn sub_assign(&amp;mut self, rhs: Self) {
        self.raw_value -= rhs.raw_value;
    }
}
</code></pre>
<p>由于加减运算并不会变单位，所以就是对系数的加减，非常直接。</p>
<h3 id="乘除运算">乘除运算</h3>
<ul>
<li>一个数字与一个Quantity相乘，单位不变：</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Mul&lt;f64&gt; for Quantity&lt;U&gt; {
    type Output = Quantity&lt;U&gt;;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs }
    }
}
</code></pre>
<ul>
<li>两个带单位的量相乘，单位发生变化，也就是<code>Quantity&lt;U&gt;</code>的泛型参数发生了变化，此时需要重新实例化一个<code>Quantity&lt;U&gt;</code>结构体：</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">// Quantity相乘转换为unit相乘，UL.unit_mul(UR)
impl&lt;const UL: SiUnit, const UR: SiUnit&gt; ops::Mul&lt;Quantity&lt;UR&gt;&gt; for Quantity&lt;UL&gt;
where
    Quantity&lt;{ UL.unit_mul(UR) }&gt;: ,
{
    type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;

    fn mul(self, rhs: Quantity&lt;UR&gt;) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs.raw_value }
    }
}
// unit相乘
impl SiUnit {
    const fn unit_mul(self, rhs: Self) -&gt; Self {
        Self {
            m: self.m + rhs.m,
            kg: self.kg + rhs.kg,
            s: self.s + rhs.s,
            A: self.A + rhs.A,
            K: self.K + rhs.K,
            mol: self.mol + rhs.mol,
            cd: self.cd + rhs.cd,
        }
    }
}
</code></pre>
<ul>
<li>这儿对泛型的约束很神奇，竟然是这样写<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;:</code> ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....</li>
</ul>
<pre><code>error: unconstrained generic constant
   --&gt; src\lib.rs:156:5
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
    |
help: consider adding a `where` bound for this expression  
   --&gt; src\lib.rs:156:28
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |                            ^^^^^^^^^^^^^^^^^^^     
</code></pre>
<ul>
<li>另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;</code> ，否则也会出错。这在最近的<a href="https://github.com/rust-lang/rust/pull/79135">Stabilization report</a>里面也有提到。</li>
</ul>
<blockquote>
<p><strong>Const arguments</strong></p>
<p>Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, <strong>most expressions must be contained within a block</strong>, with two exceptions:</p>
<ol>
<li>literals and single-segment path expressions</li>
<li>array lengths</li>
</ol>
<p>This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.</p>
<p>In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // ERR
</code></pre>
<p>To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
</code></pre>
</blockquote>
<p>简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。</p>
<h2 id="总结">总结</h2>
<p>这篇文章主要是了解了const 泛型在做啥，以及如何做的。</p>
<p>通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Rust 异步并发（一）]]></title>
        <id>https://Busy-Bob.github.io/post/rust-yi-bu/</id>
        <link href="https://Busy-Bob.github.io/post/rust-yi-bu/">
        </link>
        <updated>2020-11-22T15:07:53.000Z</updated>
        <summary type="html"><![CDATA[<p>前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。<br>
Rust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用<code>async/.await</code>解决方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。<br>
Rust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用<code>async/.await</code>解决方案。</p>
<!-- more -->
<h1 id="1-为什么需要异步编程">1. 为什么需要异步编程？</h1>
<p>刚开始一直有一个疑问：<strong>既然已经有了多线程技术，多用户访问直接使用多线程，为什么还需要异步呢？</strong> 后来终于明白，异步是用在多用户<strong>同时处理同一资源</strong>时候发挥作用的。</p>
<pre><code>现在用100个用户同时修改一个文件来举例：
</code></pre>
<ul>
<li>
<p><strong>同步</strong>(一般也是<strong>阻塞</strong>)： 程序需要实现<strong>读写锁(<code>std::sync::RwLock</code>)<strong>或</strong>互斥锁(<code>std::sync::Mutex</code>)</strong>，程序会同时产生100个线程，但是只能有一个线程拥有写锁，其他的99个线程均</p>
<ul>
<li>处于<strong>等待状态</strong>，线程不会sleep，会循环获取锁(自旋锁Spinlock)。
<ul>
<li>阻塞的线程还来参与操作系统的抢占式调度，很不科学！为什么不先排好队，用一个线程呢（这也是协程干的事）</li>
</ul>
</li>
<li>或者有起始的<strong>加锁开销</strong>(通常是对互斥锁：①线程会从sleep（加锁）——&gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；②互斥锁在sleep时会陷入到内核态，需要昂贵的系统调用；线程向操作系统请求被挂起是通过一个系统调用，在linux上的实现就是futex)。</li>
</ul>
</li>
<li>
<p><strong>异步</strong>(一般也是<strong>非阻塞</strong>)： 将100个线程根据一定的先后次序<strong>合并成一个线程</strong>(也可能是多个线程？)， 就可以避免锁的产生，从而减少操作系统对线程调用的开销。但是，当线程之间对资源的依赖关系比较复杂的时候，程序的编写就会<strong>十分复杂</strong>。</p>
<ul>
<li><strong>协程</strong>(coroutine)： 实现异步编程的一种方式，是在线程之下的一个单位。协程是语言层面控制数据流的一种“调度”（处理公共资源的时候，相当于<strong>用户态的锁</strong>）， 线程是操作系统层面的“调度”（处理公共资源，使用<strong>操作系统或者硬件的锁(即Mutex或者Spinlock)</strong>）。协程的调度是编译器通过组织运算顺序实现的（通过生成器（等同于一个状态机）实现），线程是通过操作系统来进行抢占式调度的。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">协程wiki</a>：协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。</li>
<li><a href="https://www.zhihu.com/question/332113890/answer/1052024052">互斥锁（mutex）的底层原理是什么？</a></li>
<li><a href="https://www.zhihu.com/question/50185085/answer/1342613525">出于什么样的原因，诞生了「协程」这一概念？</a></li>
</ul>
</li>
</ul>
<p>所以，异步编程是可以直接用复杂的代码结构直接写出来的。比如上面的例子就是在一个线程里面去依次读写100次。而Rust的<code>async/.await</code>解决方案做的工作是 <strong>“将复杂的异步代码 ===&gt; 利用语法糖 ===&gt; 转化为类似于同步的代码(更容易coding)”</strong>  即 <strong>“用同步的语义解决异步问题”</strong> 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.22 伊始]]></title>
        <id>https://Busy-Bob.github.io/post/2020112-yi-shi/</id>
        <link href="https://Busy-Bob.github.io/post/2020112-yi-shi/">
        </link>
        <updated>2020-11-22T08:45:04.000Z</updated>
        <content type="html"><![CDATA[<p>从<strong>今天</strong>开始记录学习和生活。</p>
<p>我也是一个懒惰的小博主啦~😋</p>
]]></content>
    </entry>
</feed>