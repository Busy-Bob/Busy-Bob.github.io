<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Busy-Bob.github.io</id>
    <title>勺海的博客</title>
    <updated>2021-01-10T09:17:20.698Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Busy-Bob.github.io"/>
    <link rel="self" href="https://Busy-Bob.github.io/atom.xml"/>
    <subtitle>尽应尽之事，做让自己开心的事。</subtitle>
    <logo>https://Busy-Bob.github.io/images/avatar.png</logo>
    <icon>https://Busy-Bob.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 勺海的博客</rights>
    <entry>
        <title type="html"><![CDATA[Xilinx FPGA 板上结构知识杂记]]></title>
        <id>https://Busy-Bob.github.io/post/xilinx-fpga-ban-shang-jie-gou-zhi-shi-za-ji/</id>
        <link href="https://Busy-Bob.github.io/post/xilinx-fpga-ban-shang-jie-gou-zhi-shi-za-ji/">
        </link>
        <updated>2021-01-10T06:04:54.000Z</updated>
        <summary type="html"><![CDATA[<p>一点xilinx fpga 板上结构的知识点，记录下来。主要参考《基于FPGA的数字信号处理》一书第八章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一点xilinx fpga 板上结构的知识点，记录下来。主要参考《基于FPGA的数字信号处理》一书第八章。</p>
<!-- more -->
<h1 id="lut和slice">LUT和Slice</h1>
<ul>
<li>zynq-7000中使用的查找表(Look Up Table，LUT)是6位的，其中包含一个5位的LUT。（6位需要的SRAM空间是2^6=64bit，5位是32bit。这应该也是为什么需要一个LUT5来构成LUT6了。）<br>
<img src="https://Busy-Bob.github.io/post-images/1610258789689.png" alt="" loading="lazy"></li>
<li>LUT可以作为RAM和ROM，<strong>逻辑输入作为地址线</strong>，内存作为ROM或者RAM，见<a href="https://electronics.stackexchange.com/a/85465">How does a LUT work, why is it used?</a>。其中SLICEL(slice logic)只能作为ROM，而SLICEM(slice memory)可以作为ROM和分布式的RAM。</li>
</ul>
<table>
<thead>
<tr>
<th>LUT功能</th>
<th>SLICEL</th>
<th>SLICEM</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑函数发生器</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>ROM</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>分布式RAM</td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>移位寄存器</td>
<td></td>
<td>√</td>
</tr>
</tbody>
</table>
<ul>
<li>作为RAM也可以有多种类型，各种需要不同数量的LUT。<br>
<img src="https://Busy-Bob.github.io/post-images/1610268719145.png" alt="" loading="lazy"></li>
<li>SLICEM中1个LUT6可配置为1个32bit的移位寄存器，<strong>逻辑输入端口作为时钟周期延时数</strong>，所以在Xilinx FPGA中实现FIFO的功能，可采用Block RAM的方式，也可采用LUT的方式。</li>
<li>一个LUT6可实现4选1的MUX （数据4位，地址2位）。</li>
<li>一个F7MUX和相邻的两个LUT6可实现一个8选1的MUX。因此，一个SLICE可实现2个8选1的MUX。</li>
<li>4个LUT6、F7AMUX、F7BMUX和F8MUX可实现一个16选1的MUX。因此，一个SLICE可实现一个16选1的MUX</li>
</ul>
<h1 id="dsp基本功能是做乘法运算">DSP：基本功能是做乘法运算</h1>
<ul>
<li>zynq中的DSP(Digital Signal Processing)部分是由DSP48E1组成的，组成基本结构如图：<br>
<img src="https://Busy-Bob.github.io/post-images/1610267218196.png" alt="" loading="lazy"></li>
<li>由五部分构成：
<ul>
<li>对外端口</li>
<li><strong>预加器</strong>(pre-adder)</li>
<li><strong>乘法器</strong>(MULT)</li>
<li><strong>逻辑运算单元</strong>(ALU)</li>
<li>模式检测电路<br>
<img src="https://Busy-Bob.github.io/post-images/1610267326031.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>对外<strong>端口</strong>有：
<ul>
<li>操作数输入输出端口</li>
<li>模式配置端口</li>
<li>级联端口<br>
<img src="https://Busy-Bob.github.io/post-images/1610267484853.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>简化结构图为：<br>
<img src="https://Busy-Bob.github.io/post-images/1610267801525.png" alt="" loading="lazy"></li>
<li>单指令多数据模式即SIMD ( Single Instruction, Multiple Data)。它使得48bit的ALU可配置为4个 12bit的ALU (执行加法、减法或位逻辑运算)或者2个24bit的ALU。</li>
<li>采用VHDL或Verilog代码描述时，<strong>乘法、乘加/乘减和乘累加运算会被自动映射为 DSP48E1,而加法、减法和累加运算默认情况下釆用常规逻辑资源实现</strong>。若也希望它们被映 射为DSP48E1,则需要通过综合属性use_dsp48对其进行约束。</li>
<li>应用：
<ul>
<li>48bit累加运算(比加法器多一个寄存器用来存取前面加过的数据，寄存器是需要时钟驱动的。)</li>
<li>2输入48bit数据相加之后累加</li>
<li>96bit加法、减法运算（需要级联）</li>
<li>96bit累加运算（需要级联）</li>
<li>乘累加运算(两个输入数据相乘并对乘积结果累加)：</li>
<li>复数乘法运算</li>
</ul>
</li>
</ul>
<h1 id="bram-block-ram">BRAM (Block RAM)</h1>
<ul>
<li>块RAM (根据地址写入和输出)</li>
<li>Block RAM (BRAM)在FPGA设计中扮演着一个重要的角色即数据存储或缓存</li>
<li>zynq中每个BRAM达到了 36Kb,由两个18Kb BRAM拼接而成.</li>
<li>BRAM在不牺牲很大带宽的前提下，提供了更大的储存密度。带宽的牺牲主要在于<strong>每个周期BRAM只有1-2个入口可以被接通</strong>(对应单端口和双端口)。</li>
<li>利用BRAM实现逻辑运算功能本质上而言是将BRAM配置为ROM,它就像一个大的 查找表（LUT）。</li>
<li>对一些固定的数据进行存储，这就需要用到 ROM，可存在BRAM里。</li>
</ul>
<h1 id="单端口ram-伪双端口ram双端口ram和fifo"><a href="https://zhuanlan.zhihu.com/p/96616326">单端口RAM、伪双端口RAM，双端口RAM和FIFO</a></h1>
<ul>
<li>单端口RAM（Single-Port RAM）
<ul>
<li>输入只有<strong>一组数据线</strong>和<strong>一组地址线</strong></li>
<li>只有一个时钟</li>
<li><strong>读写共用地址线</strong></li>
<li>所以一个时钟周期只能读或者只能写。</li>
</ul>
</li>
<li>伪双端口RAM（Simple Dual-Port RAM）
<ul>
<li>输入有<strong>一组数据线</strong>，<strong>两组地址线</strong>。</li>
<li><strong>两个时钟</strong>。</li>
<li>一个端口只读，另一个端口只写，但写入和读取的时钟可以不同，且位宽比可以不是1:1</li>
</ul>
</li>
<li>双端口RAM（True Dual-Port RAM）
<ul>
<li>输入有<strong>两组地址线</strong>和<strong>两组数据线</strong></li>
<li><strong>两个时钟</strong></li>
<li>两个端口都有读写的功能。</li>
</ul>
</li>
<li>FIFO (First-in, first-out)
<ul>
<li>一个端口只读，另一个端口只写。</li>
<li><strong>先入先出，没有地址线</strong></li>
<li>上述三种RAM都可以寻址，<strong>FIFO不能寻址</strong>。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zynq 中查看用HLS 生成的IP核端口对应的内存空间]]></title>
        <id>https://Busy-Bob.github.io/post/zynq-zhong-cha-kan-yong-hls-sheng-cheng-de-ip-he-duan-kou-dui-ying-de-nei-cun-kong-jian/</id>
        <link href="https://Busy-Bob.github.io/post/zynq-zhong-cha-kan-yong-hls-sheng-cheng-de-ip-he-duan-kou-dui-ying-de-nei-cun-kong-jian/">
        </link>
        <updated>2021-01-07T09:34:33.000Z</updated>
        <summary type="html"><![CDATA[<p>找了一会儿才找到, 所以记录下来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>找了一会儿才找到, 所以记录下来。</p>
<!-- more -->
<p>用HLS生成的ip核，使用axi-lite协议，找不到pynq中top函数变量对应的内存空间地址。</p>
<ul>
<li>
<p>HLS中，Synthesis Summary的最后一项可以看到HW info.<br>
<img src="https://Busy-Bob.github.io/post-images/1610107689191.png" alt="" loading="lazy"></p>
</li>
<li>
<p>HLS生成的verilog文件(XXXXX_control_s_axi.v)中，有接口地址信息的注释。</p>
</li>
</ul>
<pre><code>//------------------------Address Info-------------------
// 0x00 : reserved
// 0x04 : reserved
// 0x08 : reserved
// 0x0c : reserved
// 0x10 : Data signal of a
//        bit 31~0 - a[31:0] (Read/Write)
// 0x14 : reserved
// 0x18 : Data signal of b
//        bit 31~0 - b[31:0] (Read/Write)
// 0x1c : reserved
// 0x20 : Data signal of c
//        bit 31~0 - c[31:0] (Read)
// 0x24 : Control signal of c
//        bit 0  - c_ap_vld (Read/COR)
//        others - reserved
// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)
</code></pre>
<ul>
<li>pynq中，可通过<code>register_map</code>直接查看地址，或者直接操作变量。</li>
</ul>
<pre><code class="language-python">from pynq import Overlay
overlay = Overlay('./design_1.bit')
add_ip = overlay.add_0

add_ip.register_map.a = 3
add_ip.register_map.b = 4
c = add_ip.register_map.c
c.address
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vitis HLS Coding Styles]]></title>
        <id>https://Busy-Bob.github.io/post/vitis-hls-coding-styles/</id>
        <link href="https://Busy-Bob.github.io/post/vitis-hls-coding-styles/">
        </link>
        <updated>2021-01-04T08:57:57.000Z</updated>
        <summary type="html"><![CDATA[<p>参考Xilinx文档，<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html">Vitis HLS Coding Styles</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>参考Xilinx文档，<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html">Vitis HLS Coding Styles</a></p>
<!-- more -->
<h1 id="不支持的cc部分">不支持的C/C++部分</h1>
<h2 id="系统调用">系统调用</h2>
<ul>
<li><code>printf()</code>， <code>fprintf(stdout,)</code>等不会影响算法执行的系统调用——忽略掉。</li>
<li><code>getc()</code>, <code>time()</code>, <code>sleep()</code> 等系统调用——不被接受。</li>
<li>可以使用<code>__SYNTHESIS__</code>宏来区分<strong>综合</strong>与<strong>调试</strong>过程</li>
</ul>
<pre><code class="language-c">void hier_func4(din_t A, din_t B, dout_t *C, dout_t *D)
{
    dint_t apb, amb;

    sumsub_func(&amp;A, &amp;B, &amp;apb, &amp;amb);
#ifndef __SYNTHESIS__
    FILE *fp1; // The following code is ignored for synthesis
    char filename[255];
    sprintf(filename, Out_apb_ % 03d.dat, apb);
    fp1 = fopen(filename, w);
    fprintf(fp1, % d \n, apb);
    fclose(fp1);
#endif
    shift_func(&amp;apb, &amp;amb, C, D);
}

</code></pre>
<h2 id="动态内存">动态内存</h2>
<ul>
<li><code>malloc()</code>， <code>new</code> 等动态分配内存的不行, 不能在堆上分配内存，必须在栈上。（因为该HLS技术是静态分析）</li>
<li>一种改动方法是直接对栈上变量取指针：</li>
</ul>
<pre><code class="language-C">#include &quot;malloc_removed.h&quot;
#include &lt;stdlib.h&gt;
//#define NO_SYNTH

dout_t malloc_removed(din_t din[N], dsel_t width) {  

#ifdef NO_SYNTH
 long long *out_accum = malloc (sizeof(long long));
 int* array_local = malloc (64 * sizeof(int));
#else
 long long _out_accum;
 long long *out_accum = &amp;_out_accum;
 int _array_local[64];
 int* array_local = &amp;_array_local[0];
#endif
// 中间计算省略
 return *out_accum;
}
</code></pre>
<h2 id="指针的一些限制">指针的一些限制</h2>
<h3 id="通用指针类型转换">通用指针类型转换</h3>
<p>HLS 只支持C/C++原生类型的转换</p>
<h3 id="指针数组">指针数组</h3>
<p>如果每个指针指向一个标量或一个标量数组，则Vitis HLS支持指针数组的综合。但指针数组不能指向额外的指针（应该类似二维数组的行、列指针）</p>
<h3 id="函数指针">函数指针</h3>
<p>不支持</p>
<h2 id="递归函数">递归函数</h2>
<ul>
<li>不支持。不管最后递归次数是不是有限的。</li>
<li>可以使用C++模板来构造<strong>可以用来综合的尾递归</strong>，因为C++中支持非类型模板参数（Nontype Template Parameters），类似Rust中的const泛型，这儿的模板参数为<code>data_t</code>类型的一个值 N。<a href="https://github.com/Xilinx/HLS-Tiny-Tutorials/tree/master/algorithm_template_fir_filter">例子如下</a>：</li>
</ul>
<pre><code class="language-C++">// Tail recursive call
template&lt;data_t N&gt; 
	struct fibon_s {
    template&lt;typename T&gt;
    static T fibon_f(T a, T b) {
		return fibon_s&lt;N-1&gt;::fibon_f(b, (a+b));
  }
};

// Termination condition
template&lt;&gt; struct fibon_s&lt;1&gt; {
  template&lt;typename T&gt;
  static T fibon_f(T a, T b) {
    return b;
  }
};

void cpp_template(data_t a, data_t b, data_t &amp;dout){
  dout = fibon_s&lt;FIB_N&gt;::fibon_f(a,b);
}
</code></pre>
<h2 id="stl">STL</h2>
<p>有动态内存和递归，不能使用。</p>
<h1 id="函数">函数</h1>
<p>顶层函数不能是静态的。</p>
<h2 id="内联函数">内联函数</h2>
<ul>
<li>综合时候花费时间、内存较多，但效果更好。</li>
<li>没有独立的RTL文件和报告了。</li>
</ul>
<h2 id="代码风格的影响">代码风格的影响</h2>
<ul>
<li>影响函数参数和接口</li>
<li>直接用函数接口的输入量来驱动变量时候，程序就不会使用某些优化手段。（如输入量是循环索引的上限）</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;

ap_int&lt;24&gt; foo(int x, int y) {  
 int tmp;

 tmp = (x * y);
 return tmp
} 
</code></pre>
<p>上述代码这会导致一个32-bit乘法器，输出再被截取。<br>
下面这个代码直接产生一个24-bit乘法器。</p>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
typedef ap_int&lt;12&gt; din_t;
typedef ap_int&lt;24&gt; dout_t;

dout_t func_sized(din_t x, din_t y) {  
 int tmp;

 tmp = (x * y);
 return tmp
}
</code></pre>
<h2 id="cc内置函数">C/C++内置函数</h2>
<ul>
<li>只支持以下两个</li>
<li><code>__builtin_clz(unsigned int x)</code>: Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.</li>
<li><code>__builtin_ctz(unsigned int x)</code>: Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.</li>
</ul>
<h1 id="循环">循环</h1>
<ul>
<li>支持得很好。可以切流水线，展开、部分展开、合并和扁平化</li>
<li><strong>不要使用全局变量作为循环变量</strong>，否则会阻碍代码优化</li>
</ul>
<h2 id="循环变量范围">循环变量范围</h2>
<ul>
<li>循环变量的上限如果是变量，就难以在综合时候优化。</li>
<li>循环变量的上限如果是变量，循环的latency无法确定。</li>
<li>循环变量的上限如果是变量，设计的性能未知。</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
#define N 32

typedef ap_int&lt;8&gt; din_t;
typedef ap_int&lt;13&gt; dout_t;
typedef ap_uint&lt;5&gt; dsel_t;

dout_t code028(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0;x&lt;width; x++) {
 out_accum += A[x];
 }

 return out_accum;
}
</code></pre>
<p>为了克服无法分析性能的缺点，一般是加上<br>
<code>#pragma HLS loop_tripcount min=&lt;int&gt; max=&lt;int&gt; avg=&lt;int&gt;</code><br>
或者是使用断言<code>assert</code></p>
<pre><code class="language-C++">void foo (num_samples, ...) {
  int i;
  ...
  loop_1: for(i=0;i&lt; num_samples;i++) {
   #pragma HLS loop_tripcount min=12 max=16
   ...
    result = a + b;
  }
}
</code></pre>
<p><strong>注意</strong>：该编译选项只用于分析，不会用于综合。</p>
<ul>
<li><strong>对于具有可变边界的循环的解决方案是：在循环中有条件地执行，并且令循环迭代的次数为固定值。</strong></li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
#define N 32

typedef ap_int&lt;8&gt; din_t;
typedef ap_int&lt;13&gt; dout_t;
typedef ap_uint&lt;5&gt; dsel_t;

dout_t loop_max_bounds(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0; x&lt;N; x++) {
 if (x&lt;width) {
  out_accum += A[x];
 }
 }

 return out_accum;
}
</code></pre>
<h2 id="将循环流水线化">将循环流水线化</h2>
<p>通常通过流水线最内层的循环来找到面积和性能之间的最佳平衡。</p>
<pre><code class="language-C++">#include &quot;loop_pipeline.h&quot;

dout_t loop_pipeline(din_t A[N]) {  

 int i,j;
 static dout_t acc;

 LOOP_I:for(i=0; i &lt; 20; i++){
 LOOP_J: for(j=0; j &lt; 20; j++){
 acc += A[i] * j;
 }
 }

 return acc;
}
</code></pre>
<ul>
<li>
<p>Pipeline <code>LOOP_J</code></p>
<ul>
<li>只需调度一个乘法器操作和一个数组访问</li>
<li>Latency is approximately 400 cycles (20x20) and requires less than 100 LUTs and registers (the I/O control and FSM are always present).</li>
</ul>
</li>
<li>
<p>Pipeline <code>LOOP_I</code></p>
<ul>
<li>内部循环展开20次。</li>
<li>需调度20个乘法器操作和20个数组访问</li>
<li>Latency is approximately 20 cycles but requires a few hundred LUTs and registers. About 20 times the logic as first option, minus any logic optimizations that can be made.</li>
</ul>
</li>
<li>
<p>Pipeline <code>function loop_pipeline</code></p>
<ul>
<li>需调度400个乘法器操作和400个数组访问</li>
<li>Latency is approximately 10 (20 dual-port accesses) but requires thousands of LUTs and registers (about 400 times the logic of the first option minus any optimizations that can be made)</li>
</ul>
</li>
</ul>
<h3 id="不完美的循环嵌套">不完美的循环嵌套</h3>
<p>不完美的循环嵌套，或者无法将循环嵌套展开，会导致进入和退出循环的额外时钟周期。</p>
<h2 id="循环并行">循环并行</h2>
<ul>
<li>HLS会使得逻辑和函数并行，但是并不会调度循环来并行。</li>
<li>例子中SUM_X和SUM_Y不会并行调度，而是顺序的。（因为两个循环变量有不同的上限）</li>
</ul>
<pre><code class="language-C++">#include &quot;loop_sequential.h&quot;

void loop_sequential(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {  

 dout_t X_accum=0;
 dout_t Y_accum=0;
 int i,j;

 SUM_X:for (i=0;i&lt;xlimit; i++) {
 X_accum += A[i];
 X[i] = X_accum;
}

 SUM_Y:for (i=0;i&lt;ylimit; i++) {
 Y_accum += B[i];
 Y[i] = Y_accum;
 }
} 
</code></pre>
<p>把两个循环装在function里面就可以并行了</p>
<pre><code class="language-C++">#include &quot;loop_functions.h&quot;

void sub_func(din_t I[N], dout_t O[N], dsel_t limit) {
 int i;
 dout_t accum=0;
  
 SUM:for (i=0;i&lt;limit; i++) {
 accum += I[i];
 O[i] = accum;
 }

}

void loop_functions(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {

 sub_func(A,X,xlimit);
 sub_func(B,Y,ylimit);
}
</code></pre>
<ul>
<li>这是在函数中捕获循环以利用并行性的原则</li>
</ul>
<h2 id="循环依赖">循环依赖</h2>
<ul>
<li>一次循环开始可能会依赖上一次循环的结束。</li>
</ul>
<pre><code class="language-C++"> Minim_Loop: while (a != b) { 
 if (a &gt; b) 
 a -= b; 
 else 
 b -= a;
 }
</code></pre>
<ul>
<li>解决方案是<strong>尽量确保初始操作尽早执行</strong>(应该就是对循环变量做修改等)</li>
</ul>
<h2 id="在c类中不会展开循环">在c++类中不会展开循环</h2>
<ul>
<li>应小心确保循环归纳变量不是类的数据成员，因为这会防止循环被展开。</li>
</ul>
<pre><code class="language-C++">template &lt;typename T0, typename T1, typename T2, typename T3, int N&gt;
class foo_class
{
private:
    pe_mac&lt;T0, T1, T2&gt; mac;

public:
    T0 areg;
    T0 breg;
    T2 mreg;
    T1 preg;
    T0 shift[N];
    int k; // Class Member
    T0 shift_output;
    void exec(T1 *pcout, T0 *dataOut, T1 pcin, T3 coeff, T0 data, int col)
    {
    Function_label0:;
#pragma HLS inline off
    SRL:
        for (k = N - 1; k &gt;= 0; --k)
        {
#pragma HLS unroll // Loop will fail UNROLL
            if (k &gt; 0)
                shift[k] = shift[k - 1];
            else
                shift[k] = data;
        }

        *dataOut = shift_output;
        shift_output = shift[N - 1];
    }

    *pcout = mac.exec1(shift[4 * col], coeff, pcin);
};
</code></pre>
<h1 id="数组">数组</h1>
<ul>
<li>仿真时候内存不够怎么办？一个妥协的方法是动态内存。</li>
<li>定点数占用内存 &gt;  arbitrary precision type &gt; C自带类型</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
  
  int i, acc; 
#ifdef __SYNTHESIS__
  // Use an arbitrary precision type &amp; array for synthesis
  ap_int&lt;32&gt;  la0[10000000], la1[10000000]; 
#else 
  // Use an arbitrary precision type &amp; dynamic memory for simulation
 ap_int&lt;int32&gt; *la0 = malloc(10000000  * sizeof(ap_int&lt;32&gt;));
 ap_int&lt;int32&gt; *la1 = malloc(10000000  * sizeof(ap_int&lt;32&gt;));
#endif
  for (i=0 ; i &lt; 10000000; i++) { 
      acc = acc + la0[i] + la1[i]; 
  } 
</code></pre>
<ul>
<li><strong>数组长度小于1024</strong>：实例化为FIFO</li>
<li><strong>数组长度大于1024</strong>： 保存在block RAM或LUTRAM或UltraRAM</li>
</ul>
<h2 id="数组访问和性能">数组访问和性能</h2>
<ul>
<li>对数组访问次数越多，越会限制性能。（尤其是在一个循环中的情况）</li>
<li>所以有如下的更改策略：</li>
</ul>
<pre><code class="language-C++">#include &quot;array_mem_bottleneck.h&quot;
 
dout_t array_mem_bottleneck(din_t mem[N]) {  

 dout_t sum=0;
 int i;

 SUM_LOOP:for(i=2;i&lt;N;++i)
   sum += mem[i] + mem[i-1] + mem[i-2];
    
 return sum;
}
</code></pre>
<p>变成</p>
<pre><code class="language-C++">#include &quot;array_mem_perform.h&quot;
 
dout_t array_mem_perform(din_t mem[N]) {  

 din_t tmp0, tmp1, tmp2;
 dout_t sum=0;
 int i;

 tmp0 = mem[0];
 tmp1 = mem[1];
 SUM_LOOP:for (i = 2; i &lt; N; i++) { 
 tmp2 = mem[i];
 sum += tmp2 + tmp1 + tmp0;
 tmp0 = tmp1;
 tmp1 = tmp2;
 } 
    
 return sum;
}
</code></pre>
<h3 id="fifo访问">FIFO访问</h3>
<p>因为是先入先出，所以必须要从0开始顺序访问。</p>
<h2 id="接口上的数组top函数参数">接口上的数组（top函数参数）</h2>
<p>HLS会默认会将接口上数组认为是内存。HLS有两种假设的实现方式</p>
<ul>
<li><strong>off-chip的内存</strong>：</li>
<li><strong>标准的block RAM，延迟只有1clock</strong>： 数据会在地址给定后一个周期准备好。</li>
</ul>
<p>所以需要：</p>
<ul>
<li>指定是RAM还是FIFO的接口</li>
<li>指定RAM是单端口还是双端口的RAM，预编译选项中的<code>storage_type</code>，语法是<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html#jit1504034365862__ad411155">#pragma HLS interface</a></li>
<li>指定RAM延时， <code>latency</code></li>
<li>ARRAY_PARTITION, ARRAY_RESHAPE 两个优化输入的命令。语法是<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html?#ariaid-title4">#pragma HLS array_partition</a>， 相当于<strong>用寄存器代替RAM</strong>，或者用更小的RAM来代替大的RAM。</li>
</ul>
<p><strong>默认情况下</strong>：</p>
<ul>
<li>默认是单端口的RAM。</li>
<li>如果initiation interval or latency可以被减少，则使用双端口的RAM</li>
</ul>
<h2 id="数组初始化">数组初始化</h2>
<ul>
<li>建议使用<code>static</code>关键字来建立数组，保证HLS将其变成内存。</li>
<li>确保初始化大内存不会造成操作开销。不用static会在初始化时候，写入这些值，有一定时间开销。</li>
</ul>
<h3 id="实例化一个rom">实例化一个ROM</h3>
<ul>
<li>建议使用<code>const</code>来做一个只读的ROM，如果不加，也没有问题。综合过程自己会进行优化。</li>
</ul>
<h1 id="数据类型">数据类型</h1>
<h2 id="cc-类型">C/C++ 类型</h2>
<p>略</p>
<h2 id="arbitrary-precision-ap-data-types-任意精度数据类型">Arbitrary Precision (AP) Data Types 任意精度数据类型</h2>
<ul>
<li><strong>C语言可以这样写</strong></li>
</ul>
<pre><code class="language-C++">#include &quot;types.h&quot;

typedef int6 dinA_t;
typedef int12 dinB_t;
typedef int22 dinC_t;
typedef int33 dinD_t;
typedef int18 dout1_t;
typedef uint13 dout2_t;
typedef int22 dout3_t;
typedef int6 dout4_t;
</code></pre>
<ul>
<li><strong>C++模版这样写</strong>，还有一个好处是可以定义超大的数</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
void foo_top (…) {
  
 ap_int&lt;9&gt;  var1;           // 9-bit
 ap_uint&lt;10&gt;  var2;         // 10-bit unsigned
</code></pre>
<h3 id="定点数-arbitrary-precision-fixed-point-data-types">定点数 Arbitrary Precision Fixed-Point Data Types</h3>
<pre><code class="language-C++">#include &lt;ap_fixed.h&gt;
...
ap_fixed&lt;18,6,AP_RND &gt; my_type;
...
ap_fixed&lt;2, 0&gt; a = -0.5;    // a can be -0.5,
ap_ufixed&lt;1, 0&gt; x = 0.5;    // 1-bit representation. x can be 0 or 0.5
ap_ufixed&lt;1, -1&gt; y = 0.25;  // 1-bit representation. y can be 0 or 0.25
const ap_fixed&lt;1, -7&gt; z = 1.0/256;  // 1-bit representation for z = 2^-8
</code></pre>
<p>四个泛型参数分别为，见<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/use_arbitrary_precision_data_type.html#guo1585572335601">Fixed-Point Identifier Summary</a>：</p>
<ul>
<li>总长度</li>
<li>整数位数（可以为负数，见例子）</li>
<li>量化模式</li>
<li>溢出饱和位数量</li>
</ul>
<h2 id="复合数据类型">复合数据类型</h2>
<h3 id="struct"><code>struct</code></h3>
<ul>
<li>默认成员是分解的。<strong>结构体的数组实现为多个数组</strong>，结构体的每个成员都有一个单独的数组。</li>
<li>利用pragma指令控制是否分解。</li>
</ul>
<h3 id="enum"><code>enum</code></h3>
<p>略</p>
<h3 id="unions"><code>unions</code></h3>
<ul>
<li>HLS综合并不保证使用相同的内存或者寄存器</li>
</ul>
<h3 id="类型限定符">类型限定符</h3>
<ul>
<li><code>volatile</code>：
<ul>
<li>综合不会进行优化</li>
<li>Arbitrary precision types do not support the volatile qualifier（计算时候）</li>
</ul>
</li>
<li><code>static</code>：
<ul>
<li>RTL等价是寄存器、触发器和内存。</li>
<li>config_rtl 需要配置，不然默认复位不会初始化。</li>
</ul>
</li>
<li><code>const</code>：
<ul>
<li>常量或者ROM</li>
</ul>
</li>
</ul>
<h2 id="全局变量">全局变量</h2>
<p>自由使用，但是只存在该ip核内部。</p>
<h2 id="指针">指针</h2>
<p>可以综合，但尽量避免使用。尤其是以下情况：</p>
<ul>
<li>同一个函数中，一个指针被读写多次</li>
<li>指针类型转换仅限C/C++标准类型</li>
</ul>
<h3 id="接口处使用指针top函数的参数中">接口处使用指针（top函数的参数中）</h3>
<ul>
<li>基本指针：
<ul>
<li>指针可以合成为一个简单的<strong>线接口</strong>或使用握手的接口协议。</li>
<li>要合成一个FIFO接口，指针必须是只读或只写的。</li>
</ul>
</li>
<li>指针运算：
<ul>
<li>不能实现，不能实现无序访问。</li>
<li>需要变成数组，用RAM实现。</li>
</ul>
</li>
<li>流数据
<ul>
<li>C++ 编译器可能会优化指针的访问，所以需要加volatile。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">#include &quot;pointer_stream_good.h&quot;

void pointer_stream_good ( volatile dout_t *d_o,  volatile din_t *d_i) {
 din_t acc = 0;

 acc += *d_i;
 acc += *(d_i+1);
 *d_o = acc;
 acc += *(d_i+2);
 acc += *(d_i+3);
 *(d_o+1) = acc;
} 
</code></pre>
<h2 id="vector类型">Vector类型</h2>
<h3 id="hls的vector类型是为了simd操作">HLS的Vector类型是为了SIMD操作</h3>
<ul>
<li>single-instruction multiple-data (SIMD)： 单指令，多数据。</li>
<li>Vitis HLS提供的一个模版类型<code>hls::vector&lt;T, N&gt;</code>: 一个有N个T类型的元素，T必须重载了数学运算。</li>
<li>最佳性能是在<strong>T的位宽</strong>和<strong>N的值</strong>均为2的幂时。</li>
<li>在<code>hls::vector</code>上的运算操作都会被并行化，所以矩阵运算一般使用这个。</li>
</ul>
<pre><code class="language-C++">#include &lt;hls_vector.h&gt;
hls::vector&lt;T,N&gt;  aVec;
</code></pre>
<h3 id="vector-内存布局">Vector 内存布局</h3>
<ul>
<li>Vctor储存是对齐到2的n次方的。所以性能最好的时候是大小和位宽都为2的幂的时候。</li>
<li>实现方式如下：</li>
</ul>
<pre><code class="language-C++">constexpr size_t gp2(size_t N)
{
    return (N &gt; 0 &amp;&amp; N % 2 == 0) ? 2 * gp2(N / 2) : 1;
}
 
template&lt;typename T, size_t N&gt; class alignas(gp2(sizeof(T) * N)) vector
{
    std::array&lt;T, N&gt; data;
};
</code></pre>
<h1 id="c类和模版">C++类和模版</h1>
<ul>
<li>类是完全支持的。</li>
<li>不建议在类中使用全局变量，会阻碍优化</li>
<li>模版是支持的。但不能作为顶层函数。</li>
</ul>
<h1 id="断言">断言</h1>
<ul>
<li>断言可以用在综合中，提供范围的信息。如循环上限等。（不像tripcount 只能用于分析）</li>
</ul>
<h1 id="高性能hls">高性能HLS</h1>
<ul>
<li>是最大程度地减少对顶层函数参数的访问。</li>
<li>在阵列中设置默认值会花费时钟周期和性能。</li>
<li>多次读取和重新读取数据会消耗时钟周期和性能。</li>
<li>以任意或随机访问方式访问数据要求将数据存储在本地数组中，浪费资源。</li>
</ul>
<h2 id="确保数据的连续流和数据重用">确保数据的连续流和数据重用</h2>
<ul>
<li>将数据从CPU或系统内存传输到FPGA，则通常会以<strong>流传输方式</strong>进行传输。从FPGA传输回系统的数据也应以这种方式执行。</li>
<li><code>hls::stream</code> , 顺序访问，表现为一个无限深度的FIFO。</li>
<li>在CPU体系结构中，通常避免有条件或分支操作。当程序需要分支时，它将丢失存储在CPU提取管线中的所有指令。<strong>在FPGA体系结构中，每个条件分支的硬件中已经存在一条单独的路径，并且不会与流水线任务内部的分支相关的性能下降。这只是选择要使用哪个分支的一种情况。</strong></li>
<li><a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html">HLS Pragmas</a>的使用。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vitis HLS 的Tiny Tutorial部分代码分析]]></title>
        <id>https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/</id>
        <link href="https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/">
        </link>
        <updated>2021-01-04T06:15:07.000Z</updated>
        <summary type="html"><![CDATA[<p>对例子中的语法等的一点记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>对例子中的语法等的一点记录</p>
<!-- more -->
<h1 id="背景介绍">背景介绍</h1>
<ul>
<li><strong>HLS</strong> (high-level synthesis)： 高级综合, 用 C/C++为FPGA开发 RTL IP.</li>
<li><strong>Vitis HLS</strong>:  在Vivado 2020版本中替代原先的Vivado HLS, 功能略有差异，在Vivado HLS中的例子直接在Vitis HLS上跑会报错。详细比较见<a href="https://cloud.tencent.com/developer/article/1745199">Vivado HLS和Vitis HLS什么区别？</a></li>
<li><strong>HLS中的pragma语法</strong>: <a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html">HLS Pragmas</a></li>
</ul>
<h1 id="内容">内容</h1>
<ul>
<li><code>#pragma HLS dataflow</code>
<ul>
<li>默认情况下，Vitis HLS工具试图最小化延迟并提高并发性。但是，数据依赖性可能会限制这一点。DATAFLOW优化使<strong>函数或循环中的操作能够在上一个函数或循环完成其所有操作之前开始操作</strong>。（能够分析更细）。</li>
<li>也能够解决两个不依赖循环不并行情况（类似于封装进函数）。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">void diamond(data_t vecIn[N], data_t vecOut[N])
{
  data_t c1[N], c2[N], c3[N], c4[N];
#pragma HLS dataflow
  funcA(vecIn, c1, c2);
  funcB(c1, c3);
  funcC(c2, c4);
  funcD(c3, c4, vecOut);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609835551513.png" alt="" loading="lazy"></figure>
<ul>
<li><code>#pragma HLS pipeline rewind</code>
<ul>
<li>构造一个连续循环的流水线。两次循环之间没有暂停。</li>
<li>不能包含条件分支 (if-else)</li>
<li>只支持循环，不支持函数的流水线化。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">  for (int i = 0; i &lt; N; i++)
  {
#pragma HLS pipeline rewind
#pragma HLS unroll factor = 2
    data_t t = in[i] * 3;
    out1[i] = t;
    out2[i] = t;
  }
</code></pre>
<ul>
<li><code>#pragma HLS unroll factor = 2</code>
<ul>
<li>将循环展开多少次</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">for(int i = 0; i &lt; X; i++) {
  pragma HLS unroll factor=2
  a[i] = b[i] + c[i];
}
</code></pre>
<p>变成：</p>
<pre><code class="language-C++">for(int i = 0; i &lt; X; i += 2) {
  a[i] = b[i] + c[i];
  if (i+1 &gt;= X) break;
  a[i+1] = b[i+1] + c[i+1];
}
</code></pre>
<ul>
<li><code>#pragma HLS function_instantiate variable=&lt;variable&gt;</code>
<ul>
<li>FUNCTION_INSTANTIATE编译指示用于为函数的每个实例创建唯一的RTL实现，从而可以根据函数调用对每个实例进行本地优化。因为：调用函数时，<strong>函数的某些输入可以是恒定值</strong>，并使用它来简化周围的控制结构并<strong>生成更小的</strong>，<strong>更优化的功能块</strong>。</li>
<li><code>variable</code>是必需的参数，用于定义要用作常量的函数参数。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">char foo(char inval, char incr) {
#pragma HLS INLINE OFF
#pragma HLS FUNCTION_INSTANTIATE variable=incr
 return inval + incr;
}

void top(char inval1, char inval2, char inval3,
 char *outval1, char *outval2, char *outval3)
{
 *outval1 = foo(inval1,   0);
 *outval2 = foo(inval2,   1);
 *outval3 = foo(inval3, 100);
}
</code></pre>
<ul>
<li><strong>不完美的循环(imperfect loop)</strong>:
<ul>
<li>内层循环上限是一个变量。</li>
<li>循环体并非全部在最里层循环中。</li>
<li>所以<strong>没法展开</strong>，会造成额外的进出循环的时钟周期。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">    LOOP_I:for(i=0; i &lt; 20; i++){
        acc = 0;
        LOOP_J: for(j=0; j &lt; 20; j++){
            acc += A[j] * j;
        }
        if (i%2 == 0)
            B[i] = acc / 20;
        else
            B[i] = 0;
    }
</code></pre>
<ul>
<li>将不完美循环改写成完美循环的trick：<strong>使用条件语句</strong>。</li>
</ul>
<pre><code class="language-C++">    LOOP_I:for(i=0; i &lt; 20; i++){
        LOOP_J: for(j=0; j &lt; 20; j++){
            if(j==0) acc = 0;
            acc += A[j] * j;
            if(j==19) {
                if (i%2 == 0)
                    B[i] = acc / 20;
                else
                    B[i] = 0;
            }
        }
    }
</code></pre>
<ul>
<li>
<p>循环可以没有label，HLS会生成默认label。</p>
</li>
<li>
<p>循环上限为变量的优化方法： <strong>使用条件语句</strong>。</p>
</li>
</ul>
<pre><code class="language-C++">  LOOP_X:for (x=0;x&lt;N-1; x++) {
    if (x&lt;width) {
      out_accum += A[x];
    }
  }
</code></pre>
<ul>
<li>可以利用两个独立的模块来压缩流水的II （用模版实现较为方便，需要配合上多路选择器）</li>
</ul>
<pre><code class="language-C++">//                    +--proc--&gt;[ II=2 ]--+
//                   /                     \               
// in --&gt;[demux II=1]                       [mux II=1]---&gt; out
//                   \                     /
//                    +--proc--&gt;[ II=2 ]--+

#include &quot;example.h&quot;

//--------------------------------------------
template &lt;int ID&gt;
void proc(stream&lt;int&gt; &amp;in, stream&lt;int&gt; &amp;out)
{
    for (int i = 0; i &lt; 25; i++)
    {
#pragma HLS PIPELINE II=2
#pragma HLS LATENCY min=2 max=2
        int var;
        in.read(var);
        out.write(var);
    }
}

//--------------------------------------------
void mux(stream&lt;int&gt; (&amp;inter)[2], stream&lt;int&gt; &amp;mux_output)
{
    int mux_sel = 0;
    for (int i = 0; i &lt; 50; i++)
    {
#pragma HLS PIPELINE II=1
        int var;
        inter[mux_sel].read(var);
        mux_output.write(var);
        mux_sel = (mux_sel == 0) ? (1) : (0);
    }
}

//--------------------------------------------
void demux(stream&lt;int&gt; &amp;in, stream&lt;int&gt; (&amp;inter)[2])
{
    int demux_sel = 0;
    for (int i = 0; i &lt; 50; i++)
    {
#pragma HLS PIPELINE II=1

        int var;
        in.read(var);
        inter[demux_sel].write(var);
        demux_sel = (demux_sel == 0) ? 1 : 0;
    }
}

void example(stream&lt;int&gt; &amp;in, stream&lt;int&gt; &amp;out)
{
#pragma HLS DATAFLOW

    stream&lt;int&gt; inter[2];
    stream&lt;int&gt; mux_in[2];

#pragma HLS STREAM variable = inter depth = 16
#pragma HLS STREAM variable = mux_in depth = 16

    demux(in, inter);
    proc&lt;0&gt;(inter[0], mux_in[0]);
    proc&lt;1&gt;(inter[1], mux_in[1]);
    mux(mux_in, out);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[👨👩💏五周年啦~🥂🍻]]></title>
        <id>https://Busy-Bob.github.io/post/wu-zhou-nian-la/</id>
        <link href="https://Busy-Bob.github.io/post/wu-zhou-nian-la/">
        </link>
        <updated>2021-01-02T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>2021-1-3： 水吉和臭臭五周年啦！</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609601219382.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>2021-1-3： 水吉和臭臭五周年啦！</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609601219382.jpg" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="2020年的一月那么近又那么远">2020年的一月，那么近又那么远</h1>
<p>2020年跨年这一天，乡村教师吉返回北京，和被无数考试摧残的臭第一次跨年+参加学校的跨年晚会~</p>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609590165354.jpg" alt="" loading="lazy"></figure>
<p><strong>新新廿廿</strong>的2020来啦</p>
<figure data-type="image" tabindex="2"><img src="https://Busy-Bob.github.io/post-images/1609590219882.jpg" alt="" loading="lazy"></figure>
<p>那时的我们还不知道2020会是一团糟🙊🙉🙈</p>
<br>
<p>回新津(恰好错过了途径武汉的火车)，一起去看望了水吉妈妈家的小泰迪~🐶🐶🐶<br>
<img src="https://Busy-Bob.github.io/post-images/1609592085383.jpg" alt="" loading="lazy"></p>
<h1 id="二月三月家里蹲">二月三月家里蹲</h1>
<p>一月末，疫情开始严重起来了。我们就只能骑着小电驴在两个家间穿梭，一三五在臭臭家，二四六在水吉家。就这样开开心心地度过了两个月~(监管最严格的时候甚至只能在超市碰头....)</p>
<p>情人节的礼物是山地玫瑰！<br>
<img src="https://Busy-Bob.github.io/post-images/1609591290870.jpg" alt="" loading="lazy"></p>
<p>还有小相机~ 这样坏记性的水吉就能够记录下更多在一起的美好回忆啦~<br>
<img src="https://Busy-Bob.github.io/post-images/1609592821850.jpg" alt="" loading="lazy"></p>
<p>当然还有：</p>
<ul>
<li><strong>在家里一起吃火锅</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593178211.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起穿睡衣一起刷剧一起比心</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593229660.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起泡jio</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593307478.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起尬舞，第一次也是唯一的一次两个人同时MEGASTAR</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609594381621.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起玩耍</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593946953.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起做饭</strong><br>
都被吃掉了，没有图了😂<br>
<br></li>
</ul>
<h1 id="四月五月深圳happy">四月五月深圳happy</h1>
<p>四月五月，水吉的哥哥让水吉去深圳帮忙，我也一并去蹭吃蹭喝:)🍎🍖🍗🍤🍨🍡🍜</p>
<ul>
<li><strong>吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595003396.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595010299.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>做饭，然后吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595046890.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>再做饭，然后吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595058832.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>最后在办公室插满了水吉喜欢的花花~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595105586.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="六月七月是分开的两个月">六月七月是分开的两个月</h1>
<p>疫情控制住了，乡村女教师吉吉水结束了网上上课，又回到了山西，成为了落水河最强的地理老师！</p>
<ul>
<li><strong>唯一的约会地点是召唤师峡谷</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595665922.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>水吉给家里买了一堆肉肉~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595729442.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="八月-老司机嘟嘟嘟">八月 老司机嘟嘟嘟</h1>
<p>水吉回来啦！我们也开始学车车！科一我们都考了一样的分数~</p>
<ul>
<li><strong>嘟嘟嘟，开车啦</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595988555.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>也去了广安的猫猫咖啡厅，不过还有人抽烟....</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596042550.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="九月-返校吃吃吃">九月 返校吃吃吃</h1>
<p>八月末终于可以返校了，水吉爸爸去西藏玩啦，可怜吉只好住在我家。白天学车做饭，晚上和妈妈一起刷剧，最后惊险通过科二， 而我在学校吃吃吃吃吃吃吃🤤🤤🤤</p>
<ul>
<li>
<p><strong>半年多没有浇水的肉肉们</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596722960.jpg" alt="" loading="lazy"><br>
水吉送的肉肉们竟然基本还是好好的，除了实验室的那个小个子顶不住了~<br>
<img src="https://Busy-Bob.github.io/post-images/1609596772512.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>和室友返校第一餐</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596564140.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>返校后和大家吃吃吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596800689.jpg" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609596808591.jpg" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609596818858.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>水吉回来啦，去水吉最喜欢的重八~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596866823.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
</ul>
<h1 id="十月-出游-生日和桌游">十月 出游、生日和桌游</h1>
<p>每年十月，都是天高气爽的好日子，非常适合出去玩。</p>
<ul>
<li>
<p><strong>再爬蟒山<s>大爷</s>小弟</strong><br>
今天的十一又去了蟒山，蟒山大爷似乎今年格外的矮小，一会就登顶啦！<br>
<img src="https://Busy-Bob.github.io/post-images/1609597594730.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>去野鸭湖！</strong><br>
担任小学期助教的意外之喜，秋天的野鸭湖真的好漂亮~<br>
<img src="https://Busy-Bob.github.io/post-images/1609597706914.jpg" alt="" loading="lazy"><br>
<br><br>
<img src="https://Busy-Bob.github.io/post-images/1609597713248.jpg" alt="" loading="lazy"><br>
<br><br>
<img src="https://Busy-Bob.github.io/post-images/1609597735946.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>臭臭的生日</strong><br>
这一天，水吉因为有篮球比赛早早离开啦~和大为、sff在宿舍快乐嚯奶茶，开心卡卡颂！<br>
<img src="https://Busy-Bob.github.io/post-images/1609597802417.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>提前送给水吉的生日礼物</strong><br>
今年送给水吉的礼物是一个能够放进书包的itx主机~老夫老妻了，早送早享受💻从此水吉的0-12快乐提莫再也不能找电脑卡的理由了hhhhhhhhh<br>
<img src="https://Busy-Bob.github.io/post-images/1609597946418.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>桌游、桌游！</strong><br>
今年是水吉爱玩的一年，从塞尔达到卡卡颂、卡坦岛，水吉玩个不停！<br>
<img src="https://Busy-Bob.github.io/post-images/1609598264941.jpg" alt="" loading="lazy"><br>
（被迫加入游戏的我）<br>
<br></p>
</li>
</ul>
<h1 id="十一-十二月-吃吃吃和水吉的生日">十一、十二月 吃吃吃和水吉的生日</h1>
<p>今年的冬天格外的冷，所以涮肉要吃起来啊！</p>
<ul>
<li>
<p><strong>听说，初雪和涮肉更配哦</strong><br>
初雪，我们去了四道口最好吃的涮肉，排队到了下午两点.....<br>
<img src="https://Busy-Bob.github.io/post-images/1609598677322.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>繁忙的十二月，我们终于在五道口找了一家咖啡厅</strong><br>
今年因为校园封闭，不能再到校园里面来学习了，经过几番辗转，终于在五道口找到了新的落脚之地，又可以一起学习了。<br>
<img src="https://Busy-Bob.github.io/post-images/1609598757515.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>圣诞——水吉的生日</strong><br>
和水吉以及水吉的室友们一起吃饭唱K，没错我就是K歌之王<sub>(的老公)</sub>。<br>
<img src="https://Busy-Bob.github.io/post-images/1609600194043.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>再次封校前的最后一次见面</strong><br>
学校又要封闭了，赶在最后一天和水吉见了一面，还吃了小宇哥推荐的好吃串串！（当天因为寒冷变成胆小菇的我↓）<br>
<img src="https://Busy-Bob.github.io/post-images/1609600950737.jpg" alt="" loading="lazy"></p>
</li>
</ul>
<h1 id="2021">2021💑💏</h1>
<p>新的一年，2021🐛🐛🐛啊！</p>
<p>好像没啥好说的了，那 <strong>最后祝大家身体健康!!科研有成!!</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FPGA用来加速运算的调研]]></title>
        <id>https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/</id>
        <link href="https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/">
        </link>
        <updated>2021-01-02T05:53:42.000Z</updated>
        <summary type="html"><![CDATA[<p>FPGA用来加速运算的调研.😁</p>
]]></summary>
        <content type="html"><![CDATA[<p>FPGA用来加速运算的调研.😁</p>
<!-- more -->
<h2 id=""><a href="https://www.zhihu.com/question/280468724/answer/517329473"><strong>FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎</strong></a></h2>
<ol>
<li>并行计算，比如每个步骤没有关连性的循环操作；</li>
<li>算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；</li>
<li>乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；</li>
<li>一些特定的矩阵运算。</li>
</ol>
<h2 id="-2"><a href="https://www.zhihu.com/question/24174597/answer/138717507"><strong>如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎</strong></a></h2>
<ul>
<li>
<p>FPGA 为什么快？「都是同行衬托得好」。<strong>CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存</strong>，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。</p>
</li>
<li>
<p>FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，<strong>不需要指令</strong>。</p>
</li>
<li>
<p><strong>计算密集型任务</strong>(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)</p>
<ul>
<li>Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当</li>
<li>浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。</li>
<li>在数据中心，FPGA 相比 GPU 的核心优势在于<strong>延迟</strong>。</li>
<li>FPGA 同时拥有<strong>流水线并行和数据并行</strong>，而 GPU 几乎只有数据并行（流水线深度受限）。</li>
<li>数据中心的计算任务是<strong>灵活多变</strong>的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资</li>
</ul>
</li>
<li>
<p><strong>通信密集型任务</strong></p>
<ul>
<li>从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。</li>
<li>网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。</li>
</ul>
</li>
<li>
<p>只要规模足够大，对 FPGA 价格过高的担心将是不必要的。</p>
</li>
<li>
<p>对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。</p>
</li>
<li>
<p>把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。</p>
</li>
<li>
<p>每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。<strong>如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态</strong>。这时就不如用冯·诺依曼结构的处理器。</p>
</li>
<li>
<p>FPGA 和 CPU 协同工作，<strong>局部性和重复性强的归 FPGA，复杂的归 CPU</strong>。</p>
</li>
</ul>
<h2 id="-3"><a href="https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf"><strong>将浮点转为定点大幅降低功耗和成本 - Xilinx</strong></a></h2>
<ul>
<li>用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。</li>
<li>对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。</li>
<li><strong>浮点转换为定点的优势</strong>:
<ul>
<li>减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）</li>
<li>功耗更低</li>
<li>材料成本降低</li>
<li>降低时延</li>
<li>相近的性能和精度</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Zynq Book 学习： 引言]]></title>
        <id>https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/</id>
        <link href="https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/">
        </link>
        <updated>2020-12-31T07:25:06.000Z</updated>
        <summary type="html"><![CDATA[<p>学习The Zynq Book第一章时的一些笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习The Zynq Book第一章时的一些笔记</p>
<!-- more -->
<ul>
<li>
<p>Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 <strong>处理器</strong>和一个传统的现场可编程门阵列（Field Programmable Gate Array，<strong>FPGA</strong>）逻辑部件。</p>
</li>
<li>
<p>这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了<strong>高带宽、低延迟</strong>的连接。</p>
</li>
<li>
<p>这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而<strong>不会有</strong>在两个分立的芯片之间的那种<strong>接口开销</strong>。同时又能获得系统被简化为单一芯片所带来的好处，包括<strong>物理尺寸</strong>和整体<strong>成本的降低</strong>。</p>
</li>
<li>
<p><strong>什么是片上系统/SoC (System on Chip)</strong>:</p>
<ul>
<li>单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。</li>
<li>常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）</li>
<li>和板上系统(在pcb板中组合多个元件)对比。</li>
<li><strong>缺点</strong>：
<ul>
<li>开发时间和成本</li>
<li>难以重用，不够灵活（与FPGA不同，直接设计芯片设计）</li>
</ul>
</li>
<li><strong>例子</strong>：手机，PC，平板等的CPU</li>
</ul>
</li>
<li>
<p>Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）</p>
<ul>
<li>处理系统（PS）：支持软件程序和/ 或操作系统</li>
<li>可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统</li>
<li>工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。<br>
<img src="https://Busy-Bob.github.io/post-images/1609400781987.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>软硬件系统关系<br>
<img src="https://Busy-Bob.github.io/post-images/1609401050095.png" alt="" loading="lazy"></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZYNQ中的通信接口(包括PS与PL)]]></title>
        <id>https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/</id>
        <link href="https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/">
        </link>
        <updated>2020-12-31T02:45:05.000Z</updated>
        <content type="html"><![CDATA[<p>总体架构图为：<br>
<img src="https://Busy-Bob.github.io/post-images/1609385485651.png" alt="" loading="lazy"></p>
<ul>
<li><strong>PS (Processing System)中对外通信管脚:</strong>：
<ul>
<li><strong>MIO</strong> (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。</li>
<li><strong>EMIO</strong> (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在<strong>约束文件中分配管脚</strong>，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即<strong>PS可以利用EMIO和PL进行通信</strong>)</em></p>
</blockquote>
<ul>
<li>
<p>**PL (Programmable Logic) 和 PS的通信接口 **<br>
<img src="https://Busy-Bob.github.io/post-images/1609403066047.png" alt="" loading="lazy"></p>
<ul>
<li><strong>通用AXI（General Purpose AXI）</strong>： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的<strong>中低速通信</strong>。接口是透传的不带缓冲。</li>
<li><strong>加速器一致性端口（Accelerator Coherency Port）</strong>： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）</li>
<li><strong>高性能端口（High Performance Ports）</strong>： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。<strong>(PL直接从DDR中获取数据)</strong></li>
<li><strong>EMIO</strong>： 原本是用来连接I2C等协议的外设，也可以给PS使用。</li>
</ul>
</li>
</ul>
<h1 id="pynq中python类对应">PYNQ中python类对应：</h1>
<ul>
<li><strong>GPIO</strong>： 对应MIO， EMIO。（类似于单片机中的GPIO）</li>
<li><strong>MMIO</strong>： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）</li>
<li><strong>Xlnk</strong>： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）</li>
<li><strong>DMA</strong>： 对应HP AXI，访问DMA，即高性能AXI端口</li>
</ul>
<h1 id="axi-协议">AXI 协议</h1>
<ul>
<li>AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。</li>
<li>AXI4_LITE： 只支持每次连接传输一个数据（非批量）。</li>
<li>AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAND Flash, NOR Flash 的区别和应用]]></title>
        <id>https://Busy-Bob.github.io/post/nand-flash-nor-flash/</id>
        <link href="https://Busy-Bob.github.io/post/nand-flash-nor-flash/">
        </link>
        <updated>2020-12-29T14:06:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flash-原理">Flash 原理：</h2>
<p><img src="https://Busy-Bob.github.io/post-images/1609254997519.png" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609253806308.png" alt="" loading="lazy"><br>
参考<a href="https://www.youtube.com/watch?v=aO_kBa9DzPQ">youtube</a>。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。</p>
<h2 id="nand-flash-和-nor-flash-区别">NAND Flash 和 NOR Flash 区别</h2>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609253097307.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>NAND 不能够取指令（类似于硬盘）</strong></li>
<li><strong>NOR 可以取指令（类似于内存）</strong></li>
</ul>
<p>由于CPU运行时候需要三步：<strong>取指、译码、执行</strong> 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。</p>
<h2 id="应用场景">应用场景</h2>
<ul>
<li><strong>NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）</strong></li>
<li><strong>NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）</strong></li>
</ul>
<h2 id="ssd和u盘区别">SSD和U盘区别</h2>
<blockquote>
<p>储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的<br>
主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么<br>
存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发<br>
接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快</p>
<p>作者：李诗华<br>
链接：https://www.zhihu.com/question/265335741/answer/292414149<br>
来源：知乎</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 错误处理中多种类型Error传播的处理方式]]></title>
        <id>https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/</id>
        <link href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/">
        </link>
        <updated>2020-12-01T07:27:56.000Z</updated>
        <summary type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
<!-- more -->
<p>主要参考：<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a> 和 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html">Result 与可恢复的错误</a>.</p>
<h1 id="tl-dr">TL; DR</h1>
<ul>
<li><code>Box&lt;dyn std::error::Error&gt;</code> 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）</li>
<li>自定义一个<code>enum</code>通常用在需要对错误进行恢复的时候。（容易检测类型）</li>
</ul>
<h1 id="boxdyn-error-方式来聚合error"><code>Box&lt;dyn Error&gt;</code> 方式来聚合Error</h1>
<pre><code class="language-rust">fn do_something() -&gt; std::result::Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{
    let path = &quot;./dat&quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&lt;u32&gt;()?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}
</code></pre>
<p>三者分别返回不同的错误类型，但是都可以用<code>Box&lt;dyn std::error::Error&gt;</code>来装。</p>
<ul>
<li><strong>优点</strong>： 方便书写。</li>
<li><strong>缺点</strong>： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“<strong>反射</strong>”( <code>Any</code> trait)才能够确定。而不能直接match。</li>
</ul>
<h1 id="利用-enum-来聚合error">利用 <code>enum</code> 来聚合Error</h1>
<blockquote>
<p>内容来自<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a></p>
</blockquote>
<p>自定义一个<code>error</code>需要实现如下几步：</p>
<ul>
<li>手动实现impl <code>std::fmt::Display</code>的trait,并<strong>实现</strong> <code>fmt(...)</code>方法。</li>
<li>手动实现impl <code>std::fmt::Debug</code>的<code>trait</code>，一般直接添加注解即可：<code>#[derive(Debug)]</code></li>
<li>手动实现impl <code>std::error::Error</code>的<code>trait</code>,并根据自身<code>error</code>级别是否<strong>覆盖</strong><code>std::error::Error</code>中的<code>source()</code>方法。</li>
</ul>
<p>下面的内容中：</p>
<ul>
<li><code>CustomError</code>为我们实现的<strong>自定义Error</strong></li>
<li><code>CustomError</code>有三个<strong>子类型Error</strong></li>
<li><code>CustomError</code>分别实现了三个<strong>子类型Error</strong> <code>From</code>的trait,将其类型包装为<strong>自定义Error</strong>的子类型</li>
</ul>
<p>好了，有了自定义的<code>CustomError</code>，那怎么使用呢? 我们看代码：</p>
<pre><code class="language-rust">use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&gt; std::result::Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
</code></pre>
]]></content>
    </entry>
</feed>