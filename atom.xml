<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Busy-Bob.github.io</id>
    <title>勺海的博客</title>
    <updated>2021-01-05T14:31:25.989Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Busy-Bob.github.io"/>
    <link rel="self" href="https://Busy-Bob.github.io/atom.xml"/>
    <subtitle>尽应尽之事，做让自己开心的事。</subtitle>
    <logo>https://Busy-Bob.github.io/images/avatar.png</logo>
    <icon>https://Busy-Bob.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 勺海的博客</rights>
    <entry>
        <title type="html"><![CDATA[Vitis HLS Coding Styles]]></title>
        <id>https://Busy-Bob.github.io/post/vitis-hls-coding-styles/</id>
        <link href="https://Busy-Bob.github.io/post/vitis-hls-coding-styles/">
        </link>
        <updated>2021-01-04T08:57:57.000Z</updated>
        <summary type="html"><![CDATA[<p>参考Xilinx文档，<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html">Vitis HLS Coding Styles</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>参考Xilinx文档，<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html">Vitis HLS Coding Styles</a></p>
<!-- more -->
<h1 id="不支持的cc部分">不支持的C/C++部分</h1>
<h2 id="系统调用">系统调用</h2>
<ul>
<li><code>printf()</code>， <code>fprintf(stdout,)</code>等不会影响算法执行的系统调用——忽略掉。</li>
<li><code>getc()</code>, <code>time()</code>, <code>sleep()</code> 等系统调用——不被接受。</li>
<li>可以使用<code>__SYNTHESIS__</code>宏来区分<strong>综合</strong>与<strong>调试</strong>过程</li>
</ul>
<pre><code class="language-c">void hier_func4(din_t A, din_t B, dout_t *C, dout_t *D)
{
    dint_t apb, amb;

    sumsub_func(&amp;A, &amp;B, &amp;apb, &amp;amb);
#ifndef __SYNTHESIS__
    FILE *fp1; // The following code is ignored for synthesis
    char filename[255];
    sprintf(filename, Out_apb_ % 03d.dat, apb);
    fp1 = fopen(filename, w);
    fprintf(fp1, % d \n, apb);
    fclose(fp1);
#endif
    shift_func(&amp;apb, &amp;amb, C, D);
}

</code></pre>
<h2 id="动态内存">动态内存</h2>
<ul>
<li><code>malloc()</code>， <code>new</code> 等动态分配内存的不行, 不能在堆上分配内存，必须在栈上。（因为该HLS技术是静态分析）</li>
<li>一种改动方法是直接对栈上变量取指针：</li>
</ul>
<pre><code class="language-C">#include &quot;malloc_removed.h&quot;
#include &lt;stdlib.h&gt;
//#define NO_SYNTH

dout_t malloc_removed(din_t din[N], dsel_t width) {  

#ifdef NO_SYNTH
 long long *out_accum = malloc (sizeof(long long));
 int* array_local = malloc (64 * sizeof(int));
#else
 long long _out_accum;
 long long *out_accum = &amp;_out_accum;
 int _array_local[64];
 int* array_local = &amp;_array_local[0];
#endif
// 中间计算省略
 return *out_accum;
}
</code></pre>
<h2 id="指针的一些限制">指针的一些限制</h2>
<h3 id="通用指针类型转换">通用指针类型转换</h3>
<p>HLS 只支持C/C++原生类型的转换</p>
<h3 id="指针数组">指针数组</h3>
<p>如果每个指针指向一个标量或一个标量数组，则Vitis HLS支持指针数组的综合。但指针数组不能指向额外的指针（应该类似二维数组的行、列指针）</p>
<h3 id="函数指针">函数指针</h3>
<p>不支持</p>
<h2 id="递归函数">递归函数</h2>
<ul>
<li>不支持。不管最后递归次数是不是有限的。</li>
<li>可以使用C++模板来构造<strong>可以用来综合的尾递归</strong>，因为C++中支持非类型模板参数（Nontype Template Parameters），类似Rust中的const泛型，这儿的模板参数为<code>data_t</code>类型的一个值 N。<a href="https://github.com/Xilinx/HLS-Tiny-Tutorials/tree/master/algorithm_template_fir_filter">例子如下</a>：</li>
</ul>
<pre><code class="language-C++">// Tail recursive call
template&lt;data_t N&gt; 
	struct fibon_s {
    template&lt;typename T&gt;
    static T fibon_f(T a, T b) {
		return fibon_s&lt;N-1&gt;::fibon_f(b, (a+b));
  }
};

// Termination condition
template&lt;&gt; struct fibon_s&lt;1&gt; {
  template&lt;typename T&gt;
  static T fibon_f(T a, T b) {
    return b;
  }
};

void cpp_template(data_t a, data_t b, data_t &amp;dout){
  dout = fibon_s&lt;FIB_N&gt;::fibon_f(a,b);
}
</code></pre>
<h2 id="stl">STL</h2>
<p>有动态内存和递归，不能使用。</p>
<h1 id="函数">函数</h1>
<p>顶层函数不能是静态的。</p>
<h2 id="内联函数">内联函数</h2>
<ul>
<li>综合时候花费时间、内存较多，但效果更好。</li>
<li>没有独立的RTL文件和报告了。</li>
</ul>
<h2 id="代码风格的影响">代码风格的影响</h2>
<ul>
<li>影响函数参数和接口</li>
<li>直接用函数接口的输入量来驱动变量时候，程序就不会使用某些优化手段。（如输入量是循环索引的上限）</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;

ap_int&lt;24&gt; foo(int x, int y) {  
 int tmp;

 tmp = (x * y);
 return tmp
} 
</code></pre>
<p>上述代码这会导致一个32-bit乘法器，输出再被截取。<br>
下面这个代码直接产生一个24-bit乘法器。</p>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
typedef ap_int&lt;12&gt; din_t;
typedef ap_int&lt;24&gt; dout_t;

dout_t func_sized(din_t x, din_t y) {  
 int tmp;

 tmp = (x * y);
 return tmp
}
</code></pre>
<h2 id="cc内置函数">C/C++内置函数</h2>
<ul>
<li>只支持以下两个</li>
<li><code>__builtin_clz(unsigned int x)</code>: Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.</li>
<li><code>__builtin_ctz(unsigned int x)</code>: Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.</li>
</ul>
<h1 id="循环">循环</h1>
<ul>
<li>支持得很好。可以切流水线，展开、部分展开、合并和扁平化</li>
<li><strong>不要使用全局变量作为循环变量</strong>，否则会阻碍代码优化</li>
</ul>
<h2 id="循环变量范围">循环变量范围</h2>
<ul>
<li>循环变量的上限如果是变量，就难以在综合时候优化。</li>
<li>循环变量的上限如果是变量，循环的latency无法确定。</li>
<li>循环变量的上限如果是变量，设计的性能未知。</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
#define N 32

typedef ap_int&lt;8&gt; din_t;
typedef ap_int&lt;13&gt; dout_t;
typedef ap_uint&lt;5&gt; dsel_t;

dout_t code028(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0;x&lt;width; x++) {
 out_accum += A[x];
 }

 return out_accum;
}
</code></pre>
<p>为了克服无法分析性能的缺点，一般是加上<br>
<code>#pragma HLS loop_tripcount min=&lt;int&gt; max=&lt;int&gt; avg=&lt;int&gt;</code><br>
或者是使用断言<code>assert</code></p>
<pre><code class="language-C++">void foo (num_samples, ...) {
  int i;
  ...
  loop_1: for(i=0;i&lt; num_samples;i++) {
   #pragma HLS loop_tripcount min=12 max=16
   ...
    result = a + b;
  }
}
</code></pre>
<p><strong>注意</strong>：该编译选项只用于分析，不会用于综合。</p>
<ul>
<li><strong>对于具有可变边界的循环的解决方案是：在循环中有条件地执行，并且令循环迭代的次数为固定值。</strong></li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
#define N 32

typedef ap_int&lt;8&gt; din_t;
typedef ap_int&lt;13&gt; dout_t;
typedef ap_uint&lt;5&gt; dsel_t;

dout_t loop_max_bounds(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0; x&lt;N; x++) {
 if (x&lt;width) {
  out_accum += A[x];
 }
 }

 return out_accum;
}
</code></pre>
<h2 id="将循环流水线化">将循环流水线化</h2>
<p>通常通过流水线最内层的循环来找到面积和性能之间的最佳平衡。</p>
<pre><code class="language-C++">#include &quot;loop_pipeline.h&quot;

dout_t loop_pipeline(din_t A[N]) {  

 int i,j;
 static dout_t acc;

 LOOP_I:for(i=0; i &lt; 20; i++){
 LOOP_J: for(j=0; j &lt; 20; j++){
 acc += A[i] * j;
 }
 }

 return acc;
}
</code></pre>
<ul>
<li>
<p>Pipeline <code>LOOP_J</code></p>
<ul>
<li>只需调度一个乘法器操作和一个数组访问</li>
<li>Latency is approximately 400 cycles (20x20) and requires less than 100 LUTs and registers (the I/O control and FSM are always present).</li>
</ul>
</li>
<li>
<p>Pipeline <code>LOOP_I</code></p>
<ul>
<li>内部循环展开20次。</li>
<li>需调度20个乘法器操作和20个数组访问</li>
<li>Latency is approximately 20 cycles but requires a few hundred LUTs and registers. About 20 times the logic as first option, minus any logic optimizations that can be made.</li>
</ul>
</li>
<li>
<p>Pipeline <code>function loop_pipeline</code></p>
<ul>
<li>需调度400个乘法器操作和400个数组访问</li>
<li>Latency is approximately 10 (20 dual-port accesses) but requires thousands of LUTs and registers (about 400 times the logic of the first option minus any optimizations that can be made)</li>
</ul>
</li>
</ul>
<h3 id="不完美的循环嵌套">不完美的循环嵌套</h3>
<p>不完美的循环嵌套，或者无法将循环嵌套展开，会导致进入和退出循环的额外时钟周期。</p>
<h2 id="循环并行">循环并行</h2>
<ul>
<li>HLS会使得逻辑和函数并行，但是并不会调度循环来并行。</li>
<li>例子中SUM_X和SUM_Y不会并行调度，而是顺序的。（因为两个循环变量有不同的上限）</li>
</ul>
<pre><code class="language-C++">#include &quot;loop_sequential.h&quot;

void loop_sequential(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {  

 dout_t X_accum=0;
 dout_t Y_accum=0;
 int i,j;

 SUM_X:for (i=0;i&lt;xlimit; i++) {
 X_accum += A[i];
 X[i] = X_accum;
}

 SUM_Y:for (i=0;i&lt;ylimit; i++) {
 Y_accum += B[i];
 Y[i] = Y_accum;
 }
} 
</code></pre>
<p>把两个循环装在function里面就可以并行了</p>
<pre><code class="language-C++">#include &quot;loop_functions.h&quot;

void sub_func(din_t I[N], dout_t O[N], dsel_t limit) {
 int i;
 dout_t accum=0;
  
 SUM:for (i=0;i&lt;limit; i++) {
 accum += I[i];
 O[i] = accum;
 }

}

void loop_functions(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {

 sub_func(A,X,xlimit);
 sub_func(B,Y,ylimit);
}
</code></pre>
<ul>
<li>这是在函数中捕获循环以利用并行性的原则</li>
</ul>
<h2 id="循环依赖">循环依赖</h2>
<ul>
<li>一次循环开始可能会依赖上一次循环的结束。</li>
</ul>
<pre><code class="language-C++"> Minim_Loop: while (a != b) { 
 if (a &gt; b) 
 a -= b; 
 else 
 b -= a;
 }
</code></pre>
<ul>
<li>解决方案是<strong>尽量确保初始操作尽早执行</strong>(应该就是对循环变量做修改等)</li>
</ul>
<h2 id="在c类中不会展开循环">在c++类中不会展开循环</h2>
<ul>
<li>应小心确保循环归纳变量不是类的数据成员，因为这会防止循环被展开。</li>
</ul>
<pre><code class="language-C++">template &lt;typename T0, typename T1, typename T2, typename T3, int N&gt;
class foo_class
{
private:
    pe_mac&lt;T0, T1, T2&gt; mac;

public:
    T0 areg;
    T0 breg;
    T2 mreg;
    T1 preg;
    T0 shift[N];
    int k; // Class Member
    T0 shift_output;
    void exec(T1 *pcout, T0 *dataOut, T1 pcin, T3 coeff, T0 data, int col)
    {
    Function_label0:;
#pragma HLS inline off
    SRL:
        for (k = N - 1; k &gt;= 0; --k)
        {
#pragma HLS unroll // Loop will fail UNROLL
            if (k &gt; 0)
                shift[k] = shift[k - 1];
            else
                shift[k] = data;
        }

        *dataOut = shift_output;
        shift_output = shift[N - 1];
    }

    *pcout = mac.exec1(shift[4 * col], coeff, pcin);
};
</code></pre>
<h1 id="数组">数组</h1>
<ul>
<li>仿真时候内存不够怎么办？一个妥协的方法是动态内存。</li>
<li>定点数占用内存 &gt;  arbitrary precision type &gt; C自带类型</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
  
  int i, acc; 
#ifdef __SYNTHESIS__
  // Use an arbitrary precision type &amp; array for synthesis
  ap_int&lt;32&gt;  la0[10000000], la1[10000000]; 
#else 
  // Use an arbitrary precision type &amp; dynamic memory for simulation
 ap_int&lt;int32&gt; *la0 = malloc(10000000  * sizeof(ap_int&lt;32&gt;));
 ap_int&lt;int32&gt; *la1 = malloc(10000000  * sizeof(ap_int&lt;32&gt;));
#endif
  for (i=0 ; i &lt; 10000000; i++) { 
      acc = acc + la0[i] + la1[i]; 
  } 
</code></pre>
<ul>
<li><strong>数组长度小于1024</strong>：实例化为FIFO</li>
<li><strong>数组长度大于1024</strong>： 保存在block RAM或LUTRAM或UltraRAM</li>
</ul>
<h2 id="数组访问和性能">数组访问和性能</h2>
<ul>
<li>对数组访问次数越多，越会限制性能。（尤其是在一个循环中的情况）</li>
<li>所以有如下的更改策略：</li>
</ul>
<pre><code class="language-C++">#include &quot;array_mem_bottleneck.h&quot;
 
dout_t array_mem_bottleneck(din_t mem[N]) {  

 dout_t sum=0;
 int i;

 SUM_LOOP:for(i=2;i&lt;N;++i)
   sum += mem[i] + mem[i-1] + mem[i-2];
    
 return sum;
}
</code></pre>
<p>变成</p>
<pre><code class="language-C++">#include &quot;array_mem_perform.h&quot;
 
dout_t array_mem_perform(din_t mem[N]) {  

 din_t tmp0, tmp1, tmp2;
 dout_t sum=0;
 int i;

 tmp0 = mem[0];
 tmp1 = mem[1];
 SUM_LOOP:for (i = 2; i &lt; N; i++) { 
 tmp2 = mem[i];
 sum += tmp2 + tmp1 + tmp0;
 tmp0 = tmp1;
 tmp1 = tmp2;
 } 
    
 return sum;
}
</code></pre>
<h3 id="fifo访问">FIFO访问</h3>
<p>因为是先入先出，所以必须要从0开始顺序访问。</p>
<h2 id="接口上的数组top函数参数">接口上的数组（top函数参数）</h2>
<p>HLS会默认会将接口上数组认为是内存。HLS有两种假设的实现方式</p>
<ul>
<li><strong>off-chip的内存</strong>：</li>
<li><strong>标准的block RAM，延迟只有1clock</strong>： 数据会在地址给定后一个周期准备好。</li>
</ul>
<p>所以需要：</p>
<ul>
<li>指定是RAM还是FIFO的接口</li>
<li>指定RAM是单端口还是双端口的RAM，预编译选项中的<code>storage_type</code>，语法是<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html#jit1504034365862__ad411155">#pragma HLS interface</a></li>
<li>指定RAM延时， <code>latency</code></li>
<li>ARRAY_PARTITION, ARRAY_RESHAPE 两个优化输入的命令。语法是<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html?#ariaid-title4">#pragma HLS array_partition</a>， 相当于<strong>用寄存器代替RAM</strong>，或者用更小的RAM来代替大的RAM。</li>
</ul>
<p><strong>默认情况下</strong>：</p>
<ul>
<li>默认是单端口的RAM。</li>
<li>如果initiation interval or latency可以被减少，则使用双端口的RAM</li>
</ul>
<h2 id="数组初始化">数组初始化</h2>
<ul>
<li>建议使用<code>static</code>关键字来建立数组，保证HLS将其变成内存。</li>
<li>确保初始化大内存不会造成操作开销。不用static会在初始化时候，写入这些值，有一定时间开销。</li>
</ul>
<h3 id="实例化一个rom">实例化一个ROM</h3>
<ul>
<li>建议使用<code>const</code>来做一个只读的ROM，如果不加，也没有问题。综合过程自己会进行优化。</li>
</ul>
<h1 id="数据类型">数据类型</h1>
<h2 id="cc-类型">C/C++ 类型</h2>
<p>略</p>
<h2 id="arbitrary-precision-ap-data-types-任意精度数据类型">Arbitrary Precision (AP) Data Types 任意精度数据类型</h2>
<ul>
<li><strong>C语言可以这样写</strong></li>
</ul>
<pre><code class="language-C++">#include &quot;types.h&quot;

typedef int6 dinA_t;
typedef int12 dinB_t;
typedef int22 dinC_t;
typedef int33 dinD_t;
typedef int18 dout1_t;
typedef uint13 dout2_t;
typedef int22 dout3_t;
typedef int6 dout4_t;
</code></pre>
<ul>
<li><strong>C++模版这样写</strong>，还有一个好处是可以定义超大的数</li>
</ul>
<pre><code class="language-C++">#include &quot;ap_int.h&quot;
void foo_top (…) {
  
 ap_int&lt;9&gt;  var1;           // 9-bit
 ap_uint&lt;10&gt;  var2;         // 10-bit unsigned
</code></pre>
<h3 id="定点数-arbitrary-precision-fixed-point-data-types">定点数 Arbitrary Precision Fixed-Point Data Types</h3>
<pre><code class="language-C++">#include &lt;ap_fixed.h&gt;
...
ap_fixed&lt;18,6,AP_RND &gt; my_type;
...
ap_fixed&lt;2, 0&gt; a = -0.5;    // a can be -0.5,
ap_ufixed&lt;1, 0&gt; x = 0.5;    // 1-bit representation. x can be 0 or 0.5
ap_ufixed&lt;1, -1&gt; y = 0.25;  // 1-bit representation. y can be 0 or 0.25
const ap_fixed&lt;1, -7&gt; z = 1.0/256;  // 1-bit representation for z = 2^-8
</code></pre>
<p>四个泛型参数分别为，见<a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/use_arbitrary_precision_data_type.html#guo1585572335601">Fixed-Point Identifier Summary</a>：</p>
<ul>
<li>总长度</li>
<li>整数位数（可以为负数，见例子）</li>
<li>量化模式</li>
<li>溢出饱和位数量</li>
</ul>
<h2 id="复合数据类型">复合数据类型</h2>
<h3 id="struct"><code>struct</code></h3>
<ul>
<li>默认成员是分解的。<strong>结构体的数组实现为多个数组</strong>，结构体的每个成员都有一个单独的数组。</li>
<li>利用pragma指令控制是否分解。</li>
</ul>
<h3 id="enum"><code>enum</code></h3>
<p>略</p>
<h3 id="unions"><code>unions</code></h3>
<ul>
<li>HLS综合并不保证使用相同的内存或者寄存器</li>
</ul>
<h3 id="类型限定符">类型限定符</h3>
<ul>
<li><code>volatile</code>：
<ul>
<li>综合不会进行优化</li>
<li>Arbitrary precision types do not support the volatile qualifier（计算时候）</li>
</ul>
</li>
<li><code>static</code>：
<ul>
<li>RTL等价是寄存器、触发器和内存。</li>
<li>config_rtl 需要配置，不然默认复位不会初始化。</li>
</ul>
</li>
<li><code>const</code>：
<ul>
<li>常量或者ROM</li>
</ul>
</li>
</ul>
<h2 id="全局变量">全局变量</h2>
<p>自由使用，但是只存在该ip核内部。</p>
<h2 id="指针">指针</h2>
<p>可以综合，但尽量避免使用。尤其是以下情况：</p>
<ul>
<li>同一个函数中，一个指针被读写多次</li>
<li>指针类型转换仅限C/C++标准类型</li>
</ul>
<h3 id="接口处使用指针top函数的参数中">接口处使用指针（top函数的参数中）</h3>
<ul>
<li>基本指针：
<ul>
<li>指针可以合成为一个简单的<strong>线接口</strong>或使用握手的接口协议。</li>
<li>要合成一个FIFO接口，指针必须是只读或只写的。</li>
</ul>
</li>
<li>指针运算：
<ul>
<li>不能实现，不能实现无序访问。</li>
<li>需要变成数组，用RAM实现。</li>
</ul>
</li>
<li>流数据
<ul>
<li>C++ 编译器可能会优化指针的访问，所以需要加volatile。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">#include &quot;pointer_stream_good.h&quot;

void pointer_stream_good ( volatile dout_t *d_o,  volatile din_t *d_i) {
 din_t acc = 0;

 acc += *d_i;
 acc += *(d_i+1);
 *d_o = acc;
 acc += *(d_i+2);
 acc += *(d_i+3);
 *(d_o+1) = acc;
} 
</code></pre>
<h2 id="vector类型">Vector类型</h2>
<h3 id="hls的vector类型是为了simd操作">HLS的Vector类型是为了SIMD操作</h3>
<ul>
<li>single-instruction multiple-data (SIMD)： 单指令，多数据。</li>
<li>Vitis HLS提供的一个模版类型<code>hls::vector&lt;T, N&gt;</code>: 一个有N个T类型的元素，T必须重载了数学运算。</li>
<li>最佳性能是在<strong>T的位宽</strong>和<strong>N的值</strong>均为2的幂时。</li>
<li>在<code>hls::vector</code>上的运算操作都会被并行化，所以矩阵运算一般使用这个。</li>
</ul>
<pre><code class="language-C++">#include &lt;hls_vector.h&gt;
hls::vector&lt;T,N&gt;  aVec;
</code></pre>
<h3 id="vector-内存布局">Vector 内存布局</h3>
<ul>
<li>Vctor储存是对齐到2的n次方的。所以性能最好的时候是大小和位宽都为2的幂的时候。</li>
<li>实现方式如下：</li>
</ul>
<pre><code class="language-C++">constexpr size_t gp2(size_t N)
{
    return (N &gt; 0 &amp;&amp; N % 2 == 0) ? 2 * gp2(N / 2) : 1;
}
 
template&lt;typename T, size_t N&gt; class alignas(gp2(sizeof(T) * N)) vector
{
    std::array&lt;T, N&gt; data;
};
</code></pre>
<h1 id="c类和模版">C++类和模版</h1>
<ul>
<li>类是完全支持的。</li>
<li>不建议在类中使用全局变量，会阻碍优化</li>
<li>模版是支持的。但不能作为顶层函数。</li>
</ul>
<h1 id="断言">断言</h1>
<ul>
<li>断言可以用在综合中，提供范围的信息。如循环上限等。（不像tripcount 只能用于分析）</li>
</ul>
<h1 id="高性能hls">高性能HLS</h1>
<ul>
<li>是最大程度地减少对顶层函数参数的访问。</li>
<li>在阵列中设置默认值会花费时钟周期和性能。</li>
<li>多次读取和重新读取数据会消耗时钟周期和性能。</li>
<li>以任意或随机访问方式访问数据要求将数据存储在本地数组中，浪费资源。</li>
</ul>
<h2 id="确保数据的连续流和数据重用">确保数据的连续流和数据重用</h2>
<ul>
<li>将数据从CPU或系统内存传输到FPGA，则通常会以<strong>流传输方式</strong>进行传输。从FPGA传输回系统的数据也应以这种方式执行。</li>
<li><code>hls::stream</code> , 顺序访问，表现为一个无限深度的FIFO。</li>
<li>在CPU体系结构中，通常避免有条件或分支操作。当程序需要分支时，它将丢失存储在CPU提取管线中的所有指令。<strong>在FPGA体系结构中，每个条件分支的硬件中已经存在一条单独的路径，并且不会与流水线任务内部的分支相关的性能下降。这只是选择要使用哪个分支的一种情况。</strong></li>
<li><a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html">HLS Pragmas</a>的使用。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vitis HLS 的Tiny Tutorial部分代码分析]]></title>
        <id>https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/</id>
        <link href="https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/">
        </link>
        <updated>2021-01-04T06:15:07.000Z</updated>
        <summary type="html"><![CDATA[<p>对例子中的语法等的一点记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>对例子中的语法等的一点记录</p>
<!-- more -->
<h1 id="背景介绍">背景介绍</h1>
<ul>
<li><strong>HLS</strong> (high-level synthesis)： 高级综合, 用 C/C++为FPGA开发 RTL IP.</li>
<li><strong>Vitis HLS</strong>:  在Vivado 2020版本中替代原先的Vivado HLS, 功能略有差异，在Vivado HLS中的例子直接在Vitis HLS上跑会报错。详细比较见<a href="https://cloud.tencent.com/developer/article/1745199">Vivado HLS和Vitis HLS什么区别？</a></li>
<li><strong>HLS中的pragma语法</strong>: <a href="https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html">HLS Pragmas</a></li>
</ul>
<h1 id="内容">内容</h1>
<ul>
<li><code>#pragma HLS dataflow</code>
<ul>
<li>默认情况下，Vitis HLS工具试图最小化延迟并提高并发性。但是，数据依赖性可能会限制这一点。DATAFLOW优化使<strong>函数或循环中的操作能够在上一个函数或循环完成其所有操作之前开始操作</strong>。（能够分析更细）。</li>
<li>也能够解决两个不依赖循环不并行情况（类似于封装进函数）。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">void diamond(data_t vecIn[N], data_t vecOut[N])
{
  data_t c1[N], c2[N], c3[N], c4[N];
#pragma HLS dataflow
  funcA(vecIn, c1, c2);
  funcB(c1, c3);
  funcC(c2, c4);
  funcD(c3, c4, vecOut);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609835551513.png" alt="" loading="lazy"></figure>
<ul>
<li><code>#pragma HLS pipeline rewind</code>
<ul>
<li>构造一个连续循环的流水线。两次循环之间没有暂停。</li>
<li>不能包含条件分支 (if-else)</li>
<li>只支持循环，不支持函数的流水线化。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">  for (int i = 0; i &lt; N; i++)
  {
#pragma HLS pipeline rewind
#pragma HLS unroll factor = 2
    data_t t = in[i] * 3;
    out1[i] = t;
    out2[i] = t;
  }
</code></pre>
<ul>
<li><code>#pragma HLS unroll factor = 2</code>
<ul>
<li>将循环展开多少次</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">for(int i = 0; i &lt; X; i++) {
  pragma HLS unroll factor=2
  a[i] = b[i] + c[i];
}
</code></pre>
<p>变成：</p>
<pre><code class="language-C++">for(int i = 0; i &lt; X; i += 2) {
  a[i] = b[i] + c[i];
  if (i+1 &gt;= X) break;
  a[i+1] = b[i+1] + c[i+1];
}
</code></pre>
<ul>
<li><code>#pragma HLS function_instantiate variable=&lt;variable&gt;</code>
<ul>
<li>FUNCTION_INSTANTIATE编译指示用于为函数的每个实例创建唯一的RTL实现，从而可以根据函数调用对每个实例进行本地优化。因为：调用函数时，<strong>函数的某些输入可以是恒定值</strong>，并使用它来简化周围的控制结构并<strong>生成更小的</strong>，<strong>更优化的功能块</strong>。</li>
<li><code>variable</code>是必需的参数，用于定义要用作常量的函数参数。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">char foo(char inval, char incr) {
#pragma HLS INLINE OFF
#pragma HLS FUNCTION_INSTANTIATE variable=incr
 return inval + incr;
}

void top(char inval1, char inval2, char inval3,
 char *outval1, char *outval2, char *outval3)
{
 *outval1 = foo(inval1,   0);
 *outval2 = foo(inval2,   1);
 *outval3 = foo(inval3, 100);
}
</code></pre>
<ul>
<li><strong>不完美的循环(imperfect loop)</strong>:
<ul>
<li>内层循环上限是一个变量。</li>
<li>循环体并非全部在最里层循环中。</li>
<li>所以<strong>没法展开</strong>，会造成额外的进出循环的时钟周期。</li>
</ul>
</li>
</ul>
<pre><code class="language-C++">    LOOP_I:for(i=0; i &lt; 20; i++){
        acc = 0;
        LOOP_J: for(j=0; j &lt; 20; j++){
            acc += A[j] * j;
        }
        if (i%2 == 0)
            B[i] = acc / 20;
        else
            B[i] = 0;
    }
</code></pre>
<ul>
<li>将不完美循环改写成完美循环的trick：<strong>使用条件语句</strong>。</li>
</ul>
<pre><code class="language-C++">    LOOP_I:for(i=0; i &lt; 20; i++){
        LOOP_J: for(j=0; j &lt; 20; j++){
            if(j==0) acc = 0;
            acc += A[j] * j;
            if(j==19) {
                if (i%2 == 0)
                    B[i] = acc / 20;
                else
                    B[i] = 0;
            }
        }
    }
</code></pre>
<ul>
<li>
<p>循环可以没有label，HLS会生成默认label。</p>
</li>
<li>
<p>循环上限为变量的优化方法： <strong>使用条件语句</strong>。</p>
</li>
</ul>
<pre><code class="language-C++">  LOOP_X:for (x=0;x&lt;N-1; x++) {
    if (x&lt;width) {
      out_accum += A[x];
    }
  }
</code></pre>
<ul>
<li>可以利用两个独立的模块来压缩流水的II （用模版实现较为方便，需要配合上多路选择器）</li>
</ul>
<pre><code class="language-C++">//                    +--proc--&gt;[ II=2 ]--+
//                   /                     \               
// in --&gt;[demux II=1]                       [mux II=1]---&gt; out
//                   \                     /
//                    +--proc--&gt;[ II=2 ]--+

#include &quot;example.h&quot;

//--------------------------------------------
template &lt;int ID&gt;
void proc(stream&lt;int&gt; &amp;in, stream&lt;int&gt; &amp;out)
{
    for (int i = 0; i &lt; 25; i++)
    {
#pragma HLS PIPELINE II=2
#pragma HLS LATENCY min=2 max=2
        int var;
        in.read(var);
        out.write(var);
    }
}

//--------------------------------------------
void mux(stream&lt;int&gt; (&amp;inter)[2], stream&lt;int&gt; &amp;mux_output)
{
    int mux_sel = 0;
    for (int i = 0; i &lt; 50; i++)
    {
#pragma HLS PIPELINE II=1
        int var;
        inter[mux_sel].read(var);
        mux_output.write(var);
        mux_sel = (mux_sel == 0) ? (1) : (0);
    }
}

//--------------------------------------------
void demux(stream&lt;int&gt; &amp;in, stream&lt;int&gt; (&amp;inter)[2])
{
    int demux_sel = 0;
    for (int i = 0; i &lt; 50; i++)
    {
#pragma HLS PIPELINE II=1

        int var;
        in.read(var);
        inter[demux_sel].write(var);
        demux_sel = (demux_sel == 0) ? 1 : 0;
    }
}

void example(stream&lt;int&gt; &amp;in, stream&lt;int&gt; &amp;out)
{
#pragma HLS DATAFLOW

    stream&lt;int&gt; inter[2];
    stream&lt;int&gt; mux_in[2];

#pragma HLS STREAM variable = inter depth = 16
#pragma HLS STREAM variable = mux_in depth = 16

    demux(in, inter);
    proc&lt;0&gt;(inter[0], mux_in[0]);
    proc&lt;1&gt;(inter[1], mux_in[1]);
    mux(mux_in, out);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[👨👩💏五周年啦~🥂🍻]]></title>
        <id>https://Busy-Bob.github.io/post/wu-zhou-nian-la/</id>
        <link href="https://Busy-Bob.github.io/post/wu-zhou-nian-la/">
        </link>
        <updated>2021-01-02T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>2021-1-3： 水吉和臭臭五周年啦！</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609601219382.jpg" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>2021-1-3： 水吉和臭臭五周年啦！</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609601219382.jpg" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="2020年的一月那么近又那么远">2020年的一月，那么近又那么远</h1>
<p>2020年跨年这一天，乡村教师吉返回北京，和被无数考试摧残的臭第一次跨年+参加学校的跨年晚会~</p>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609590165354.jpg" alt="" loading="lazy"></figure>
<p><strong>新新廿廿</strong>的2020来啦</p>
<figure data-type="image" tabindex="2"><img src="https://Busy-Bob.github.io/post-images/1609590219882.jpg" alt="" loading="lazy"></figure>
<p>那时的我们还不知道2020会是一团糟🙊🙉🙈</p>
<br>
<p>回新津(恰好错过了途径武汉的火车)，一起去看望了水吉妈妈家的小泰迪~🐶🐶🐶<br>
<img src="https://Busy-Bob.github.io/post-images/1609592085383.jpg" alt="" loading="lazy"></p>
<h1 id="二月三月家里蹲">二月三月家里蹲</h1>
<p>一月末，疫情开始严重起来了。我们就只能骑着小电驴在两个家间穿梭，一三五在臭臭家，二四六在水吉家。就这样开开心心地度过了两个月~(监管最严格的时候甚至只能在超市碰头....)</p>
<p>情人节的礼物是山地玫瑰！<br>
<img src="https://Busy-Bob.github.io/post-images/1609591290870.jpg" alt="" loading="lazy"></p>
<p>还有小相机~ 这样坏记性的水吉就能够记录下更多在一起的美好回忆啦~<br>
<img src="https://Busy-Bob.github.io/post-images/1609592821850.jpg" alt="" loading="lazy"></p>
<p>当然还有：</p>
<ul>
<li><strong>在家里一起吃火锅</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593178211.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起穿睡衣一起刷剧一起比心</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593229660.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起泡jio</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593307478.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起尬舞，第一次也是唯一的一次两个人同时MEGASTAR</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609594381621.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起玩耍</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609593946953.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>一起做饭</strong><br>
都被吃掉了，没有图了😂<br>
<br></li>
</ul>
<h1 id="四月五月深圳happy">四月五月深圳happy</h1>
<p>四月五月，水吉的哥哥让水吉去深圳帮忙，我也一并去蹭吃蹭喝:)🍎🍖🍗🍤🍨🍡🍜</p>
<ul>
<li><strong>吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595003396.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595010299.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>做饭，然后吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595046890.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>再做饭，然后吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595058832.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>最后在办公室插满了水吉喜欢的花花~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595105586.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="六月七月是分开的两个月">六月七月是分开的两个月</h1>
<p>疫情控制住了，乡村女教师吉吉水结束了网上上课，又回到了山西，成为了落水河最强的地理老师！</p>
<ul>
<li><strong>唯一的约会地点是召唤师峡谷</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595665922.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>水吉给家里买了一堆肉肉~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595729442.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="八月-老司机嘟嘟嘟">八月 老司机嘟嘟嘟</h1>
<p>水吉回来啦！我们也开始学车车！科一我们都考了一样的分数~</p>
<ul>
<li><strong>嘟嘟嘟，开车啦</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609595988555.jpg" alt="" loading="lazy"><br>
<br></li>
<li><strong>也去了广安的猫猫咖啡厅，不过还有人抽烟....</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596042550.jpg" alt="" loading="lazy"><br>
<br></li>
</ul>
<h1 id="九月-返校吃吃吃">九月 返校吃吃吃</h1>
<p>八月末终于可以返校了，水吉爸爸去西藏玩啦，可怜吉只好住在我家。白天学车做饭，晚上和妈妈一起刷剧，最后惊险通过科二， 而我在学校吃吃吃吃吃吃吃🤤🤤🤤</p>
<ul>
<li>
<p><strong>半年多没有浇水的肉肉们</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596722960.jpg" alt="" loading="lazy"><br>
水吉送的肉肉们竟然基本还是好好的，除了实验室的那个小个子顶不住了~<br>
<img src="https://Busy-Bob.github.io/post-images/1609596772512.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>和室友返校第一餐</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596564140.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>返校后和大家吃吃吃</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596800689.jpg" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609596808591.jpg" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609596818858.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>水吉回来啦，去水吉最喜欢的重八~</strong><br>
<img src="https://Busy-Bob.github.io/post-images/1609596866823.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
</ul>
<h1 id="十月-出游-生日和桌游">十月 出游、生日和桌游</h1>
<p>每年十月，都是天高气爽的好日子，非常适合出去玩。</p>
<ul>
<li>
<p><strong>再爬蟒山<s>大爷</s>小弟</strong><br>
今天的十一又去了蟒山，蟒山大爷似乎今年格外的矮小，一会就登顶啦！<br>
<img src="https://Busy-Bob.github.io/post-images/1609597594730.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>去野鸭湖！</strong><br>
担任小学期助教的意外之喜，秋天的野鸭湖真的好漂亮~<br>
<img src="https://Busy-Bob.github.io/post-images/1609597706914.jpg" alt="" loading="lazy"><br>
<br><br>
<img src="https://Busy-Bob.github.io/post-images/1609597713248.jpg" alt="" loading="lazy"><br>
<br><br>
<img src="https://Busy-Bob.github.io/post-images/1609597735946.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>臭臭的生日</strong><br>
这一天，水吉因为有篮球比赛早早离开啦~和大为、sff在宿舍快乐嚯奶茶，开心卡卡颂！<br>
<img src="https://Busy-Bob.github.io/post-images/1609597802417.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>提前送给水吉的生日礼物</strong><br>
今年送给水吉的礼物是一个能够放进书包的itx主机~老夫老妻了，早送早享受💻从此水吉的0-12快乐提莫再也不能找电脑卡的理由了hhhhhhhhh<br>
<img src="https://Busy-Bob.github.io/post-images/1609597946418.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>桌游、桌游！</strong><br>
今年是水吉爱玩的一年，从塞尔达到卡卡颂、卡坦岛，水吉玩个不停！<br>
<img src="https://Busy-Bob.github.io/post-images/1609598264941.jpg" alt="" loading="lazy"><br>
（被迫加入游戏的我）<br>
<br></p>
</li>
</ul>
<h1 id="十一-十二月-吃吃吃和水吉的生日">十一、十二月 吃吃吃和水吉的生日</h1>
<p>今年的冬天格外的冷，所以涮肉要吃起来啊！</p>
<ul>
<li>
<p><strong>听说，初雪和涮肉更配哦</strong><br>
初雪，我们去了四道口最好吃的涮肉，排队到了下午两点.....<br>
<img src="https://Busy-Bob.github.io/post-images/1609598677322.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>繁忙的十二月，我们终于在五道口找了一家咖啡厅</strong><br>
今年因为校园封闭，不能再到校园里面来学习了，经过几番辗转，终于在五道口找到了新的落脚之地，又可以一起学习了。<br>
<img src="https://Busy-Bob.github.io/post-images/1609598757515.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>圣诞——水吉的生日</strong><br>
和水吉以及水吉的室友们一起吃饭唱K，没错我就是K歌之王<sub>(的老公)</sub>。<br>
<img src="https://Busy-Bob.github.io/post-images/1609600194043.jpg" alt="" loading="lazy"><br>
<br></p>
</li>
<li>
<p><strong>再次封校前的最后一次见面</strong><br>
学校又要封闭了，赶在最后一天和水吉见了一面，还吃了小宇哥推荐的好吃串串！（当天因为寒冷变成胆小菇的我↓）<br>
<img src="https://Busy-Bob.github.io/post-images/1609600950737.jpg" alt="" loading="lazy"></p>
</li>
</ul>
<h1 id="2021">2021💑💏</h1>
<p>新的一年，2021🐛🐛🐛啊！</p>
<p>好像没啥好说的了，那 <strong>最后祝大家身体健康!!科研有成!!</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FPGA用来加速运算的调研]]></title>
        <id>https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/</id>
        <link href="https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/">
        </link>
        <updated>2021-01-02T05:53:42.000Z</updated>
        <summary type="html"><![CDATA[<p>FPGA用来加速运算的调研.😁</p>
]]></summary>
        <content type="html"><![CDATA[<p>FPGA用来加速运算的调研.😁</p>
<!-- more -->
<h2 id=""><a href="https://www.zhihu.com/question/280468724/answer/517329473"><strong>FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎</strong></a></h2>
<ol>
<li>并行计算，比如每个步骤没有关连性的循环操作；</li>
<li>算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；</li>
<li>乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；</li>
<li>一些特定的矩阵运算。</li>
</ol>
<h2 id="-2"><a href="https://www.zhihu.com/question/24174597/answer/138717507"><strong>如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎</strong></a></h2>
<ul>
<li>
<p>FPGA 为什么快？「都是同行衬托得好」。<strong>CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存</strong>，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。</p>
</li>
<li>
<p>FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，<strong>不需要指令</strong>。</p>
</li>
<li>
<p><strong>计算密集型任务</strong>(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)</p>
<ul>
<li>Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当</li>
<li>浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。</li>
<li>在数据中心，FPGA 相比 GPU 的核心优势在于<strong>延迟</strong>。</li>
<li>FPGA 同时拥有<strong>流水线并行和数据并行</strong>，而 GPU 几乎只有数据并行（流水线深度受限）。</li>
<li>数据中心的计算任务是<strong>灵活多变</strong>的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资</li>
</ul>
</li>
<li>
<p><strong>通信密集型任务</strong></p>
<ul>
<li>从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。</li>
<li>网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。</li>
</ul>
</li>
<li>
<p>只要规模足够大，对 FPGA 价格过高的担心将是不必要的。</p>
</li>
<li>
<p>对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。</p>
</li>
<li>
<p>把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。</p>
</li>
<li>
<p>每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。<strong>如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态</strong>。这时就不如用冯·诺依曼结构的处理器。</p>
</li>
<li>
<p>FPGA 和 CPU 协同工作，<strong>局部性和重复性强的归 FPGA，复杂的归 CPU</strong>。</p>
</li>
</ul>
<h2 id="-3"><a href="https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf"><strong>将浮点转为定点大幅降低功耗和成本 - Xilinx</strong></a></h2>
<ul>
<li>用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。</li>
<li>对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。</li>
<li><strong>浮点转换为定点的优势</strong>:
<ul>
<li>减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）</li>
<li>功耗更低</li>
<li>材料成本降低</li>
<li>降低时延</li>
<li>相近的性能和精度</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Zynq Book 学习： 引言]]></title>
        <id>https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/</id>
        <link href="https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/">
        </link>
        <updated>2020-12-31T07:25:06.000Z</updated>
        <summary type="html"><![CDATA[<p>学习The Zynq Book第一章时的一些笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习The Zynq Book第一章时的一些笔记</p>
<!-- more -->
<ul>
<li>
<p>Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 <strong>处理器</strong>和一个传统的现场可编程门阵列（Field Programmable Gate Array，<strong>FPGA</strong>）逻辑部件。</p>
</li>
<li>
<p>这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了<strong>高带宽、低延迟</strong>的连接。</p>
</li>
<li>
<p>这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而<strong>不会有</strong>在两个分立的芯片之间的那种<strong>接口开销</strong>。同时又能获得系统被简化为单一芯片所带来的好处，包括<strong>物理尺寸</strong>和整体<strong>成本的降低</strong>。</p>
</li>
<li>
<p><strong>什么是片上系统/SoC (System on Chip)</strong>:</p>
<ul>
<li>单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。</li>
<li>常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）</li>
<li>和板上系统(在pcb板中组合多个元件)对比。</li>
<li><strong>缺点</strong>：
<ul>
<li>开发时间和成本</li>
<li>难以重用，不够灵活（与FPGA不同，直接设计芯片设计）</li>
</ul>
</li>
<li><strong>例子</strong>：手机，PC，平板等的CPU</li>
</ul>
</li>
<li>
<p>Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）</p>
<ul>
<li>处理系统（PS）：支持软件程序和/ 或操作系统</li>
<li>可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统</li>
<li>工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。<br>
<img src="https://Busy-Bob.github.io/post-images/1609400781987.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>软硬件系统关系<br>
<img src="https://Busy-Bob.github.io/post-images/1609401050095.png" alt="" loading="lazy"></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZYNQ中的通信接口(包括PS与PL)]]></title>
        <id>https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/</id>
        <link href="https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/">
        </link>
        <updated>2020-12-31T02:45:05.000Z</updated>
        <content type="html"><![CDATA[<p>总体架构图为：<br>
<img src="https://Busy-Bob.github.io/post-images/1609385485651.png" alt="" loading="lazy"></p>
<ul>
<li><strong>PS (Processing System)中对外通信管脚:</strong>：
<ul>
<li><strong>MIO</strong> (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。</li>
<li><strong>EMIO</strong> (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在<strong>约束文件中分配管脚</strong>，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即<strong>PS可以利用EMIO和PL进行通信</strong>)</em></p>
</blockquote>
<ul>
<li>
<p>**PL (Programmable Logic) 和 PS的通信接口 **<br>
<img src="https://Busy-Bob.github.io/post-images/1609403066047.png" alt="" loading="lazy"></p>
<ul>
<li><strong>通用AXI（General Purpose AXI）</strong>： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的<strong>中低速通信</strong>。接口是透传的不带缓冲。</li>
<li><strong>加速器一致性端口（Accelerator Coherency Port）</strong>： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）</li>
<li><strong>高性能端口（High Performance Ports）</strong>： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。<strong>(PL直接从DDR中获取数据)</strong></li>
<li><strong>EMIO</strong>： 原本是用来连接I2C等协议的外设，也可以给PS使用。</li>
</ul>
</li>
</ul>
<h1 id="pynq中python类对应">PYNQ中python类对应：</h1>
<ul>
<li><strong>GPIO</strong>： 对应MIO， EMIO。（类似于单片机中的GPIO）</li>
<li><strong>MMIO</strong>： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）</li>
<li><strong>Xlnk</strong>： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）</li>
<li><strong>DMA</strong>： 对应HP AXI，访问DMA，即高性能AXI端口</li>
</ul>
<h1 id="axi-协议">AXI 协议</h1>
<ul>
<li>AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。</li>
<li>AXI4_LITE： 只支持每次连接传输一个数据（非批量）。</li>
<li>AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NAND Flash, NOR Flash 的区别和应用]]></title>
        <id>https://Busy-Bob.github.io/post/nand-flash-nor-flash/</id>
        <link href="https://Busy-Bob.github.io/post/nand-flash-nor-flash/">
        </link>
        <updated>2020-12-29T14:06:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="flash-原理">Flash 原理：</h2>
<p><img src="https://Busy-Bob.github.io/post-images/1609254997519.png" alt="" loading="lazy"><br>
<img src="https://Busy-Bob.github.io/post-images/1609253806308.png" alt="" loading="lazy"><br>
参考<a href="https://www.youtube.com/watch?v=aO_kBa9DzPQ">youtube</a>。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。</p>
<h2 id="nand-flash-和-nor-flash-区别">NAND Flash 和 NOR Flash 区别</h2>
<figure data-type="image" tabindex="1"><img src="https://Busy-Bob.github.io/post-images/1609253097307.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>NAND 不能够取指令（类似于硬盘）</strong></li>
<li><strong>NOR 可以取指令（类似于内存）</strong></li>
</ul>
<p>由于CPU运行时候需要三步：<strong>取指、译码、执行</strong> 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。</p>
<h2 id="应用场景">应用场景</h2>
<ul>
<li><strong>NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）</strong></li>
<li><strong>NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）</strong></li>
</ul>
<h2 id="ssd和u盘区别">SSD和U盘区别</h2>
<blockquote>
<p>储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的<br>
主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么<br>
存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发<br>
接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快</p>
<p>作者：李诗华<br>
链接：https://www.zhihu.com/question/265335741/answer/292414149<br>
来源：知乎</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 错误处理中多种类型Error传播的处理方式]]></title>
        <id>https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/</id>
        <link href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/">
        </link>
        <updated>2020-12-01T07:27:56.000Z</updated>
        <summary type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用<code>Box&lt;dyn std::error::Error&gt;</code>来用trait object来代表所有类型的错误；另一种是使用自定义的<code>enum</code>来装所有的错误。</p>
<!-- more -->
<p>主要参考：<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a> 和 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html">Result 与可恢复的错误</a>.</p>
<h1 id="tl-dr">TL; DR</h1>
<ul>
<li><code>Box&lt;dyn std::error::Error&gt;</code> 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）</li>
<li>自定义一个<code>enum</code>通常用在需要对错误进行恢复的时候。（容易检测类型）</li>
</ul>
<h1 id="boxdyn-error-方式来聚合error"><code>Box&lt;dyn Error&gt;</code> 方式来聚合Error</h1>
<pre><code class="language-rust">fn do_something() -&gt; std::result::Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{
    let path = &quot;./dat&quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&lt;u32&gt;()?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}
</code></pre>
<p>三者分别返回不同的错误类型，但是都可以用<code>Box&lt;dyn std::error::Error&gt;</code>来装。</p>
<ul>
<li><strong>优点</strong>： 方便书写。</li>
<li><strong>缺点</strong>： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“<strong>反射</strong>”( <code>Any</code> trait)才能够确定。而不能直接match。</li>
</ul>
<h1 id="利用-enum-来聚合error">利用 <code>enum</code> 来聚合Error</h1>
<blockquote>
<p>内容来自<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">细说Rust错误处理</a></p>
</blockquote>
<p>自定义一个<code>error</code>需要实现如下几步：</p>
<ul>
<li>手动实现impl <code>std::fmt::Display</code>的trait,并<strong>实现</strong> <code>fmt(...)</code>方法。</li>
<li>手动实现impl <code>std::fmt::Debug</code>的<code>trait</code>，一般直接添加注解即可：<code>#[derive(Debug)]</code></li>
<li>手动实现impl <code>std::error::Error</code>的<code>trait</code>,并根据自身<code>error</code>级别是否<strong>覆盖</strong><code>std::error::Error</code>中的<code>source()</code>方法。</li>
</ul>
<p>下面的内容中：</p>
<ul>
<li><code>CustomError</code>为我们实现的<strong>自定义Error</strong></li>
<li><code>CustomError</code>有三个<strong>子类型Error</strong></li>
<li><code>CustomError</code>分别实现了三个<strong>子类型Error</strong> <code>From</code>的trait,将其类型包装为<strong>自定义Error</strong>的子类型</li>
</ul>
<p>好了，有了自定义的<code>CustomError</code>，那怎么使用呢? 我们看代码：</p>
<pre><code class="language-rust">use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&gt; std::result::Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 基于回调的异步方法分析]]></title>
        <id>https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/">
        </link>
        <updated>2020-11-30T08:57:43.000Z</updated>
        <summary type="html"><![CDATA[<p>基于<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>文中的回调代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>基于<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>文中的回调代码。</p>
<!-- more -->
<h1 id="原作者的一些分析">原作者的一些分析</h1>
<p>基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(<strong>指针</strong>)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。</p>
<ul>
<li><strong>优势：</strong>
<ul>
<li>易于在大多数语言中实现</li>
<li>没有上下文切换</li>
<li>相对较低的内存开销(在大多数情况下)</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。</li>
<li>很难理解。许多人已经知道这是“回调地狱”。</li>
<li>这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。</li>
<li>由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。</li>
</ul>
</li>
</ul>
<h1 id="代码">代码</h1>
<p>通过代码，学习到了一些新东西，主要包括：</p>
<ul>
<li><code>thread_local!</code> ：用来对每一个线程初始化同一个变量的一个新的副本。</li>
<li>trait 对象： <code>Box&lt;dyn FnOnce() -&gt; ()&gt;</code>,  <code>dyn Trait</code>表示一个类型，强调是动态分发，并且必须是一个<code>impl</code>了<code>Trait</code>的类型。</li>
<li>传递闭包可以使用<code>impl Trait</code>，这也是一个类型，并且该类型是<code>impl</code>了<code>Trait</code>的类型。</li>
<li><code>thread::spawn</code>会直接新开一个子线程运行，不会造成主线程阻塞。</li>
<li><code>std::sync::mpsc::Receiver.iter()</code> 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的<code>.next()</code> 才会变成<code>None</code>，否则会一直等待。</li>
</ul>
<blockquote>
<p>回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。</p>
</blockquote>
<pre><code class="language-rust">
fn program_main() {
    // 第一个输出
    println!(&quot;So we start the program here!&quot;);
    // 运行到这儿的时候， 0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(200, || {
        // 第五个输出
        println!(&quot;We create tasks with a callback that runs once the task finished!&quot;);
    });
    // 运行到这儿的时候， 仍然是0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(100, || {
        // 第三个输出
        println!(&quot;We can even chain sub-tasks...&quot;);
        set_timeout(50, || {
            // 第四个输出
            println!(&quot;...like this!&quot;);
        })
    });
    // 运行到这儿的时候， 仍然是0ms
    // 第二个输出
    println!(&quot;While our tasks are executing we can do other stuff instead of waiting.&quot;);
}

fn main() {
    RT.with(|rt| rt.run(program_main));
}

use std::sync::mpsc::{channel, Receiver, Sender};
use std::{cell::RefCell, collections::HashMap, thread};


// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本
// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&lt;Runtime&gt;
// 这儿好像只用到了一个副本
thread_local! {
    static RT: Runtime = Runtime::new();
}

struct Runtime {
    // callbacks 中的Box&lt;dyn FnOnce() -&gt; ()&gt; 是一个 trait 对象。 
    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&gt; u32。 
    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。
    callbacks: RefCell&lt;HashMap&lt;usize, Box&lt;dyn FnOnce() -&gt; ()&gt;&gt;&gt;,
    // 储存下一个闭包的id
    next_id: RefCell&lt;usize&gt;,
    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id
    evt_sender: Sender&lt;usize&gt;,
    // 接受下一个该运行的闭包的id
    evt_reciever: Receiver&lt;usize&gt;,
}

// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. 
// Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.
// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait
// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html
fn set_timeout(ms: u64, cb: impl FnOnce() + 'static) {
    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。
    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。
    // 相当于用.with()就是在使用该变量的函数。
    RT.with(|rt| {
        let id = *rt.next_id.borrow();
        // next_id递增
        *rt.next_id.borrow_mut() += 1;
        // callbacks存 (id: usize, Box&lt;dyn FnOnce() -&gt; ()&gt;)
        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知
        // cb 在输入参数中用的impl FnOnce() + 'static 来限定。
        rt.callbacks.borrow_mut().insert(id, Box::new(cb));
        // The sending-half of Rust's asynchronous channel type. 
        // This half can only be owned by one thread, but it can be cloned to send to other threads.
        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个
        let evt_sender = rt.evt_sender.clone();
        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去
        thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(ms));
            // 在延时结束后，发送当前延时结束的任务id
            evt_sender.send(id).unwrap();
        });
    });
}


impl Runtime {
    fn new() -&gt; Self {
        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver
        let (evt_sender, evt_reciever) = channel();
        Runtime {
            callbacks: RefCell::new(HashMap::new()),
            next_id: RefCell::new(1),
            evt_sender,
            evt_reciever,
        }
    }

    // 这儿是在运行一个函数.
    fn run(&amp;self, program: fn()) {
        // 直接运行， 
        program();
        // 0ms 运行到这儿
        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。
        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.
        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None
        for evt_id in &amp;self.evt_reciever {
            // 这儿直接从HashMap里remove出对应编号的闭包。
            let cb = self.callbacks.borrow_mut().remove(&amp;evt_id).unwrap();
            cb();
            // 是不是也不需要这句话？
            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了
            if self.callbacks.borrow().is_empty() {
                break;
            }
        }
    }
}

</code></pre>
<h1 id="总结">总结</h1>
<ul>
<li>如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&quot;学歌&quot;。所以，在回调逻辑中 <code>sing_song()</code>作为闭包， <code>learn_song()</code> 作为子线程，主线程运行<code>dance()</code> 。子线程结束后再运行这个闭包。运行顺序是 <code>learn_song()</code> （子线程）和 <code>dance()</code>  （主线程）同时运行，在两个任务均完成后， 再回调<code>sing_song()</code>这个闭包。</li>
<li><strong>子线程</strong>对应 <strong>“等待资源”</strong> ； <strong>闭包</strong>对应“<strong>接收到等待资源后的操作”</strong>。</li>
</ul>
<pre><code class="language-rust">async fn learn_and_sing() {
    // 在唱歌之前等待学歌完成
    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。
    let song = learn_song().await;
    sing_song(song).await;
}
 async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成
     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞
     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，
     // 这个‘async_main'函数就会变成阻塞状态，并生成一个执行器
    futures::join!(f1, f2)
}
 fn main() {
    block_on(async_main());
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc]]></title>
        <id>https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/">
        </link>
        <updated>2020-11-23T12:15:59.000Z</updated>
        <summary type="html"><![CDATA[<p>对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)</p>
<!-- more -->
<h2 id="const_unit_poc-利用const-generics实现的物理单位库"><code>const_unit_poc</code> ：利用const generics实现的物理单位库</h2>
<p><code>const_unit_poc</code>  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked)]
use const_unit_poc::values::{m, kg, s, N};

let distance = 1.0 * m;
let mass = 18.0 * kg;
let force = distance * mass / (1.8 * s * 2.0 * s);
assert_eq!(force, 5.0 * N);

let mut mutable_distance = 3.2 * m;
mutable_distance -= 0.2 * m;
mutable_distance += 2.0 * m;

assert_eq!(mutable_distance, 5.0 * m);
</code></pre>
<p>代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。</p>
<h2 id="const_unit_poc-源码分析"><code>const_unit_poc</code> 源码分析</h2>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked, doc_cfg)]
#![allow(incomplete_features)]
#![cfg_attr(feature = &quot;non_ascii&quot;, feature(non_ascii_idents))]

use std::ops;

pub mod units;
pub mod values;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_snake_case)]
pub struct SiUnit {
    m: i8,
    kg: i8,
    s: i8,
    A: i8,
    K: i8,
    mol: i8,
    cd: i8,
}

// 后面还有内容
</code></pre>
<p>这里引入了<code>units</code>, <code>values</code>两个mod，并且声明了<code>SiUnit</code> 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。</p>
<p>看到这儿，笔者推测应该是使用 <code>SiUnit</code> 这个结构体来实例化各种常用的单位（如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>），其中成员的值表示该单位表示成基本单位后的指数的值（如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>m</mi><mo>∗</mo><msup><mi>s</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N=m*s^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>， 则<code>N.m == 1; N.s == -2</code>）。</p>
<p>再看一下引入的模块<code>units</code>的内容</p>
<h3 id="units的实现">units的实现</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs"><code>./src/units.rs</code></a>：</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use super::SiUnit;
const NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };
/// meter
pub const m: SiUnit = SiUnit { m: 1, ..NONE };
/// 中间内容省略
/// lux
pub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };
/// square meter
pub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };
/// cubic meter
pub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };
</code></pre>
<p>的确和猜想一致！注意结构体实例化时候这儿使用了<code>..NONE</code>，这是用已经创建的实例None上<strong>更新部分参数</strong>，创建新的实例，见<a href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">使用结构体更新语法从其他实例创建实例</a>。这儿使用了const使得各个单位全局可见且不可变。</p>
<p>现在已经有了单位，但是我们注意到代码中<code>assert_eq!(mutable_distance, 5.0 * m);</code>不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。</p>
<h3 id="对单位系数的包装">对单位系数的包装</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs"><code>./src/values.rs</code></a>：</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use crate::{units, Quantity};
// base
/// 1 meter
pub const m: Quantity&lt;{ units::m }&gt; = Quantity { raw_value: 1.0 };
/// 1 kilogram
pub const kg: Quantity&lt;{ units::kg }&gt; = Quantity { raw_value: 1.0 };
/// 1 second
pub const s: Quantity&lt;{ units::s }&gt; = Quantity { raw_value: 1.0 };
/// 后面还有
</code></pre>
<p><strong>注意</strong>：<code>use crate::{units, Quantity}</code>, 代表的是导入的当前<code>crate</code>中的<code>units</code>和<code>Quantity</code>。<br>
<strong>const 泛型</strong>: 从这儿的可以大概可以看出，<code>Quantity</code>的泛型参数是一个const常量，包装每一个<code>units.rs</code>中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：<code>Quantity&lt;{ units::m }&gt; { raw_value: 1.0 }</code>。 所以是用<code>raw_value</code>来表示每一个单位的系数。</p>
<p>所以再来看看<code>Quantity</code>的定义吧。</p>
<p>###结构体 <code>Quantity</code>的定义</p>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Quantity&lt;const U: SiUnit&gt; {
    pub raw_value: f64,
}
</code></pre>
<p>简单干脆的使用const 类型作为泛型参数。</p>
<h3 id="加减运算">加减运算</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Add for Quantity&lt;U&gt; {
    type Output = Self;

    fn add(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value + rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::AddAssign for Quantity&lt;U&gt; {
    fn add_assign(&amp;mut self, rhs: Self) {
        self.raw_value += rhs.raw_value;
    }
}

impl&lt;const U: SiUnit&gt; ops::Sub for Quantity&lt;U&gt; {
    type Output = Self;

    fn sub(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value - rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::SubAssign for Quantity&lt;U&gt; {
    fn sub_assign(&amp;mut self, rhs: Self) {
        self.raw_value -= rhs.raw_value;
    }
}
</code></pre>
<p>由于加减运算并不会变单位，所以就是对系数的加减，非常直接。</p>
<h3 id="乘除运算">乘除运算</h3>
<ul>
<li>一个数字与一个Quantity相乘，单位不变：</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Mul&lt;f64&gt; for Quantity&lt;U&gt; {
    type Output = Quantity&lt;U&gt;;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs }
    }
}
</code></pre>
<ul>
<li>两个带单位的量相乘，单位发生变化，也就是<code>Quantity&lt;U&gt;</code>的泛型参数发生了变化，此时需要重新实例化一个<code>Quantity&lt;U&gt;</code>结构体：</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>：</p>
<pre><code class="language-rust">// Quantity相乘转换为unit相乘，UL.unit_mul(UR)
impl&lt;const UL: SiUnit, const UR: SiUnit&gt; ops::Mul&lt;Quantity&lt;UR&gt;&gt; for Quantity&lt;UL&gt;
where
    Quantity&lt;{ UL.unit_mul(UR) }&gt;: ,
{
    type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;

    fn mul(self, rhs: Quantity&lt;UR&gt;) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs.raw_value }
    }
}
// unit相乘
impl SiUnit {
    const fn unit_mul(self, rhs: Self) -&gt; Self {
        Self {
            m: self.m + rhs.m,
            kg: self.kg + rhs.kg,
            s: self.s + rhs.s,
            A: self.A + rhs.A,
            K: self.K + rhs.K,
            mol: self.mol + rhs.mol,
            cd: self.cd + rhs.cd,
        }
    }
}
</code></pre>
<ul>
<li>这儿对泛型的约束很神奇，竟然是这样写<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;:</code> ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....</li>
</ul>
<pre><code>error: unconstrained generic constant
   --&gt; src\lib.rs:156:5
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
    |
help: consider adding a `where` bound for this expression  
   --&gt; src\lib.rs:156:28
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |                            ^^^^^^^^^^^^^^^^^^^     
</code></pre>
<ul>
<li>另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;</code> ，否则也会出错。这在最近的<a href="https://github.com/rust-lang/rust/pull/79135">Stabilization report</a>里面也有提到。</li>
</ul>
<blockquote>
<p><strong>Const arguments</strong></p>
<p>Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, <strong>most expressions must be contained within a block</strong>, with two exceptions:</p>
<ol>
<li>literals and single-segment path expressions</li>
<li>array lengths</li>
</ol>
<p>This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.</p>
<p>In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // ERR
</code></pre>
<p>To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
</code></pre>
</blockquote>
<p>简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。</p>
<h2 id="总结">总结</h2>
<p>这篇文章主要是了解了const 泛型在做啥，以及如何做的。</p>
<p>通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。</p>
]]></content>
    </entry>
</feed>