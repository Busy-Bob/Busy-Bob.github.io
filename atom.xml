<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Busy-Bob.github.io</id>
    <title>å‹ºæµ·çš„åšå®¢</title>
    <updated>2020-12-01T08:15:22.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Busy-Bob.github.io"/>
    <link rel="self" href="https://Busy-Bob.github.io/atom.xml"/>
    <subtitle>å°½åº”å°½ä¹‹äº‹ï¼Œåšè®©è‡ªå·±å¼€å¿ƒçš„äº‹ã€‚</subtitle>
    <logo>https://Busy-Bob.github.io/images/avatar.png</logo>
    <icon>https://Busy-Bob.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, å‹ºæµ·çš„åšå®¢</rights>
    <entry>
        <title type="html"><![CDATA[Rust é”™è¯¯å¤„ç†ä¸­å¤šç§ç±»å‹Errorä¼ æ’­çš„å¤„ç†æ–¹å¼]]></title>
        <id>https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/</id>
        <link href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/">
        </link>
        <updated>2020-12-01T07:27:56.000Z</updated>
        <summary type="html"><![CDATA[<p>æœ‰ä¸¤ç§æ–¹å¼æ¥èšåˆå¤šç§ç±»å‹çš„Erroræ¥è¿›è¡Œå‡½æ•°é—´çš„ä¼ æ’­ï¼šä¸€ç§æ˜¯ä½¿ç”¨<code>Box&lt;dyn std::error::Error&gt;</code>æ¥ç”¨trait objectæ¥ä»£è¡¨æ‰€æœ‰ç±»å‹çš„é”™è¯¯ï¼›å¦ä¸€ç§æ˜¯ä½¿ç”¨è‡ªå®šä¹‰çš„<code>enum</code>æ¥è£…æ‰€æœ‰çš„é”™è¯¯ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>æœ‰ä¸¤ç§æ–¹å¼æ¥èšåˆå¤šç§ç±»å‹çš„Erroræ¥è¿›è¡Œå‡½æ•°é—´çš„ä¼ æ’­ï¼šä¸€ç§æ˜¯ä½¿ç”¨<code>Box&lt;dyn std::error::Error&gt;</code>æ¥ç”¨trait objectæ¥ä»£è¡¨æ‰€æœ‰ç±»å‹çš„é”™è¯¯ï¼›å¦ä¸€ç§æ˜¯ä½¿ç”¨è‡ªå®šä¹‰çš„<code>enum</code>æ¥è£…æ‰€æœ‰çš„é”™è¯¯ã€‚</p>
<!-- more -->
<p>ä¸»è¦å‚è€ƒï¼š<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">ç»†è¯´Rusté”™è¯¯å¤„ç†</a> å’Œ <a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html">Result ä¸å¯æ¢å¤çš„é”™è¯¯</a>.</p>
<h1 id="tl-dr">TL; DR</h1>
<ul>
<li><code>Box&lt;dyn std::error::Error&gt;</code> é€šå¸¸ç”¨åœ¨ä¸å¯¹é”™è¯¯è¿›è¡Œæ¢å¤çš„æ—¶å€™ã€‚ï¼ˆä¸å®¹æ˜“æ£€æµ‹åˆ°é”™è¯¯ç±»å‹ï¼‰</li>
<li>è‡ªå®šä¹‰ä¸€ä¸ª<code>enum</code>é€šå¸¸ç”¨åœ¨éœ€è¦å¯¹é”™è¯¯è¿›è¡Œæ¢å¤çš„æ—¶å€™ã€‚ï¼ˆå®¹æ˜“æ£€æµ‹ç±»å‹ï¼‰</li>
</ul>
<h1 id="boxdyn-error-æ–¹å¼æ¥èšåˆerror"><code>Box&lt;dyn Error&gt;</code> æ–¹å¼æ¥èšåˆError</h1>
<pre><code class="language-rust">fn do_something() -&gt; std::result::Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{
    let path = &quot;./dat&quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&lt;u32&gt;()?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}
</code></pre>
<p>ä¸‰è€…åˆ†åˆ«è¿”å›ä¸åŒçš„é”™è¯¯ç±»å‹ï¼Œä½†æ˜¯éƒ½å¯ä»¥ç”¨<code>Box&lt;dyn std::error::Error&gt;</code>æ¥è£…ã€‚</p>
<ul>
<li><strong>ä¼˜ç‚¹</strong>ï¼š æ–¹ä¾¿ä¹¦å†™ã€‚</li>
<li><strong>ç¼ºç‚¹</strong>ï¼š åœ¨ä¼ é€’åè¯¥Resultåï¼Œè¯¥trait object å¯¹åº”çš„å®é™…çš„é”™è¯¯ç±»å‹éš¾ä»¥ç¡®å®šï¼Œåº”è¯¥éœ€è¦ç”¨â€œ<strong>åå°„</strong>â€( <code>Any</code> trait)æ‰èƒ½å¤Ÿç¡®å®šã€‚è€Œä¸èƒ½ç›´æ¥matchã€‚</li>
</ul>
<h1 id="åˆ©ç”¨-enum-æ¥èšåˆerror">åˆ©ç”¨ <code>enum</code> æ¥èšåˆError</h1>
<blockquote>
<p>å†…å®¹æ¥è‡ª<a href="https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074">ç»†è¯´Rusté”™è¯¯å¤„ç†</a></p>
</blockquote>
<p>è‡ªå®šä¹‰ä¸€ä¸ª<code>error</code>éœ€è¦å®ç°å¦‚ä¸‹å‡ æ­¥ï¼š</p>
<ul>
<li>æ‰‹åŠ¨å®ç°impl <code>std::fmt::Display</code>çš„trait,å¹¶<strong>å®ç°</strong> <code>fmt(...)</code>æ–¹æ³•ã€‚</li>
<li>æ‰‹åŠ¨å®ç°impl <code>std::fmt::Debug</code>çš„<code>trait</code>ï¼Œä¸€èˆ¬ç›´æ¥æ·»åŠ æ³¨è§£å³å¯ï¼š<code>#[derive(Debug)]</code></li>
<li>æ‰‹åŠ¨å®ç°impl <code>std::error::Error</code>çš„<code>trait</code>,å¹¶æ ¹æ®è‡ªèº«<code>error</code>çº§åˆ«æ˜¯å¦<strong>è¦†ç›–</strong><code>std::error::Error</code>ä¸­çš„<code>source()</code>æ–¹æ³•ã€‚</li>
</ul>
<p>ä¸‹é¢çš„å†…å®¹ä¸­ï¼š</p>
<ul>
<li><code>CustomError</code>ä¸ºæˆ‘ä»¬å®ç°çš„<strong>è‡ªå®šä¹‰Error</strong></li>
<li><code>CustomError</code>æœ‰ä¸‰ä¸ª<strong>å­ç±»å‹Error</strong></li>
<li><code>CustomError</code>åˆ†åˆ«å®ç°äº†ä¸‰ä¸ª<strong>å­ç±»å‹Error</strong> <code>From</code>çš„trait,å°†å…¶ç±»å‹åŒ…è£…ä¸º<strong>è‡ªå®šä¹‰Error</strong>çš„å­ç±»å‹</li>
</ul>
<p>å¥½äº†ï¼Œæœ‰äº†è‡ªå®šä¹‰çš„<code>CustomError</code>ï¼Œé‚£æ€ä¹ˆä½¿ç”¨å‘¢? æˆ‘ä»¬çœ‹ä»£ç ï¼š</p>
<pre><code class="language-rust">use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&gt; std::result::Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}

///è¯»å–æ–‡ä»¶å†…å®¹
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// è½¬æ¢ä¸ºutf8å†…å®¹
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// è½¬åŒ–ä¸ºu32æ•°å­—
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust åŸºäºå›è°ƒçš„å¼‚æ­¥æ–¹æ³•åˆ†æ]]></title>
        <id>https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/">
        </link>
        <updated>2020-11-30T08:57:43.000Z</updated>
        <summary type="html"><![CDATA[<p>åŸºäº<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>æ–‡ä¸­çš„å›è°ƒä»£ç ã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>åŸºäº<a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches">Futures Explained in 200 Lines of Rust</a>æ–‡ä¸­çš„å›è°ƒä»£ç ã€‚</p>
<!-- more -->
<h1 id="åŸä½œè€…çš„ä¸€äº›åˆ†æ">åŸä½œè€…çš„ä¸€äº›åˆ†æ</h1>
<p>åŸºäºå›è°ƒæ–¹æ³•èƒŒåçš„æ•´ä¸ªæ€æƒ³æ˜¯ä¿å­˜ä¸€ä¸ªæŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘ä¸€ç»„æˆ‘ä»¬å¸Œæœ›ç¨åè¿è¡Œçš„ä¸€ç³»åˆ—æŒ‡ä»¤ï¼Œä»¥åŠéœ€è¦çš„å„ç§çŠ¶æ€ã€‚åœ¨Rustï¼Œè¿™(<strong>æŒ‡é’ˆ</strong>)å°†æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†æ­¤ä¿¡æ¯ä¿å­˜åœ¨ä¸€ä¸ªHashMapä¸­ï¼Œä½†è¿™ä¸æ˜¯å”¯ä¸€çš„é€‰é¡¹ã€‚</p>
<ul>
<li><strong>ä¼˜åŠ¿ï¼š</strong>
<ul>
<li>æ˜“äºåœ¨å¤§å¤šæ•°è¯­è¨€ä¸­å®ç°</li>
<li>æ²¡æœ‰ä¸Šä¸‹æ–‡åˆ‡æ¢</li>
<li>ç›¸å¯¹è¾ƒä½çš„å†…å­˜å¼€é”€(åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹)</li>
</ul>
</li>
<li><strong>ç¼ºç‚¹ï¼š</strong>
<ul>
<li>ç”±äºæ¯ä¸ªä»»åŠ¡éƒ½å¿…é¡»ä¿å­˜ä»¥åéœ€è¦çš„çŠ¶æ€ï¼Œå› æ­¤å†…å­˜ä½¿ç”¨å°†éšç€è®¡ç®—é“¾ä¸­çš„å›è°ƒæ¬¡æ•°çº¿æ€§å¢é•¿ã€‚</li>
<li>å¾ˆéš¾ç†è§£ã€‚è®¸å¤šäººå·²ç»çŸ¥é“è¿™æ˜¯â€œå›è°ƒåœ°ç‹±â€ã€‚</li>
<li>è¿™æ˜¯ä¸€ç§éå¸¸ä¸åŒçš„ç¼–å†™ç¨‹åºçš„æ–¹å¼ï¼Œå¹¶ä¸”éœ€è¦å¤§é‡é‡å†™æ‰èƒ½ä»â€œæ­£å¸¸â€çš„ç¨‹åºæµè½¬æ¢ä¸ºä½¿ç”¨â€œåŸºäºå›è°ƒâ€çš„ç¨‹åºæµã€‚</li>
<li>ç”±äºRustçš„æ‰€æœ‰æƒæ¨¡å‹ï¼Œä»»åŠ¡ä¹‹é—´çš„çŠ¶æ€å…±äº«åœ¨ä½¿ç”¨è¯¥æ–¹æ³•æ—¶æ˜¯ä¸€ä¸ªå›°éš¾çš„é—®é¢˜ã€‚</li>
</ul>
</li>
</ul>
<h1 id="ä»£ç ">ä»£ç </h1>
<p>é€šè¿‡ä»£ç ï¼Œå­¦ä¹ åˆ°äº†ä¸€äº›æ–°ä¸œè¥¿ï¼Œä¸»è¦åŒ…æ‹¬ï¼š</p>
<ul>
<li><code>thread_local!</code> ï¼šç”¨æ¥å¯¹æ¯ä¸€ä¸ªçº¿ç¨‹åˆå§‹åŒ–åŒä¸€ä¸ªå˜é‡çš„ä¸€ä¸ªæ–°çš„å‰¯æœ¬ã€‚</li>
<li>trait å¯¹è±¡ï¼š <code>Box&lt;dyn FnOnce() -&gt; ()&gt;</code>,  <code>dyn Trait</code>è¡¨ç¤ºä¸€ä¸ªç±»å‹ï¼Œå¼ºè°ƒæ˜¯åŠ¨æ€åˆ†å‘ï¼Œå¹¶ä¸”å¿…é¡»æ˜¯ä¸€ä¸ª<code>impl</code>äº†<code>Trait</code>çš„ç±»å‹ã€‚</li>
<li>ä¼ é€’é—­åŒ…å¯ä»¥ä½¿ç”¨<code>impl Trait</code>ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹ï¼Œå¹¶ä¸”è¯¥ç±»å‹æ˜¯<code>impl</code>äº†<code>Trait</code>çš„ç±»å‹ã€‚</li>
<li><code>thread::spawn</code>ä¼šç›´æ¥æ–°å¼€ä¸€ä¸ªå­çº¿ç¨‹è¿è¡Œï¼Œä¸ä¼šé€ æˆä¸»çº¿ç¨‹é˜»å¡ã€‚</li>
<li><code>std::sync::mpsc::Receiver.iter()</code> è¿™æ˜¯ä¸€ä¸ªé˜»å¡çš„è¿­ä»£å™¨ï¼Œåªæœ‰å½“senderéƒ½è¢«dropçš„æ—¶å€™ï¼Œè¯¥è¿­ä»£å™¨çš„<code>.next()</code> æ‰ä¼šå˜æˆ<code>None</code>ï¼Œå¦åˆ™ä¼šä¸€ç›´ç­‰å¾…ã€‚</li>
</ul>
<blockquote>
<p>å›è°ƒæ˜¯åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸Šè¿è¡Œçš„ã€‚ è¿™ä¸ªä¾‹å­ä¸­,æˆ‘ä»¬åˆ›å»ºçš„å­çº¿ç¨‹åŸºæœ¬ä¸Šåªæ˜¯ç”¨ä½œè®¡æ—¶å™¨ï¼Œä½†å¯ä»¥è¡¨ç¤ºä»»ä½•ç±»å‹çš„æˆ‘ä»¬å°†ä¸å¾—ä¸ç­‰å¾…çš„èµ„æºã€‚</p>
</blockquote>
<pre><code class="language-rust">
fn program_main() {
    // ç¬¬ä¸€ä¸ªè¾“å‡º
    println!(&quot;So we start the program here!&quot;);
    // è¿è¡Œåˆ°è¿™å„¿çš„æ—¶å€™ï¼Œ 0ms
    // 1ã€æŠŠé—­åŒ…é‡Œçš„ä»»åŠ¡æ”¾åœ¨callbacksä¸­ï¼Œnext_id(æ­¤æ—¶ä¸º1)ä½œä¸ºkeyï¼Œé—­åŒ…ä½œä¸ºvalï¼Œ next_id é€’å¢ã€‚
    // 2ã€ä¼šæœ‰ä¸€ä¸ªå­çº¿ç¨‹åœ¨set_timeouté‡Œé¢è¢«åˆ›å»ºï¼Œåªè´Ÿè´£å»¶æ—¶ã€‚è¿è¡Œæ—¶å€™ä¸ä¼šè¢«è¯¥è´Ÿè´£å»¶æ—¶å­çº¿ç¨‹é˜»å¡
    set_timeout(200, || {
        // ç¬¬äº”ä¸ªè¾“å‡º
        println!(&quot;We create tasks with a callback that runs once the task finished!&quot;);
    });
    // è¿è¡Œåˆ°è¿™å„¿çš„æ—¶å€™ï¼Œ ä»ç„¶æ˜¯0ms
    // 1ã€æŠŠé—­åŒ…é‡Œçš„ä»»åŠ¡æ”¾åœ¨callbacksä¸­ï¼Œnext_id(æ­¤æ—¶ä¸º2)ä½œä¸ºkeyï¼Œé—­åŒ…ä½œä¸ºvalï¼Œ next_id é€’å¢ã€‚
    // 2ã€ä¼šæœ‰ä¸€ä¸ªå­çº¿ç¨‹åœ¨set_timeouté‡Œé¢è¢«åˆ›å»ºï¼Œåªè´Ÿè´£å»¶æ—¶ã€‚è¿è¡Œæ—¶å€™ä¸ä¼šè¢«è¯¥è´Ÿè´£å»¶æ—¶å­çº¿ç¨‹é˜»å¡
    set_timeout(100, || {
        // ç¬¬ä¸‰ä¸ªè¾“å‡º
        println!(&quot;We can even chain sub-tasks...&quot;);
        set_timeout(50, || {
            // ç¬¬å››ä¸ªè¾“å‡º
            println!(&quot;...like this!&quot;);
        })
    });
    // è¿è¡Œåˆ°è¿™å„¿çš„æ—¶å€™ï¼Œ ä»ç„¶æ˜¯0ms
    // ç¬¬äºŒä¸ªè¾“å‡º
    println!(&quot;While our tasks are executing we can do other stuff instead of waiting.&quot;);
}

fn main() {
    RT.with(|rt| rt.run(program_main));
}

use std::sync::mpsc::{channel, Receiver, Sender};
use std::{cell::RefCell, collections::HashMap, thread};


// threadlocal: å˜é‡æ˜¯åŒä¸€ä¸ªï¼Œä½†æ˜¯æ¯ä¸ªçº¿ç¨‹éƒ½ä½¿ç”¨åŒä¸€ä¸ªåˆå§‹å€¼ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨åŒä¸€ä¸ªå˜é‡çš„ä¸€ä¸ªæ–°çš„å‰¯æœ¬
// æ¯ä¸ªçº¿ç¨‹éƒ½å®ä¾‹åŒ–äº†ä¸€ä¸ªRuntimeï¼Œ å®é™…ä¸ŠRTæ˜¯ä¸€ä¸ªRT: std::thread::LocalKey&lt;Runtime&gt;
// è¿™å„¿å¥½åƒåªç”¨åˆ°äº†ä¸€ä¸ªå‰¯æœ¬
thread_local! {
    static RT: Runtime = Runtime::new();
}

struct Runtime {
    // callbacks ä¸­çš„Box&lt;dyn FnOnce() -&gt; ()&gt; æ˜¯ä¸€ä¸ª trait å¯¹è±¡ã€‚ 
    // æ¯ä¸€ä¸ªé—­åŒ…å®ä¾‹æœ‰å…¶è‡ªå·±ç‹¬æœ‰çš„åŒ¿åç±»å‹, é—­åŒ…æœ‰trait boundï¼Œæ¯”å¦‚ Fn(u32) -&gt; u32ã€‚ 
    // callbacks ç”¨æ¥å­˜ä¸‹ä¸€ä¸ªè¿è¡Œçš„ç¨‹åºå—ï¼ˆè¿™é‡Œç”¨é—­åŒ…æ¥è¡¨ç¤ºï¼‰ã€‚
    callbacks: RefCell&lt;HashMap&lt;usize, Box&lt;dyn FnOnce() -&gt; ()&gt;&gt;&gt;,
    // å‚¨å­˜ä¸‹ä¸€ä¸ªé—­åŒ…çš„id
    next_id: RefCell&lt;usize&gt;,
    // æ¯ä¸€ä¸ªç­‰å¾…å­çº¿ç¨‹æ‹¥æœ‰ä¸€ä¸ªï¼Œåœ¨å»¶æ—¶ç»“æŸåï¼Œå‘é€éœ€è¦è¿è¡Œçš„id
    evt_sender: Sender&lt;usize&gt;,
    // æ¥å—ä¸‹ä¸€ä¸ªè¯¥è¿è¡Œçš„é—­åŒ…çš„id
    evt_reciever: Receiver&lt;usize&gt;,
}

// cb æ˜¯ä¼ é€’çš„æ˜¯ä¸€ä¸ªé—­åŒ…,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. 
// Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.
// ä¼ é€’é—­åŒ…æ—¶å€™ç”¨impl Traitã€‚è¡¨ç¤ºä¸€ä¸ªã€ç±»å‹ã€‘ï¼Œè¿™ä¸ªç±»å‹implements äº†è¿™ä¸ªtrait
// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html
fn set_timeout(ms: u64, cb: impl FnOnce() + 'static) {
    // with æ–¹æ³•æ˜¯ åœ¨ std::thread::local::LocalKey ä¸­æœ‰çš„ï¼Œä¹Ÿå°±æ˜¯ RT æœ‰çš„ ã€‚
    // è·å–å¯¹è¿™ä¸ªTLSé”®ä¸­çš„å€¼çš„å¼•ç”¨ã€‚å¦‚æœè¿™ä¸ªçº¿ç¨‹è¿˜æ²¡æœ‰å¼•ç”¨è¿™ä¸ªé”®ï¼Œè¿™å°†å»¶è¿Ÿåˆå§‹åŒ–è¿™ä¸ªå€¼ã€‚
    // ç›¸å½“äºç”¨.with()å°±æ˜¯åœ¨ä½¿ç”¨è¯¥å˜é‡çš„å‡½æ•°ã€‚
    RT.with(|rt| {
        let id = *rt.next_id.borrow();
        // next_idé€’å¢
        *rt.next_id.borrow_mut() += 1;
        // callbackså­˜ (id: usize, Box&lt;dyn FnOnce() -&gt; ()&gt;)
        // ä¸ºä»€ä¹ˆéœ€è¦ Box::new(cb) è¿™æ ·å­çš„å‘€, å› ä¸ºè¾“å…¥çš„ç±»å‹æœªçŸ¥
        // cb åœ¨è¾“å…¥å‚æ•°ä¸­ç”¨çš„impl FnOnce() + 'static æ¥é™å®šã€‚
        rt.callbacks.borrow_mut().insert(id, Box::new(cb));
        // The sending-half of Rust's asynchronous channel type. 
        // This half can only be owned by one thread, but it can be cloned to send to other threads.
        // ä¸€ä¸ªsenderåªèƒ½å¤Ÿç”¨åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œé¢ï¼Œä½†æ˜¯å¯ä»¥å…‹éš†åˆ°å…¶ä»–çº¿ç¨‹ä¸­ï¼Œæ­¤æ—¶receiverè¿˜æ˜¯åªæœ‰ä¸€ä¸ª
        let evt_sender = rt.evt_sender.clone();
        // thread::spawnä¼šç›´æ¥æ–°å¼€ä¸€ä¸ªå­çº¿ç¨‹è¿è¡Œï¼Œä¸ä¼šé€ æˆä¸»çº¿ç¨‹é˜»å¡ã€‚åŠŸèƒ½æ˜¯ä¼‘çœ åå†æŠŠidè¾“å‡ºå‡ºå»
        thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(ms));
            // åœ¨å»¶æ—¶ç»“æŸåï¼Œå‘é€å½“å‰å»¶æ—¶ç»“æŸçš„ä»»åŠ¡id
            evt_sender.send(id).unwrap();
        });
    });
}


impl Runtime {
    fn new() -&gt; Self {
        // è¿™æ˜¯ä¸€ä¸ªasynchronous channelï¼Œ æ¯ä¸ªçº¿ç¨‹é‡Œé¢éƒ½æœ‰ä¸€ä¸ªsenderå’Œreceiver
        let (evt_sender, evt_reciever) = channel();
        Runtime {
            callbacks: RefCell::new(HashMap::new()),
            next_id: RefCell::new(1),
            evt_sender,
            evt_reciever,
        }
    }

    // è¿™å„¿æ˜¯åœ¨è¿è¡Œä¸€ä¸ªå‡½æ•°.
    fn run(&amp;self, program: fn()) {
        // ç›´æ¥è¿è¡Œï¼Œ 
        program();
        // 0ms è¿è¡Œåˆ°è¿™å„¿
        // è¿è¡Œç»“æŸåï¼Œå¼€å§‹é€ä¸ªè®¿é—®Runtime é‡Œé¢çš„ä¼‘çœ å­çº¿ç¨‹è¿”å›çš„ å¯¹åº”idçš„å€¼ã€‚
        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.
        // è¿™æ˜¯ä¸€ä¸ªé˜»å¡çš„æ–¹æ³•ï¼Œåªæœ‰å½“senderéƒ½è¢«dropçš„æ—¶å€™ï¼Œè¯¥è¿­ä»£å™¨çš„.next() æ‰ä¼šå˜æˆNone
        for evt_id in &amp;self.evt_reciever {
            // è¿™å„¿ç›´æ¥ä»HashMapé‡Œremoveå‡ºå¯¹åº”ç¼–å·çš„é—­åŒ…ã€‚
            let cb = self.callbacks.borrow_mut().remove(&amp;evt_id).unwrap();
            cb();
            // æ˜¯ä¸æ˜¯ä¹Ÿä¸éœ€è¦è¿™å¥è¯ï¼Ÿ
            // ã€ä¸è¡Œï¼ã€‘: å› ä¸ºåœ¨Runtimeé‡Œé¢ä¸€ä¸ªsenderï¼Œä¸ä¼šè¢«dropæ‰ï¼Œå°±ä¼šé™·å…¥æ— é™ç­‰å¾…äº†
            if self.callbacks.borrow().is_empty() {
                break;
            }
        }
    }
}

</code></pre>
<h1 id="æ€»ç»“">æ€»ç»“</h1>
<ul>
<li>å¦‚æœç”¨åŸºäºå›è°ƒçš„æ–¹æ³•æ¥è¯´Rustå¼‚æ­¥ç¼–ç¨‹ä¸­çš„å”±æ­Œè·³èˆä¾‹å­ï¼Œ ä¹Ÿå°±æ˜¯ï¼Œâ€œè®¡æ—¶å™¨â€ä»£è¡¨çš„â€œç­‰å¾…èµ„æºâ€ï¼Œç­‰ä»·äº â€œå”±æ­Œâ€å‰ç­‰å¾…&quot;å­¦æ­Œ&quot;ã€‚æ‰€ä»¥ï¼Œåœ¨å›è°ƒé€»è¾‘ä¸­ <code>sing_song()</code>ä½œä¸ºé—­åŒ…ï¼Œ <code>learn_song()</code> ä½œä¸ºå­çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹è¿è¡Œ<code>dance()</code> ã€‚å­çº¿ç¨‹ç»“æŸåå†è¿è¡Œè¿™ä¸ªé—­åŒ…ã€‚è¿è¡Œé¡ºåºæ˜¯ <code>learn_song()</code> ï¼ˆå­çº¿ç¨‹ï¼‰å’Œ <code>dance()</code>  ï¼ˆä¸»çº¿ç¨‹ï¼‰åŒæ—¶è¿è¡Œï¼Œåœ¨ä¸¤ä¸ªä»»åŠ¡å‡å®Œæˆåï¼Œ å†å›è°ƒ<code>sing_song()</code>è¿™ä¸ªé—­åŒ…ã€‚</li>
<li><strong>å­çº¿ç¨‹</strong>å¯¹åº” <strong>â€œç­‰å¾…èµ„æºâ€</strong> ï¼› <strong>é—­åŒ…</strong>å¯¹åº”â€œ<strong>æ¥æ”¶åˆ°ç­‰å¾…èµ„æºåçš„æ“ä½œâ€</strong>ã€‚</li>
</ul>
<pre><code class="language-rust">async fn learn_and_sing() {
    // åœ¨å”±æ­Œä¹‹å‰ç­‰å¾…å­¦æ­Œå®Œæˆ
    // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ `.await` è€Œä¸æ˜¯ `block_on` æ¥é˜²æ­¢é˜»å¡çº¿ç¨‹ï¼Œè¿™æ ·å°±å¯ä»¥åŒæ—¶æ‰§è¡Œ `dance` äº†ã€‚
    let song = learn_song().await;
    sing_song(song).await;
}
 async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
     // `join!` ç±»ä¼¼äº `.await` ï¼Œä½†æ˜¯å¯ä»¥ç­‰å¾…å¤šä¸ª future å¹¶å‘å®Œæˆ
     // å¦‚æœå­¦æ­Œçš„æ—¶å€™æœ‰äº†çŸ­æš‚çš„é˜»å¡ï¼Œè·³èˆå°†ä¼šæ¥ç®¡å½“å‰çš„çº¿ç¨‹ï¼Œå¦‚æœè·³èˆå˜æˆäº†é˜»å¡
     // å­¦æ­Œå°†ä¼šè¿”å›æ¥æ¥ç®¡çº¿ç¨‹ã€‚å¦‚æœä¸¤ä¸ªfutureséƒ½æ˜¯é˜»å¡çš„ï¼Œ
     // è¿™ä¸ªâ€˜async_main'å‡½æ•°å°±ä¼šå˜æˆé˜»å¡çŠ¶æ€ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªæ‰§è¡Œå™¨
    futures::join!(f1, f2)
}
 fn main() {
    block_on(async_main());
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust const æ³›å‹ (Const Generics)çš„ä½¿ç”¨æ–¹æ³•ï¼šè§£æconst_unit_poc]]></title>
        <id>https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/</id>
        <link href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/">
        </link>
        <updated>2020-11-23T12:15:59.000Z</updated>
        <summary type="html"><![CDATA[<p>å¯¹äºconst æ³›å‹ï¼Œç¬”è€…ä¹Ÿäº†è§£ç”šå°‘ã€‚å€Ÿå†™è¯¥æ–‡ç« çš„æœºä¼šï¼Œå­¦ä¹ ä¸€ä¸‹Rustçš„const æ³›å‹(Const Generics)</p>
]]></summary>
        <content type="html"><![CDATA[<p>å¯¹äºconst æ³›å‹ï¼Œç¬”è€…ä¹Ÿäº†è§£ç”šå°‘ã€‚å€Ÿå†™è¯¥æ–‡ç« çš„æœºä¼šï¼Œå­¦ä¹ ä¸€ä¸‹Rustçš„const æ³›å‹(Const Generics)</p>
<!-- more -->
<h2 id="const_unit_poc-åˆ©ç”¨const-genericså®ç°çš„ç‰©ç†å•ä½åº“"><code>const_unit_poc</code> ï¼šåˆ©ç”¨const genericså®ç°çš„ç‰©ç†å•ä½åº“</h2>
<p><code>const_unit_poc</code>  æ˜¯å‡ å¤©å‰æ¨å‡ºçš„ï¼Œç‡å…ˆä½¿ç”¨const æ³›å‹çš„åº“ã€‚è¯¥åº“çš„ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked)]
use const_unit_poc::values::{m, kg, s, N};

let distance = 1.0 * m;
let mass = 18.0 * kg;
let force = distance * mass / (1.8 * s * 2.0 * s);
assert_eq!(force, 5.0 * N);

let mut mutable_distance = 3.2 * m;
mutable_distance -= 0.2 * m;
mutable_distance += 2.0 * m;

assert_eq!(mutable_distance, 5.0 * m);
</code></pre>
<p>ä»£ç åŠå…¶ç®€ä¾¿ï¼æ˜“æ‡‚ï¼éå¸¸ç¥å¥‡ï¼æ‰€ä»¥å°±æ ¹æ®è¯¥åº“çš„æºä»£ç çœ‹çœ‹const æ³›å‹è¯¥å¦‚ä½•ä½¿ç”¨ã€‚</p>
<h2 id="const_unit_poc-æºç åˆ†æ"><code>const_unit_poc</code> æºç åˆ†æ</h2>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>ï¼š</p>
<pre><code class="language-rust">#![feature(const_generics, const_evaluatable_checked, doc_cfg)]
#![allow(incomplete_features)]
#![cfg_attr(feature = &quot;non_ascii&quot;, feature(non_ascii_idents))]

use std::ops;

pub mod units;
pub mod values;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_snake_case)]
pub struct SiUnit {
    m: i8,
    kg: i8,
    s: i8,
    A: i8,
    K: i8,
    mol: i8,
    cd: i8,
}

// åé¢è¿˜æœ‰å†…å®¹
</code></pre>
<p>è¿™é‡Œå¼•å…¥äº†<code>units</code>, <code>values</code>ä¸¤ä¸ªmodï¼Œå¹¶ä¸”å£°æ˜äº†<code>SiUnit</code> è¿™ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢çš„æˆå‘˜æ˜¯SIçš„7ä¸ªæ ‡å‡†å•ä½ï¼Œ ç±»å‹ä¸ºi8ã€‚</p>
<p>çœ‹åˆ°è¿™å„¿ï¼Œç¬”è€…æ¨æµ‹åº”è¯¥æ˜¯ä½¿ç”¨ <code>SiUnit</code> è¿™ä¸ªç»“æ„ä½“æ¥å®ä¾‹åŒ–å„ç§å¸¸ç”¨çš„å•ä½ï¼ˆå¦‚<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>ï¼‰ï¼Œå…¶ä¸­æˆå‘˜çš„å€¼è¡¨ç¤ºè¯¥å•ä½è¡¨ç¤ºæˆåŸºæœ¬å•ä½åçš„æŒ‡æ•°çš„å€¼ï¼ˆå¦‚<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>m</mi><mo>âˆ—</mo><msup><mi>s</mi><mrow><mo>âˆ’</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N=m*s^{-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ—</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">âˆ’</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>ï¼Œ åˆ™<code>N.m == 1; N.s == -2</code>ï¼‰ã€‚</p>
<p>å†çœ‹ä¸€ä¸‹å¼•å…¥çš„æ¨¡å—<code>units</code>çš„å†…å®¹</p>
<h3 id="unitsçš„å®ç°">unitsçš„å®ç°</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs"><code>./src/units.rs</code></a>ï¼š</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use super::SiUnit;
const NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };
/// meter
pub const m: SiUnit = SiUnit { m: 1, ..NONE };
/// ä¸­é—´å†…å®¹çœç•¥
/// lux
pub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };
/// square meter
pub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };
/// cubic meter
pub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };
</code></pre>
<p>çš„ç¡®å’ŒçŒœæƒ³ä¸€è‡´ï¼æ³¨æ„ç»“æ„ä½“å®ä¾‹åŒ–æ—¶å€™è¿™å„¿ä½¿ç”¨äº†<code>..NONE</code>ï¼Œè¿™æ˜¯ç”¨å·²ç»åˆ›å»ºçš„å®ä¾‹Noneä¸Š<strong>æ›´æ–°éƒ¨åˆ†å‚æ•°</strong>ï¼Œåˆ›å»ºæ–°çš„å®ä¾‹ï¼Œè§<a href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•ä»å…¶ä»–å®ä¾‹åˆ›å»ºå®ä¾‹</a>ã€‚è¿™å„¿ä½¿ç”¨äº†constä½¿å¾—å„ä¸ªå•ä½å…¨å±€å¯è§ä¸”ä¸å¯å˜ã€‚</p>
<p>ç°åœ¨å·²ç»æœ‰äº†å•ä½ï¼Œä½†æ˜¯æˆ‘ä»¬æ³¨æ„åˆ°ä»£ç ä¸­<code>assert_eq!(mutable_distance, 5.0 * m);</code>ä¸ä»…ä»…è¦æ£€æµ‹å•ä½çš„å€¼ï¼Œè¿˜è¦æ£€æµ‹ç³»æ•°çš„å€¼ï¼Œç»“æ„ä½“ä¸æ•°å­—ç›¸ä¹˜ååˆè¯¥å¦‚ä½•è¡¨ç¤ºå‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜åº”è¯¥èƒ½å¤Ÿä»å¦ä¸€ä¸ªæ¨¡å—å¾—åˆ°ç­”æ¡ˆå§ã€‚</p>
<h3 id="å¯¹å•ä½ç³»æ•°çš„åŒ…è£…">å¯¹å•ä½ç³»æ•°çš„åŒ…è£…</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs"><code>./src/values.rs</code></a>ï¼š</p>
<pre><code class="language-rust">#![allow(non_upper_case_globals)]
use crate::{units, Quantity};
// base
/// 1 meter
pub const m: Quantity&lt;{ units::m }&gt; = Quantity { raw_value: 1.0 };
/// 1 kilogram
pub const kg: Quantity&lt;{ units::kg }&gt; = Quantity { raw_value: 1.0 };
/// 1 second
pub const s: Quantity&lt;{ units::s }&gt; = Quantity { raw_value: 1.0 };
/// åé¢è¿˜æœ‰
</code></pre>
<p><strong>æ³¨æ„</strong>ï¼š<code>use crate::{units, Quantity}</code>, ä»£è¡¨çš„æ˜¯å¯¼å…¥çš„å½“å‰<code>crate</code>ä¸­çš„<code>units</code>å’Œ<code>Quantity</code>ã€‚<br>
<strong>const æ³›å‹</strong>: ä»è¿™å„¿çš„å¯ä»¥å¤§æ¦‚å¯ä»¥çœ‹å‡ºï¼Œ<code>Quantity</code>çš„æ³›å‹å‚æ•°æ˜¯ä¸€ä¸ªconstå¸¸é‡ï¼ŒåŒ…è£…æ¯ä¸€ä¸ª<code>units.rs</code>ä¸­çš„constå¸¸é‡å€¼ã€‚è¿™å°±æ˜¯const genericså§! åé¢çš„å®ä¾‹åŒ–æ ¹æ®ç±»å‹æ¨å¯¼åº”è¯¥åˆå¯ä»¥å†™åšï¼š<code>Quantity&lt;{ units::m }&gt; { raw_value: 1.0 }</code>ã€‚ æ‰€ä»¥æ˜¯ç”¨<code>raw_value</code>æ¥è¡¨ç¤ºæ¯ä¸€ä¸ªå•ä½çš„ç³»æ•°ã€‚</p>
<p>æ‰€ä»¥å†æ¥çœ‹çœ‹<code>Quantity</code>çš„å®šä¹‰å§ã€‚</p>
<p>###ç»“æ„ä½“ <code>Quantity</code>çš„å®šä¹‰</p>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>ï¼š</p>
<pre><code class="language-rust">#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Quantity&lt;const U: SiUnit&gt; {
    pub raw_value: f64,
}
</code></pre>
<p>ç®€å•å¹²è„†çš„ä½¿ç”¨const ç±»å‹ä½œä¸ºæ³›å‹å‚æ•°ã€‚</p>
<h3 id="åŠ å‡è¿ç®—">åŠ å‡è¿ç®—</h3>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>ï¼š</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Add for Quantity&lt;U&gt; {
    type Output = Self;

    fn add(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value + rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::AddAssign for Quantity&lt;U&gt; {
    fn add_assign(&amp;mut self, rhs: Self) {
        self.raw_value += rhs.raw_value;
    }
}

impl&lt;const U: SiUnit&gt; ops::Sub for Quantity&lt;U&gt; {
    type Output = Self;

    fn sub(self, rhs: Self) -&gt; Self {
        Self { raw_value: self.raw_value - rhs.raw_value }
    }
}

impl&lt;const U: SiUnit&gt; ops::SubAssign for Quantity&lt;U&gt; {
    fn sub_assign(&amp;mut self, rhs: Self) {
        self.raw_value -= rhs.raw_value;
    }
}
</code></pre>
<p>ç”±äºåŠ å‡è¿ç®—å¹¶ä¸ä¼šå˜å•ä½ï¼Œæ‰€ä»¥å°±æ˜¯å¯¹ç³»æ•°çš„åŠ å‡ï¼Œéå¸¸ç›´æ¥ã€‚</p>
<h3 id="ä¹˜é™¤è¿ç®—">ä¹˜é™¤è¿ç®—</h3>
<ul>
<li>ä¸€ä¸ªæ•°å­—ä¸ä¸€ä¸ªQuantityç›¸ä¹˜ï¼Œå•ä½ä¸å˜ï¼š</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>ï¼š</p>
<pre><code class="language-rust">impl&lt;const U: SiUnit&gt; ops::Mul&lt;f64&gt; for Quantity&lt;U&gt; {
    type Output = Quantity&lt;U&gt;;

    fn mul(self, rhs: f64) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs }
    }
}
</code></pre>
<ul>
<li>ä¸¤ä¸ªå¸¦å•ä½çš„é‡ç›¸ä¹˜ï¼Œå•ä½å‘ç”Ÿå˜åŒ–ï¼Œä¹Ÿå°±æ˜¯<code>Quantity&lt;U&gt;</code>çš„æ³›å‹å‚æ•°å‘ç”Ÿäº†å˜åŒ–ï¼Œæ­¤æ—¶éœ€è¦é‡æ–°å®ä¾‹åŒ–ä¸€ä¸ª<code>Quantity&lt;U&gt;</code>ç»“æ„ä½“ï¼š</li>
</ul>
<p><a href="https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs"><code>./src/lib.rs</code></a>ï¼š</p>
<pre><code class="language-rust">// Quantityç›¸ä¹˜è½¬æ¢ä¸ºunitç›¸ä¹˜ï¼ŒUL.unit_mul(UR)
impl&lt;const UL: SiUnit, const UR: SiUnit&gt; ops::Mul&lt;Quantity&lt;UR&gt;&gt; for Quantity&lt;UL&gt;
where
    Quantity&lt;{ UL.unit_mul(UR) }&gt;: ,
{
    type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;

    fn mul(self, rhs: Quantity&lt;UR&gt;) -&gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs.raw_value }
    }
}
// unitç›¸ä¹˜
impl SiUnit {
    const fn unit_mul(self, rhs: Self) -&gt; Self {
        Self {
            m: self.m + rhs.m,
            kg: self.kg + rhs.kg,
            s: self.s + rhs.s,
            A: self.A + rhs.A,
            K: self.K + rhs.K,
            mol: self.mol + rhs.mol,
            cd: self.cd + rhs.cd,
        }
    }
}
</code></pre>
<ul>
<li>è¿™å„¿å¯¹æ³›å‹çš„çº¦æŸå¾ˆç¥å¥‡ï¼Œç«Ÿç„¶æ˜¯è¿™æ ·å†™<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;:</code> ï¼Œå¦‚æœå»æ‰è¿™ä¸ªwhereï¼Œåˆ™ä¼šæŠ¥é”™unconstrained generic constantã€‚è™½ç„¶ç°åœ¨è¿˜ä¸æ‡‚æ˜¯ä»€ä¹ˆæ„æ€....</li>
</ul>
<pre><code>error: unconstrained generic constant
   --&gt; src\lib.rs:156:5
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
    |
help: consider adding a `where` bound for this expression  
   --&gt; src\lib.rs:156:28
    |
156 |     type Output = Quantity&lt;{ UL.unit_mul(UR) }&gt;;     
    |                            ^^^^^^^^^^^^^^^^^^^     
</code></pre>
<ul>
<li>å¦å¤–ä¸€ç‚¹ï¼Œæ³›å‹ä¸­çš„constæ˜¯è°ƒç”¨ä¸€ä¸ªconst fnå¾—åˆ°çš„æ—¶å€™ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦æ‰“å¤§æ‹¬å·ï¼Œå¦‚ï¼š<code>Quantity&lt;{ UL.unit_mul(UR) }&gt;</code> ï¼Œå¦åˆ™ä¹Ÿä¼šå‡ºé”™ã€‚è¿™åœ¨æœ€è¿‘çš„<a href="https://github.com/rust-lang/rust/pull/79135">Stabilization report</a>é‡Œé¢ä¹Ÿæœ‰æåˆ°ã€‚</li>
</ul>
<blockquote>
<p><strong>Const arguments</strong></p>
<p>Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, <strong>most expressions must be contained within a block</strong>, with two exceptions:</p>
<ol>
<li>literals and single-segment path expressions</li>
<li>array lengths</li>
</ol>
<p>This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.</p>
<p>In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn foo&lt;const N: usize&gt;() -&gt; Foo&lt;N&gt; { todo!() } // ERR
</code></pre>
<p>To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.</p>
<pre><code class="language-rust">type N = u32;
struct Foo&lt;const N: usize&gt;;
fn bar&lt;const N: usize&gt;() -&gt; Foo&lt;{ N }&gt; { todo!() } // ok
</code></pre>
</blockquote>
<p>ç®€å•æ¥è¯´ï¼Œconst æ³›å‹ä¸€èˆ¬éƒ½éœ€è¦æ‰“å¤§æ‹¬å·(ä¸¤ç§æƒ…å†µé™¤å¤–)ï¼Œæ‰“å¤§æ‹¬å·æ˜¯ä¸ºäº†é˜²æ­¢æ­§ä¹‰ã€‚</p>
<h2 id="æ€»ç»“">æ€»ç»“</h2>
<p>è¿™ç¯‡æ–‡ç« ä¸»è¦æ˜¯äº†è§£äº†const æ³›å‹åœ¨åšå•¥ï¼Œä»¥åŠå¦‚ä½•åšçš„ã€‚</p>
<p>é€šè¿‡è¿™ä¸ªç®€å•çš„ä¾‹å­ï¼Œæˆ‘æ„Ÿè§‰const æ³›å‹æ˜¯ç”¨åœ¨å½“æ³›å‹éœ€è¦æœ‰å–å€¼çš„æ—¶å€™ï¼ˆæ¯”å¦‚è¿™é‡Œçš„unitå°±éœ€è¦å–å€¼ï¼Œè€Œä¸èƒ½æ¯ä¸€ä¸ªå•ä½ä¸€ä¸ªç±»å‹...ï¼‰ã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Rust å¼‚æ­¥å¹¶å‘ï¼ˆä¸€ï¼‰]]></title>
        <id>https://Busy-Bob.github.io/post/rust-yi-bu/</id>
        <link href="https://Busy-Bob.github.io/post/rust-yi-bu/">
        </link>
        <updated>2020-11-22T15:07:53.000Z</updated>
        <summary type="html"><![CDATA[<p>å‰ä¸€æ®µæ—¶é—´çœ‹äº†ä¸€äº›å…³äºRustçš„å¼‚æ­¥ç¼–ç¨‹ç›¸å…³çš„çŸ¥è¯†ï¼Œå—ç›ŠåŒªæµ…ï¼Œæ•…åšæ­¤è®°å½•ã€‚<br>
Rustå¼‚æ­¥ç¼–ç¨‹æ˜¯Rustè¯­è¨€ä¸­ååˆ†é‡è¦ç‰¹æ€§ã€‚ç°åœ¨Rustä¸­çš„å¼‚æ­¥ç¼–ç¨‹é‡‡ç”¨<code>async/.await</code>è§£å†³æ–¹æ¡ˆã€‚</p>
]]></summary>
        <content type="html"><![CDATA[<p>å‰ä¸€æ®µæ—¶é—´çœ‹äº†ä¸€äº›å…³äºRustçš„å¼‚æ­¥ç¼–ç¨‹ç›¸å…³çš„çŸ¥è¯†ï¼Œå—ç›ŠåŒªæµ…ï¼Œæ•…åšæ­¤è®°å½•ã€‚<br>
Rustå¼‚æ­¥ç¼–ç¨‹æ˜¯Rustè¯­è¨€ä¸­ååˆ†é‡è¦ç‰¹æ€§ã€‚ç°åœ¨Rustä¸­çš„å¼‚æ­¥ç¼–ç¨‹é‡‡ç”¨<code>async/.await</code>è§£å†³æ–¹æ¡ˆã€‚</p>
<!-- more -->
<h1 id="1-ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ç¼–ç¨‹">1. ä¸ºä»€ä¹ˆéœ€è¦å¼‚æ­¥ç¼–ç¨‹ï¼Ÿ</h1>
<p>åˆšå¼€å§‹ä¸€ç›´æœ‰ä¸€ä¸ªç–‘é—®ï¼š<strong>æ—¢ç„¶å·²ç»æœ‰äº†å¤šçº¿ç¨‹æŠ€æœ¯ï¼Œå¤šç”¨æˆ·è®¿é—®ç›´æ¥ä½¿ç”¨å¤šçº¿ç¨‹ï¼Œä¸ºä»€ä¹ˆè¿˜éœ€è¦å¼‚æ­¥å‘¢ï¼Ÿ</strong> åæ¥ç»ˆäºæ˜ç™½ï¼Œå¼‚æ­¥æ˜¯ç”¨åœ¨å¤šç”¨æˆ·<strong>åŒæ—¶å¤„ç†åŒä¸€èµ„æº</strong>æ—¶å€™å‘æŒ¥ä½œç”¨çš„ã€‚</p>
<pre><code>ç°åœ¨ç”¨100ä¸ªç”¨æˆ·åŒæ—¶ä¿®æ”¹ä¸€ä¸ªæ–‡ä»¶æ¥ä¸¾ä¾‹ï¼š
</code></pre>
<ul>
<li>
<p><strong>åŒæ­¥</strong>(ä¸€èˆ¬ä¹Ÿæ˜¯<strong>é˜»å¡</strong>)ï¼š ç¨‹åºéœ€è¦å®ç°<strong>è¯»å†™é”(<code>std::sync::RwLock</code>)<strong>æˆ–</strong>äº’æ–¥é”(<code>std::sync::Mutex</code>)</strong>ï¼Œç¨‹åºä¼šåŒæ—¶äº§ç”Ÿ100ä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‹¥æœ‰å†™é”ï¼Œå…¶ä»–çš„99ä¸ªçº¿ç¨‹å‡</p>
<ul>
<li>å¤„äº<strong>ç­‰å¾…çŠ¶æ€</strong>ï¼Œçº¿ç¨‹ä¸ä¼šsleepï¼Œä¼šå¾ªç¯è·å–é”(è‡ªæ—‹é”Spinlock)ã€‚
<ul>
<li>é˜»å¡çš„çº¿ç¨‹è¿˜æ¥å‚ä¸æ“ä½œç³»ç»Ÿçš„æŠ¢å å¼è°ƒåº¦ï¼Œå¾ˆä¸ç§‘å­¦ï¼ä¸ºä»€ä¹ˆä¸å…ˆæ’å¥½é˜Ÿï¼Œç”¨ä¸€ä¸ªçº¿ç¨‹å‘¢ï¼ˆè¿™ä¹Ÿæ˜¯åç¨‹å¹²çš„äº‹ï¼‰</li>
</ul>
</li>
<li>æˆ–è€…æœ‰èµ·å§‹çš„<strong>åŠ é”å¼€é”€</strong>(é€šå¸¸æ˜¯å¯¹äº’æ–¥é”ï¼šâ‘ çº¿ç¨‹ä¼šä»sleepï¼ˆåŠ é”ï¼‰â€”â€”&gt;runningï¼ˆè§£é”ï¼‰ï¼Œè¿‡ç¨‹ä¸­æœ‰ä¸Šä¸‹æ–‡çš„åˆ‡æ¢ï¼Œcpuçš„æŠ¢å ï¼Œä¿¡å·çš„å‘é€ç­‰å¼€é”€ï¼›â‘¡äº’æ–¥é”åœ¨sleepæ—¶ä¼šé™·å…¥åˆ°å†…æ ¸æ€ï¼Œéœ€è¦æ˜‚è´µçš„ç³»ç»Ÿè°ƒç”¨ï¼›çº¿ç¨‹å‘æ“ä½œç³»ç»Ÿè¯·æ±‚è¢«æŒ‚èµ·æ˜¯é€šè¿‡ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨linuxä¸Šçš„å®ç°å°±æ˜¯futex)ã€‚</li>
</ul>
</li>
<li>
<p><strong>å¼‚æ­¥</strong>(ä¸€èˆ¬ä¹Ÿæ˜¯<strong>éé˜»å¡</strong>)ï¼š å°†100ä¸ªçº¿ç¨‹æ ¹æ®ä¸€å®šçš„å…ˆåæ¬¡åº<strong>åˆå¹¶æˆä¸€ä¸ªçº¿ç¨‹</strong>(ä¹Ÿå¯èƒ½æ˜¯å¤šä¸ªçº¿ç¨‹ï¼Ÿ)ï¼Œ å°±å¯ä»¥é¿å…é”çš„äº§ç”Ÿï¼Œä»è€Œå‡å°‘æ“ä½œç³»ç»Ÿå¯¹çº¿ç¨‹è°ƒç”¨çš„å¼€é”€ã€‚ä½†æ˜¯ï¼Œå½“çº¿ç¨‹ä¹‹é—´å¯¹èµ„æºçš„ä¾èµ–å…³ç³»æ¯”è¾ƒå¤æ‚çš„æ—¶å€™ï¼Œç¨‹åºçš„ç¼–å†™å°±ä¼š<strong>ååˆ†å¤æ‚</strong>ã€‚</p>
<ul>
<li><strong>åç¨‹</strong>(coroutine)ï¼š å®ç°å¼‚æ­¥ç¼–ç¨‹çš„ä¸€ç§æ–¹å¼ï¼Œæ˜¯åœ¨çº¿ç¨‹ä¹‹ä¸‹çš„ä¸€ä¸ªå•ä½ã€‚åç¨‹æ˜¯è¯­è¨€å±‚é¢æ§åˆ¶æ•°æ®æµçš„ä¸€ç§â€œè°ƒåº¦â€ï¼ˆå¤„ç†å…¬å…±èµ„æºçš„æ—¶å€™ï¼Œç›¸å½“äº<strong>ç”¨æˆ·æ€çš„é”</strong>ï¼‰ï¼Œ çº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿå±‚é¢çš„â€œè°ƒåº¦â€ï¼ˆå¤„ç†å…¬å…±èµ„æºï¼Œä½¿ç”¨<strong>æ“ä½œç³»ç»Ÿæˆ–è€…ç¡¬ä»¶çš„é”(å³Mutexæˆ–è€…Spinlock)</strong>ï¼‰ã€‚åç¨‹çš„è°ƒåº¦æ˜¯ç¼–è¯‘å™¨é€šè¿‡ç»„ç»‡è¿ç®—é¡ºåºå®ç°çš„ï¼ˆé€šè¿‡ç”Ÿæˆå™¨ï¼ˆç­‰åŒäºä¸€ä¸ªçŠ¶æ€æœºï¼‰å®ç°ï¼‰ï¼Œçº¿ç¨‹æ˜¯é€šè¿‡æ“ä½œç³»ç»Ÿæ¥è¿›è¡ŒæŠ¢å å¼è°ƒåº¦çš„ã€‚</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">åç¨‹wiki</a>ï¼šåç¨‹éå¸¸ç±»ä¼¼äºçº¿ç¨‹ã€‚ä½†æ˜¯åç¨‹æ˜¯åä½œå¼å¤šä»»åŠ¡çš„ï¼Œè€Œçº¿ç¨‹å…¸å‹æ˜¯æŠ¢å å¼å¤šä»»åŠ¡çš„ã€‚è¿™æ„å‘³ç€åç¨‹æä¾›å¹¶å‘æ€§è€Œéå¹¶è¡Œæ€§ã€‚åç¨‹è¶…è¿‡çº¿ç¨‹çš„å¥½å¤„æ˜¯å®ƒä»¬å¯ä»¥ç”¨äºç¡¬æ€§å®æ—¶çš„è¯­å¢ƒï¼ˆåœ¨åç¨‹ä¹‹é—´çš„åˆ‡æ¢ä¸éœ€è¦æ¶‰åŠä»»ä½•ç³»ç»Ÿè°ƒç”¨æˆ–ä»»ä½•é˜»å¡è°ƒç”¨ï¼‰ï¼Œè¿™é‡Œä¸éœ€è¦ç”¨æ¥å®ˆå«å…³é”®åŒºå—çš„åŒæ­¥æ€§åŸè¯­ï¼ˆprimitiveï¼‰æ¯”å¦‚äº’æ–¥é”ã€ä¿¡å·é‡ç­‰ï¼Œå¹¶ä¸”ä¸éœ€è¦æ¥è‡ªæ“ä½œç³»ç»Ÿçš„æ”¯æŒã€‚</li>
<li><a href="https://www.zhihu.com/question/332113890/answer/1052024052">äº’æ–¥é”ï¼ˆmutexï¼‰çš„åº•å±‚åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ</a></li>
<li><a href="https://www.zhihu.com/question/50185085/answer/1342613525">å‡ºäºä»€ä¹ˆæ ·çš„åŸå› ï¼Œè¯ç”Ÿäº†ã€Œåç¨‹ã€è¿™ä¸€æ¦‚å¿µï¼Ÿ</a></li>
</ul>
</li>
</ul>
<p>æ‰€ä»¥ï¼Œå¼‚æ­¥ç¼–ç¨‹æ˜¯å¯ä»¥ç›´æ¥ç”¨å¤æ‚çš„ä»£ç ç»“æ„ç›´æ¥å†™å‡ºæ¥çš„ã€‚æ¯”å¦‚ä¸Šé¢çš„ä¾‹å­å°±æ˜¯åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œé¢å»ä¾æ¬¡è¯»å†™100æ¬¡ã€‚è€ŒRustçš„<code>async/.await</code>è§£å†³æ–¹æ¡ˆåšçš„å·¥ä½œæ˜¯ <strong>â€œå°†å¤æ‚çš„å¼‚æ­¥ä»£ç  ===&gt; åˆ©ç”¨è¯­æ³•ç³– ===&gt; è½¬åŒ–ä¸ºç±»ä¼¼äºåŒæ­¥çš„ä»£ç (æ›´å®¹æ˜“coding)â€</strong>  å³ <strong>â€œç”¨åŒæ­¥çš„è¯­ä¹‰è§£å†³å¼‚æ­¥é—®é¢˜â€</strong> ã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020.11.22 ä¼Šå§‹]]></title>
        <id>https://Busy-Bob.github.io/post/2020112-yi-shi/</id>
        <link href="https://Busy-Bob.github.io/post/2020112-yi-shi/">
        </link>
        <updated>2020-11-22T08:45:04.000Z</updated>
        <content type="html"><![CDATA[<p>ä»<strong>ä»Šå¤©</strong>å¼€å§‹è®°å½•å­¦ä¹ å’Œç”Ÿæ´»ã€‚</p>
<p>æˆ‘ä¹Ÿæ˜¯ä¸€ä¸ªæ‡’æƒ°çš„å°åšä¸»å•¦~ğŸ˜‹</p>
]]></content>
    </entry>
</feed>