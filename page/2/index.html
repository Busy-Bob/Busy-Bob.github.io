<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="勺海的个人博客">
<meta name="description" content="尽应尽之事，做让自己开心的事。">
<meta name="theme-color" content="#000">
<title>勺海的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1610033464827">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/zenburn.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>勺海的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">尽应尽之事，做让自己开心的事。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 文章
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">勺海</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">沉迷于知识本身</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">15</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">15</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://Busy-Bob.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/Busy-Bob">
              <i class="fa fa-github-alt" title="github"></i>
            </a>
          
        
        
      </div>
    </div>
  

  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box pisces">
          <section class="section bg-color posts-expand slide-down-in">
            
  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/">
      Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-11-23</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://Busy-Bob.github.io/tag/Op9tNmAIW/">
        <span>const</span>
      </a>、
      
      
      
      <a href="https://Busy-Bob.github.io/tag/BCk2FVrJcy/">
        <span>泛型</span>
      </a>、
      
      
      
      <a href="https://Busy-Bob.github.io/tag/PUCwH47Rx/">
        <span>rust</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>8分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1592<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <p>对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
        <footer class="post-footer">
          <div class="post-eof"></div>
        </footer>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Busy-Bob.github.io/post/rust-yi-bu/">
       Rust 异步并发（一）
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-11-22</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://Busy-Bob.github.io/tag/PUCwH47Rx/">
        <span>rust</span>
      </a>、
      
      
      
      <a href="https://Busy-Bob.github.io/tag/hDYBWTXHUV/">
        <span>异步编程</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>907<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <p>前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。<br>
Rust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用<code>async/.await</code>解决方案。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://Busy-Bob.github.io/post/rust-yi-bu/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
        <footer class="post-footer">
          <div class="post-eof"></div>
        </footer>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://Busy-Bob.github.io/post/2020112-yi-shi/">
      2020.11.22 伊始
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-11-22</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://Busy-Bob.github.io/tag/xMGkC-iLRF/">
        <span>随便写写</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>24<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          
        
        
        <div class="post-button text-center">
          <a class="btn" href="https://Busy-Bob.github.io/post/2020112-yi-shi/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
        <footer class="post-footer">
          <div class="post-eof"></div>
        </footer>
      
    </div>
  </article>
  
            
            
<div class="page bg-color">
  <ul class="pagination-ul">
    
      <li class="pagination-dir">
        <a href="https://Busy-Bob.github.io/">
          <i class="fa fa-angle-left"></i>
        </a>
      </li>
    
    
      
        <li class="pagination-li ">
            <a href="/page/../">
              1
            </a>
        </li>
      
        <li class="pagination-li pagination-active">
            <a href="/page/2">
              2
            </a>
        </li>
      
    
    
  </ul>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/zynq-zhong-cha-kan-yong-hls-sheng-cheng-de-ip-he-duan-kou-dui-ying-de-nei-cun-kong-jian/"" data-c="
          &lt;p&gt;找了一会儿才找到, 所以记录下来。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;用HLS生成的ip核，使用axi-lite协议，找不到pynq中top函数变量对应的内存空间地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HLS中，Synthesis Summary的最后一项可以看到HW info.&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1610012440636.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;HLS生成的verilog文件(XXXXX_control_s_axi.v)中，有接口地址信息的注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//------------------------Address Info-------------------
// 0x00 : reserved
// 0x04 : reserved
// 0x08 : reserved
// 0x0c : reserved
// 0x10 : Data signal of a
//        bit 31~0 - a[31:0] (Read/Write)
// 0x14 : reserved
// 0x18 : Data signal of b
//        bit 31~0 - b[31:0] (Read/Write)
// 0x1c : reserved
// 0x20 : Data signal of c
//        bit 31~0 - c[31:0] (Read)
// 0x24 : Control signal of c
//        bit 0  - c_ap_vld (Read/COR)
//        others - reserved
// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;pynq中，可通过&lt;code&gt;register_map&lt;/code&gt;直接查看地址，或者直接操作变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pynq import Overlay
overlay = Overlay(&#39;./design_1.bit&#39;)
add_ip = overlay.add_0

add_ip.register_map.a = 3
add_ip.register_map.b = 4
c = add_ip.register_map.c
c.address
&lt;/code&gt;&lt;/pre&gt;
">Zynq 中查看用HLS 生成的IP核端口对应的内存空间</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/vitis-hls-coding-styles/"" data-c="
          &lt;p&gt;参考Xilinx文档，&lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html&#34;&gt;Vitis HLS Coding Styles&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;不支持的cc部分&#34;&gt;不支持的C/C++部分&lt;/h1&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;系统调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;， &lt;code&gt;fprintf(stdout,)&lt;/code&gt;等不会影响算法执行的系统调用——忽略掉。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getc()&lt;/code&gt;, &lt;code&gt;time()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt; 等系统调用——不被接受。&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;__SYNTHESIS__&lt;/code&gt;宏来区分&lt;strong&gt;综合&lt;/strong&gt;与&lt;strong&gt;调试&lt;/strong&gt;过程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void hier_func4(din_t A, din_t B, dout_t *C, dout_t *D)
{
    dint_t apb, amb;

    sumsub_func(&amp;amp;A, &amp;amp;B, &amp;amp;apb, &amp;amp;amb);
#ifndef __SYNTHESIS__
    FILE *fp1; // The following code is ignored for synthesis
    char filename[255];
    sprintf(filename, Out_apb_ % 03d.dat, apb);
    fp1 = fopen(filename, w);
    fprintf(fp1, % d \n, apb);
    fclose(fp1);
#endif
    shift_func(&amp;amp;apb, &amp;amp;amb, C, D);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;动态内存&#34;&gt;动态内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;malloc()&lt;/code&gt;， &lt;code&gt;new&lt;/code&gt; 等动态分配内存的不行, 不能在堆上分配内存，必须在栈上。（因为该HLS技术是静态分析）&lt;/li&gt;
&lt;li&gt;一种改动方法是直接对栈上变量取指针：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;quot;malloc_removed.h&amp;quot;
#include &amp;lt;stdlib.h&amp;gt;
//#define NO_SYNTH

dout_t malloc_removed(din_t din[N], dsel_t width) {  

#ifdef NO_SYNTH
 long long *out_accum = malloc (sizeof(long long));
 int* array_local = malloc (64 * sizeof(int));
#else
 long long _out_accum;
 long long *out_accum = &amp;amp;_out_accum;
 int _array_local[64];
 int* array_local = &amp;amp;_array_local[0];
#endif
// 中间计算省略
 return *out_accum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;指针的一些限制&#34;&gt;指针的一些限制&lt;/h2&gt;
&lt;h3 id=&#34;通用指针类型转换&#34;&gt;通用指针类型转换&lt;/h3&gt;
&lt;p&gt;HLS 只支持C/C++原生类型的转换&lt;/p&gt;
&lt;h3 id=&#34;指针数组&#34;&gt;指针数组&lt;/h3&gt;
&lt;p&gt;如果每个指针指向一个标量或一个标量数组，则Vitis HLS支持指针数组的综合。但指针数组不能指向额外的指针（应该类似二维数组的行、列指针）&lt;/p&gt;
&lt;h3 id=&#34;函数指针&#34;&gt;函数指针&lt;/h3&gt;
&lt;p&gt;不支持&lt;/p&gt;
&lt;h2 id=&#34;递归函数&#34;&gt;递归函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不支持。不管最后递归次数是不是有限的。&lt;/li&gt;
&lt;li&gt;可以使用C++模板来构造&lt;strong&gt;可以用来综合的尾递归&lt;/strong&gt;，因为C++中支持非类型模板参数（Nontype Template Parameters），类似Rust中的const泛型，这儿的模板参数为&lt;code&gt;data_t&lt;/code&gt;类型的一个值 N。&lt;a href=&#34;https://github.com/Xilinx/HLS-Tiny-Tutorials/tree/master/algorithm_template_fir_filter&#34;&gt;例子如下&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Tail recursive call
template&amp;lt;data_t N&amp;gt; 
	struct fibon_s {
    template&amp;lt;typename T&amp;gt;
    static T fibon_f(T a, T b) {
		return fibon_s&amp;lt;N-1&amp;gt;::fibon_f(b, (a+b));
  }
};

// Termination condition
template&amp;lt;&amp;gt; struct fibon_s&amp;lt;1&amp;gt; {
  template&amp;lt;typename T&amp;gt;
  static T fibon_f(T a, T b) {
    return b;
  }
};

void cpp_template(data_t a, data_t b, data_t &amp;amp;dout){
  dout = fibon_s&amp;lt;FIB_N&amp;gt;::fibon_f(a,b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stl&#34;&gt;STL&lt;/h2&gt;
&lt;p&gt;有动态内存和递归，不能使用。&lt;/p&gt;
&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;
&lt;p&gt;顶层函数不能是静态的。&lt;/p&gt;
&lt;h2 id=&#34;内联函数&#34;&gt;内联函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;综合时候花费时间、内存较多，但效果更好。&lt;/li&gt;
&lt;li&gt;没有独立的RTL文件和报告了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码风格的影响&#34;&gt;代码风格的影响&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;影响函数参数和接口&lt;/li&gt;
&lt;li&gt;直接用函数接口的输入量来驱动变量时候，程序就不会使用某些优化手段。（如输入量是循环索引的上限）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;

ap_int&amp;lt;24&amp;gt; foo(int x, int y) {  
 int tmp;

 tmp = (x * y);
 return tmp
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码这会导致一个32-bit乘法器，输出再被截取。&lt;br&gt;
下面这个代码直接产生一个24-bit乘法器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;
typedef ap_int&amp;lt;12&amp;gt; din_t;
typedef ap_int&amp;lt;24&amp;gt; dout_t;

dout_t func_sized(din_t x, din_t y) {  
 int tmp;

 tmp = (x * y);
 return tmp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cc内置函数&#34;&gt;C/C++内置函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;只支持以下两个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__builtin_clz(unsigned int x)&lt;/code&gt;: Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__builtin_ctz(unsigned int x)&lt;/code&gt;: Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;循环&#34;&gt;循环&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;支持得很好。可以切流水线，展开、部分展开、合并和扁平化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要使用全局变量作为循环变量&lt;/strong&gt;，否则会阻碍代码优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环变量范围&#34;&gt;循环变量范围&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;循环变量的上限如果是变量，就难以在综合时候优化。&lt;/li&gt;
&lt;li&gt;循环变量的上限如果是变量，循环的latency无法确定。&lt;/li&gt;
&lt;li&gt;循环变量的上限如果是变量，设计的性能未知。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;
#define N 32

typedef ap_int&amp;lt;8&amp;gt; din_t;
typedef ap_int&amp;lt;13&amp;gt; dout_t;
typedef ap_uint&amp;lt;5&amp;gt; dsel_t;

dout_t code028(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0;x&amp;lt;width; x++) {
 out_accum += A[x];
 }

 return out_accum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了克服无法分析性能的缺点，一般是加上&lt;br&gt;
&lt;code&gt;#pragma HLS loop_tripcount min=&amp;lt;int&amp;gt; max=&amp;lt;int&amp;gt; avg=&amp;lt;int&amp;gt;&lt;/code&gt;&lt;br&gt;
或者是使用断言&lt;code&gt;assert&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void foo (num_samples, ...) {
  int i;
  ...
  loop_1: for(i=0;i&amp;lt; num_samples;i++) {
   #pragma HLS loop_tripcount min=12 max=16
   ...
    result = a + b;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：该编译选项只用于分析，不会用于综合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于具有可变边界的循环的解决方案是：在循环中有条件地执行，并且令循环迭代的次数为固定值。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;
#define N 32

typedef ap_int&amp;lt;8&amp;gt; din_t;
typedef ap_int&amp;lt;13&amp;gt; dout_t;
typedef ap_uint&amp;lt;5&amp;gt; dsel_t;

dout_t loop_max_bounds(din_t A[N], dsel_t width) {  

 dout_t out_accum=0;
 dsel_t x;

 LOOP_X:for (x=0; x&amp;lt;N; x++) {
 if (x&amp;lt;width) {
  out_accum += A[x];
 }
 }

 return out_accum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;将循环流水线化&#34;&gt;将循环流水线化&lt;/h2&gt;
&lt;p&gt;通常通过流水线最内层的循环来找到面积和性能之间的最佳平衡。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;loop_pipeline.h&amp;quot;

dout_t loop_pipeline(din_t A[N]) {  

 int i,j;
 static dout_t acc;

 LOOP_I:for(i=0; i &amp;lt; 20; i++){
 LOOP_J: for(j=0; j &amp;lt; 20; j++){
 acc += A[i] * j;
 }
 }

 return acc;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pipeline &lt;code&gt;LOOP_J&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只需调度一个乘法器操作和一个数组访问&lt;/li&gt;
&lt;li&gt;Latency is approximately 400 cycles (20x20) and requires less than 100 LUTs and registers (the I/O control and FSM are always present).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pipeline &lt;code&gt;LOOP_I&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部循环展开20次。&lt;/li&gt;
&lt;li&gt;需调度20个乘法器操作和20个数组访问&lt;/li&gt;
&lt;li&gt;Latency is approximately 20 cycles but requires a few hundred LUTs and registers. About 20 times the logic as first option, minus any logic optimizations that can be made.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pipeline &lt;code&gt;function loop_pipeline&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需调度400个乘法器操作和400个数组访问&lt;/li&gt;
&lt;li&gt;Latency is approximately 10 (20 dual-port accesses) but requires thousands of LUTs and registers (about 400 times the logic of the first option minus any optimizations that can be made)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不完美的循环嵌套&#34;&gt;不完美的循环嵌套&lt;/h3&gt;
&lt;p&gt;不完美的循环嵌套，或者无法将循环嵌套展开，会导致进入和退出循环的额外时钟周期。&lt;/p&gt;
&lt;h2 id=&#34;循环并行&#34;&gt;循环并行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HLS会使得逻辑和函数并行，但是并不会调度循环来并行。&lt;/li&gt;
&lt;li&gt;例子中SUM_X和SUM_Y不会并行调度，而是顺序的。（因为两个循环变量有不同的上限）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;loop_sequential.h&amp;quot;

void loop_sequential(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {  

 dout_t X_accum=0;
 dout_t Y_accum=0;
 int i,j;

 SUM_X:for (i=0;i&amp;lt;xlimit; i++) {
 X_accum += A[i];
 X[i] = X_accum;
}

 SUM_Y:for (i=0;i&amp;lt;ylimit; i++) {
 Y_accum += B[i];
 Y[i] = Y_accum;
 }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把两个循环装在function里面就可以并行了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;loop_functions.h&amp;quot;

void sub_func(din_t I[N], dout_t O[N], dsel_t limit) {
 int i;
 dout_t accum=0;
  
 SUM:for (i=0;i&amp;lt;limit; i++) {
 accum += I[i];
 O[i] = accum;
 }

}

void loop_functions(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], 
 dsel_t xlimit, dsel_t ylimit) {

 sub_func(A,X,xlimit);
 sub_func(B,Y,ylimit);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这是在函数中捕获循环以利用并行性的原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;循环依赖&#34;&gt;循环依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一次循环开始可能会依赖上一次循环的结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt; Minim_Loop: while (a != b) { 
 if (a &amp;gt; b) 
 a -= b; 
 else 
 b -= a;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;解决方案是&lt;strong&gt;尽量确保初始操作尽早执行&lt;/strong&gt;(应该就是对循环变量做修改等)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在c类中不会展开循环&#34;&gt;在c++类中不会展开循环&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;应小心确保循环归纳变量不是类的数据成员，因为这会防止循环被展开。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template &amp;lt;typename T0, typename T1, typename T2, typename T3, int N&amp;gt;
class foo_class
{
private:
    pe_mac&amp;lt;T0, T1, T2&amp;gt; mac;

public:
    T0 areg;
    T0 breg;
    T2 mreg;
    T1 preg;
    T0 shift[N];
    int k; // Class Member
    T0 shift_output;
    void exec(T1 *pcout, T0 *dataOut, T1 pcin, T3 coeff, T0 data, int col)
    {
    Function_label0:;
#pragma HLS inline off
    SRL:
        for (k = N - 1; k &amp;gt;= 0; --k)
        {
#pragma HLS unroll // Loop will fail UNROLL
            if (k &amp;gt; 0)
                shift[k] = shift[k - 1];
            else
                shift[k] = data;
        }

        *dataOut = shift_output;
        shift_output = shift[N - 1];
    }

    *pcout = mac.exec1(shift[4 * col], coeff, pcin);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;数组&#34;&gt;数组&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;仿真时候内存不够怎么办？一个妥协的方法是动态内存。&lt;/li&gt;
&lt;li&gt;定点数占用内存 &amp;gt;  arbitrary precision type &amp;gt; C自带类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;
  
  int i, acc; 
#ifdef __SYNTHESIS__
  // Use an arbitrary precision type &amp;amp; array for synthesis
  ap_int&amp;lt;32&amp;gt;  la0[10000000], la1[10000000]; 
#else 
  // Use an arbitrary precision type &amp;amp; dynamic memory for simulation
 ap_int&amp;lt;int32&amp;gt; *la0 = malloc(10000000  * sizeof(ap_int&amp;lt;32&amp;gt;));
 ap_int&amp;lt;int32&amp;gt; *la1 = malloc(10000000  * sizeof(ap_int&amp;lt;32&amp;gt;));
#endif
  for (i=0 ; i &amp;lt; 10000000; i++) { 
      acc = acc + la0[i] + la1[i]; 
  } 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组长度小于1024&lt;/strong&gt;：实例化为FIFO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组长度大于1024&lt;/strong&gt;： 保存在block RAM或LUTRAM或UltraRAM&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组访问和性能&#34;&gt;数组访问和性能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对数组访问次数越多，越会限制性能。（尤其是在一个循环中的情况）&lt;/li&gt;
&lt;li&gt;所以有如下的更改策略：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;array_mem_bottleneck.h&amp;quot;
 
dout_t array_mem_bottleneck(din_t mem[N]) {  

 dout_t sum=0;
 int i;

 SUM_LOOP:for(i=2;i&amp;lt;N;++i)
   sum += mem[i] + mem[i-1] + mem[i-2];
    
 return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;array_mem_perform.h&amp;quot;
 
dout_t array_mem_perform(din_t mem[N]) {  

 din_t tmp0, tmp1, tmp2;
 dout_t sum=0;
 int i;

 tmp0 = mem[0];
 tmp1 = mem[1];
 SUM_LOOP:for (i = 2; i &amp;lt; N; i++) { 
 tmp2 = mem[i];
 sum += tmp2 + tmp1 + tmp0;
 tmp0 = tmp1;
 tmp1 = tmp2;
 } 
    
 return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fifo访问&#34;&gt;FIFO访问&lt;/h3&gt;
&lt;p&gt;因为是先入先出，所以必须要从0开始顺序访问。&lt;/p&gt;
&lt;h2 id=&#34;接口上的数组top函数参数&#34;&gt;接口上的数组（top函数参数）&lt;/h2&gt;
&lt;p&gt;HLS会默认会将接口上数组认为是内存。HLS有两种假设的实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;off-chip的内存&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标准的block RAM，延迟只有1clock&lt;/strong&gt;： 数据会在地址给定后一个周期准备好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定是RAM还是FIFO的接口&lt;/li&gt;
&lt;li&gt;指定RAM是单端口还是双端口的RAM，预编译选项中的&lt;code&gt;storage_type&lt;/code&gt;，语法是&lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html#jit1504034365862__ad411155&#34;&gt;#pragma HLS interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;指定RAM延时， &lt;code&gt;latency&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ARRAY_PARTITION, ARRAY_RESHAPE 两个优化输入的命令。语法是&lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html?#ariaid-title4&#34;&gt;#pragma HLS array_partition&lt;/a&gt;， 相当于&lt;strong&gt;用寄存器代替RAM&lt;/strong&gt;，或者用更小的RAM来代替大的RAM。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;默认情况下&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认是单端口的RAM。&lt;/li&gt;
&lt;li&gt;如果initiation interval or latency可以被减少，则使用双端口的RAM&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数组初始化&#34;&gt;数组初始化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;建议使用&lt;code&gt;static&lt;/code&gt;关键字来建立数组，保证HLS将其变成内存。&lt;/li&gt;
&lt;li&gt;确保初始化大内存不会造成操作开销。不用static会在初始化时候，写入这些值，有一定时间开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例化一个rom&#34;&gt;实例化一个ROM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;建议使用&lt;code&gt;const&lt;/code&gt;来做一个只读的ROM，如果不加，也没有问题。综合过程自己会进行优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h2 id=&#34;cc-类型&#34;&gt;C/C++ 类型&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&#34;arbitrary-precision-ap-data-types-任意精度数据类型&#34;&gt;Arbitrary Precision (AP) Data Types 任意精度数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C语言可以这样写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;types.h&amp;quot;

typedef int6 dinA_t;
typedef int12 dinB_t;
typedef int22 dinC_t;
typedef int33 dinD_t;
typedef int18 dout1_t;
typedef uint13 dout2_t;
typedef int22 dout3_t;
typedef int6 dout4_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C++模版这样写&lt;/strong&gt;，还有一个好处是可以定义超大的数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;
void foo_top (…) {
  
 ap_int&amp;lt;9&amp;gt;  var1;           // 9-bit
 ap_uint&amp;lt;10&amp;gt;  var2;         // 10-bit unsigned
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定点数-arbitrary-precision-fixed-point-data-types&#34;&gt;定点数 Arbitrary Precision Fixed-Point Data Types&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;ap_fixed.h&amp;gt;
...
ap_fixed&amp;lt;18,6,AP_RND &amp;gt; my_type;
...
ap_fixed&amp;lt;2, 0&amp;gt; a = -0.5;    // a can be -0.5,
ap_ufixed&amp;lt;1, 0&amp;gt; x = 0.5;    // 1-bit representation. x can be 0 or 0.5
ap_ufixed&amp;lt;1, -1&amp;gt; y = 0.25;  // 1-bit representation. y can be 0 or 0.25
const ap_fixed&amp;lt;1, -7&amp;gt; z = 1.0/256;  // 1-bit representation for z = 2^-8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四个泛型参数分别为，见&lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/use_arbitrary_precision_data_type.html#guo1585572335601&#34;&gt;Fixed-Point Identifier Summary&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总长度&lt;/li&gt;
&lt;li&gt;整数位数（可以为负数，见例子）&lt;/li&gt;
&lt;li&gt;量化模式&lt;/li&gt;
&lt;li&gt;溢出饱和位数量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复合数据类型&#34;&gt;复合数据类型&lt;/h2&gt;
&lt;h3 id=&#34;struct&#34;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;默认成员是分解的。&lt;strong&gt;结构体的数组实现为多个数组&lt;/strong&gt;，结构体的每个成员都有一个单独的数组。&lt;/li&gt;
&lt;li&gt;利用pragma指令控制是否分解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;enum&#34;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&#34;unions&#34;&gt;&lt;code&gt;unions&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HLS综合并不保证使用相同的内存或者寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;类型限定符&#34;&gt;类型限定符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;综合不会进行优化&lt;/li&gt;
&lt;li&gt;Arbitrary precision types do not support the volatile qualifier（计算时候）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;RTL等价是寄存器、触发器和内存。&lt;/li&gt;
&lt;li&gt;config_rtl 需要配置，不然默认复位不会初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;常量或者ROM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全局变量&#34;&gt;全局变量&lt;/h2&gt;
&lt;p&gt;自由使用，但是只存在该ip核内部。&lt;/p&gt;
&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;
&lt;p&gt;可以综合，但尽量避免使用。尤其是以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个函数中，一个指针被读写多次&lt;/li&gt;
&lt;li&gt;指针类型转换仅限C/C++标准类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;接口处使用指针top函数的参数中&#34;&gt;接口处使用指针（top函数的参数中）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基本指针：
&lt;ul&gt;
&lt;li&gt;指针可以合成为一个简单的&lt;strong&gt;线接口&lt;/strong&gt;或使用握手的接口协议。&lt;/li&gt;
&lt;li&gt;要合成一个FIFO接口，指针必须是只读或只写的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指针运算：
&lt;ul&gt;
&lt;li&gt;不能实现，不能实现无序访问。&lt;/li&gt;
&lt;li&gt;需要变成数组，用RAM实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流数据
&lt;ul&gt;
&lt;li&gt;C++ 编译器可能会优化指针的访问，所以需要加volatile。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;pointer_stream_good.h&amp;quot;

void pointer_stream_good ( volatile dout_t *d_o,  volatile din_t *d_i) {
 din_t acc = 0;

 acc += *d_i;
 acc += *(d_i+1);
 *d_o = acc;
 acc += *(d_i+2);
 acc += *(d_i+3);
 *(d_o+1) = acc;
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vector类型&#34;&gt;Vector类型&lt;/h2&gt;
&lt;h3 id=&#34;hls的vector类型是为了simd操作&#34;&gt;HLS的Vector类型是为了SIMD操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;single-instruction multiple-data (SIMD)： 单指令，多数据。&lt;/li&gt;
&lt;li&gt;Vitis HLS提供的一个模版类型&lt;code&gt;hls::vector&amp;lt;T, N&amp;gt;&lt;/code&gt;: 一个有N个T类型的元素，T必须重载了数学运算。&lt;/li&gt;
&lt;li&gt;最佳性能是在&lt;strong&gt;T的位宽&lt;/strong&gt;和&lt;strong&gt;N的值&lt;/strong&gt;均为2的幂时。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;hls::vector&lt;/code&gt;上的运算操作都会被并行化，所以矩阵运算一般使用这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;hls_vector.h&amp;gt;
hls::vector&amp;lt;T,N&amp;gt;  aVec;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vector-内存布局&#34;&gt;Vector 内存布局&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vctor储存是对齐到2的n次方的。所以性能最好的时候是大小和位宽都为2的幂的时候。&lt;/li&gt;
&lt;li&gt;实现方式如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;constexpr size_t gp2(size_t N)
{
    return (N &amp;gt; 0 &amp;amp;&amp;amp; N % 2 == 0) ? 2 * gp2(N / 2) : 1;
}
 
template&amp;lt;typename T, size_t N&amp;gt; class alignas(gp2(sizeof(T) * N)) vector
{
    std::array&amp;lt;T, N&amp;gt; data;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;c类和模版&#34;&gt;C++类和模版&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;类是完全支持的。&lt;/li&gt;
&lt;li&gt;不建议在类中使用全局变量，会阻碍优化&lt;/li&gt;
&lt;li&gt;模版是支持的。但不能作为顶层函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;断言&#34;&gt;断言&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;断言可以用在综合中，提供范围的信息。如循环上限等。（不像tripcount 只能用于分析）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;高性能hls&#34;&gt;高性能HLS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;是最大程度地减少对顶层函数参数的访问。&lt;/li&gt;
&lt;li&gt;在阵列中设置默认值会花费时钟周期和性能。&lt;/li&gt;
&lt;li&gt;多次读取和重新读取数据会消耗时钟周期和性能。&lt;/li&gt;
&lt;li&gt;以任意或随机访问方式访问数据要求将数据存储在本地数组中，浪费资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;确保数据的连续流和数据重用&#34;&gt;确保数据的连续流和数据重用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将数据从CPU或系统内存传输到FPGA，则通常会以&lt;strong&gt;流传输方式&lt;/strong&gt;进行传输。从FPGA传输回系统的数据也应以这种方式执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hls::stream&lt;/code&gt; , 顺序访问，表现为一个无限深度的FIFO。&lt;/li&gt;
&lt;li&gt;在CPU体系结构中，通常避免有条件或分支操作。当程序需要分支时，它将丢失存储在CPU提取管线中的所有指令。&lt;strong&gt;在FPGA体系结构中，每个条件分支的硬件中已经存在一条单独的路径，并且不会与流水线任务内部的分支相关的性能下降。这只是选择要使用哪个分支的一种情况。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html&#34;&gt;HLS Pragmas&lt;/a&gt;的使用。&lt;/li&gt;
&lt;/ul&gt;
">Vitis HLS Coding Styles</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/"" data-c="
          &lt;p&gt;对例子中的语法等的一点记录&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HLS&lt;/strong&gt; (high-level synthesis)： 高级综合, 用 C/C++为FPGA开发 RTL IP.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vitis HLS&lt;/strong&gt;:  在Vivado 2020版本中替代原先的Vivado HLS, 功能略有差异，在Vivado HLS中的例子直接在Vitis HLS上跑会报错。详细比较见&lt;a href=&#34;https://cloud.tencent.com/developer/article/1745199&#34;&gt;Vivado HLS和Vitis HLS什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HLS中的pragma语法&lt;/strong&gt;: &lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html&#34;&gt;HLS Pragmas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma HLS dataflow&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，Vitis HLS工具试图最小化延迟并提高并发性。但是，数据依赖性可能会限制这一点。DATAFLOW优化使&lt;strong&gt;函数或循环中的操作能够在上一个函数或循环完成其所有操作之前开始操作&lt;/strong&gt;。（能够分析更细）。&lt;/li&gt;
&lt;li&gt;也能够解决两个不依赖循环不并行情况（类似于封装进函数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void diamond(data_t vecIn[N], data_t vecOut[N])
{
  data_t c1[N], c2[N], c3[N], c4[N];
#pragma HLS dataflow
  funcA(vecIn, c1, c2);
  funcB(c1, c3);
  funcC(c2, c4);
  funcD(c3, c4, vecOut);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609835551513.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma HLS pipeline rewind&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;构造一个连续循环的流水线。两次循环之间没有暂停。&lt;/li&gt;
&lt;li&gt;不能包含条件分支 (if-else)&lt;/li&gt;
&lt;li&gt;只支持循环，不支持函数的流水线化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;  for (int i = 0; i &amp;lt; N; i++)
  {
#pragma HLS pipeline rewind
#pragma HLS unroll factor = 2
    data_t t = in[i] * 3;
    out1[i] = t;
    out2[i] = t;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma HLS unroll factor = 2&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;将循环展开多少次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(int i = 0; i &amp;lt; X; i++) {
  pragma HLS unroll factor=2
  a[i] = b[i] + c[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;for(int i = 0; i &amp;lt; X; i += 2) {
  a[i] = b[i] + c[i];
  if (i+1 &amp;gt;= X) break;
  a[i+1] = b[i+1] + c[i+1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma HLS function_instantiate variable=&amp;lt;variable&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;FUNCTION_INSTANTIATE编译指示用于为函数的每个实例创建唯一的RTL实现，从而可以根据函数调用对每个实例进行本地优化。因为：调用函数时，&lt;strong&gt;函数的某些输入可以是恒定值&lt;/strong&gt;，并使用它来简化周围的控制结构并&lt;strong&gt;生成更小的&lt;/strong&gt;，&lt;strong&gt;更优化的功能块&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;variable&lt;/code&gt;是必需的参数，用于定义要用作常量的函数参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;char foo(char inval, char incr) {
#pragma HLS INLINE OFF
#pragma HLS FUNCTION_INSTANTIATE variable=incr
 return inval + incr;
}

void top(char inval1, char inval2, char inval3,
 char *outval1, char *outval2, char *outval3)
{
 *outval1 = foo(inval1,   0);
 *outval2 = foo(inval2,   1);
 *outval3 = foo(inval3, 100);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不完美的循环(imperfect loop)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;内层循环上限是一个变量。&lt;/li&gt;
&lt;li&gt;循环体并非全部在最里层循环中。&lt;/li&gt;
&lt;li&gt;所以&lt;strong&gt;没法展开&lt;/strong&gt;，会造成额外的进出循环的时钟周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    LOOP_I:for(i=0; i &amp;lt; 20; i++){
        acc = 0;
        LOOP_J: for(j=0; j &amp;lt; 20; j++){
            acc += A[j] * j;
        }
        if (i%2 == 0)
            B[i] = acc / 20;
        else
            B[i] = 0;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将不完美循环改写成完美循环的trick：&lt;strong&gt;使用条件语句&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    LOOP_I:for(i=0; i &amp;lt; 20; i++){
        LOOP_J: for(j=0; j &amp;lt; 20; j++){
            if(j==0) acc = 0;
            acc += A[j] * j;
            if(j==19) {
                if (i%2 == 0)
                    B[i] = acc / 20;
                else
                    B[i] = 0;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;循环可以没有label，HLS会生成默认label。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环上限为变量的优化方法： &lt;strong&gt;使用条件语句&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;  LOOP_X:for (x=0;x&amp;lt;N-1; x++) {
    if (x&amp;lt;width) {
      out_accum += A[x];
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;可以利用两个独立的模块来压缩流水的II （用模版实现较为方便，需要配合上多路选择器）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;//                    +--proc--&amp;gt;[ II=2 ]--+
//                   /                     \               
// in --&amp;gt;[demux II=1]                       [mux II=1]---&amp;gt; out
//                   \                     /
//                    +--proc--&amp;gt;[ II=2 ]--+

#include &amp;quot;example.h&amp;quot;

//--------------------------------------------
template &amp;lt;int ID&amp;gt;
void proc(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; &amp;amp;out)
{
    for (int i = 0; i &amp;lt; 25; i++)
    {
#pragma HLS PIPELINE II=2
#pragma HLS LATENCY min=2 max=2
        int var;
        in.read(var);
        out.write(var);
    }
}

//--------------------------------------------
void mux(stream&amp;lt;int&amp;gt; (&amp;amp;inter)[2], stream&amp;lt;int&amp;gt; &amp;amp;mux_output)
{
    int mux_sel = 0;
    for (int i = 0; i &amp;lt; 50; i++)
    {
#pragma HLS PIPELINE II=1
        int var;
        inter[mux_sel].read(var);
        mux_output.write(var);
        mux_sel = (mux_sel == 0) ? (1) : (0);
    }
}

//--------------------------------------------
void demux(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; (&amp;amp;inter)[2])
{
    int demux_sel = 0;
    for (int i = 0; i &amp;lt; 50; i++)
    {
#pragma HLS PIPELINE II=1

        int var;
        in.read(var);
        inter[demux_sel].write(var);
        demux_sel = (demux_sel == 0) ? 1 : 0;
    }
}

void example(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; &amp;amp;out)
{
#pragma HLS DATAFLOW

    stream&amp;lt;int&amp;gt; inter[2];
    stream&amp;lt;int&amp;gt; mux_in[2];

#pragma HLS STREAM variable = inter depth = 16
#pragma HLS STREAM variable = mux_in depth = 16

    demux(in, inter);
    proc&amp;lt;0&amp;gt;(inter[0], mux_in[0]);
    proc&amp;lt;1&amp;gt;(inter[1], mux_in[1]);
    mux(mux_in, out);
}
&lt;/code&gt;&lt;/pre&gt;
">Vitis HLS 的Tiny Tutorial部分代码分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/wu-zhou-nian-la/"" data-c="
          &lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609601219382.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;2020年的一月那么近又那么远&#34;&gt;2020年的一月，那么近又那么远&lt;/h1&gt;
&lt;p&gt;2020年跨年这一天，乡村教师吉返回北京，和被无数考试摧残的臭第一次跨年+参加学校的跨年晚会~&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609590165354.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;新新廿廿&lt;/strong&gt;的2020来啦&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609590219882.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那时的我们还不知道2020会是一团糟🙊🙉🙈&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;回新津(恰好错过了途径武汉的火车)，一起去看望了水吉妈妈家的小泰迪~🐶🐶🐶&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609592085383.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二月三月家里蹲&#34;&gt;二月三月家里蹲&lt;/h1&gt;
&lt;p&gt;一月末，疫情开始严重起来了。我们就只能骑着小电驴在两个家间穿梭，一三五在臭臭家，二四六在水吉家。就这样开开心心地度过了两个月~(监管最严格的时候甚至只能在超市碰头....)&lt;/p&gt;
&lt;p&gt;情人节的礼物是山地玫瑰！&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609591290870.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有小相机~ 这样坏记性的水吉就能够记录下更多在一起的美好回忆啦~&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609592821850.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在家里一起吃火锅&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609593178211.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一起穿睡衣一起刷剧一起比心&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609593229660.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一起泡jio&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609593307478.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一起尬舞，第一次也是唯一的一次两个人同时MEGASTAR&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609594381621.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一起玩耍&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609593946953.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一起做饭&lt;/strong&gt;&lt;br&gt;
都被吃掉了，没有图了😂&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;四月五月深圳happy&#34;&gt;四月五月深圳happy&lt;/h1&gt;
&lt;p&gt;四月五月，水吉的哥哥让水吉去深圳帮忙，我也一并去蹭吃蹭喝:)🍎🍖🍗🍤🍨🍡🍜&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;吃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595003396.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;吃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595010299.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;做饭，然后吃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595046890.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再做饭，然后吃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595058832.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后在办公室插满了水吉喜欢的花花~&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595105586.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;六月七月是分开的两个月&#34;&gt;六月七月是分开的两个月&lt;/h1&gt;
&lt;p&gt;疫情控制住了，乡村女教师吉吉水结束了网上上课，又回到了山西，成为了落水河最强的地理老师！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;唯一的约会地点是召唤师峡谷&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595665922.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;水吉给家里买了一堆肉肉~&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595729442.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;八月-老司机嘟嘟嘟&#34;&gt;八月 老司机嘟嘟嘟&lt;/h1&gt;
&lt;p&gt;水吉回来啦！我们也开始学车车！科一我们都考了一样的分数~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;嘟嘟嘟，开车啦&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609595988555.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;也去了广安的猫猫咖啡厅，不过还有人抽烟....&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596042550.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;九月-返校吃吃吃&#34;&gt;九月 返校吃吃吃&lt;/h1&gt;
&lt;p&gt;八月末终于可以返校了，水吉爸爸去西藏玩啦，可怜吉只好住在我家。白天学车做饭，晚上和妈妈一起刷剧，最后惊险通过科二， 而我在学校吃吃吃吃吃吃吃🤤🤤🤤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;半年多没有浇水的肉肉们&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596722960.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
水吉送的肉肉们竟然基本还是好好的，除了实验室的那个小个子顶不住了~&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596772512.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;和室友返校第一餐&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596564140.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;返校后和大家吃吃吃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596800689.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596808591.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596818858.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水吉回来啦，去水吉最喜欢的重八~&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609596866823.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;十月-出游-生日和桌游&#34;&gt;十月 出游、生日和桌游&lt;/h1&gt;
&lt;p&gt;每年十月，都是天高气爽的好日子，非常适合出去玩。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;再爬蟒山&lt;s&gt;大爷&lt;/s&gt;小弟&lt;/strong&gt;&lt;br&gt;
今天的十一又去了蟒山，蟒山大爷似乎今年格外的矮小，一会就登顶啦！&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597594730.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;去野鸭湖！&lt;/strong&gt;&lt;br&gt;
担任小学期助教的意外之喜，秋天的野鸭湖真的好漂亮~&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597706914.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597713248.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597735946.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;臭臭的生日&lt;/strong&gt;&lt;br&gt;
这一天，水吉因为有篮球比赛早早离开啦~和大为、sff在宿舍快乐嚯奶茶，开心卡卡颂！&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597802417.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提前送给水吉的生日礼物&lt;/strong&gt;&lt;br&gt;
今年送给水吉的礼物是一个能够放进书包的itx主机~老夫老妻了，早送早享受💻从此水吉的0-12快乐提莫再也不能找电脑卡的理由了hhhhhhhhh&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609597946418.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;桌游、桌游！&lt;/strong&gt;&lt;br&gt;
今年是水吉爱玩的一年，从塞尔达到卡卡颂、卡坦岛，水吉玩个不停！&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609598264941.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
（被迫加入游戏的我）&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;十一-十二月-吃吃吃和水吉的生日&#34;&gt;十一、十二月 吃吃吃和水吉的生日&lt;/h1&gt;
&lt;p&gt;今年的冬天格外的冷，所以涮肉要吃起来啊！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;听说，初雪和涮肉更配哦&lt;/strong&gt;&lt;br&gt;
初雪，我们去了四道口最好吃的涮肉，排队到了下午两点.....&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609598677322.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;繁忙的十二月，我们终于在五道口找了一家咖啡厅&lt;/strong&gt;&lt;br&gt;
今年因为校园封闭，不能再到校园里面来学习了，经过几番辗转，终于在五道口找到了新的落脚之地，又可以一起学习了。&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609598757515.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;圣诞——水吉的生日&lt;/strong&gt;&lt;br&gt;
和水吉以及水吉的室友们一起吃饭唱K，没错我就是K歌之王&lt;sub&gt;(的老公)&lt;/sub&gt;。&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609600194043.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;再次封校前的最后一次见面&lt;/strong&gt;&lt;br&gt;
学校又要封闭了，赶在最后一天和水吉见了一面，还吃了小宇哥推荐的好吃串串！（当天因为寒冷变成胆小菇的我↓）&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609600950737.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2021&#34;&gt;2021💑💏&lt;/h1&gt;
&lt;p&gt;新的一年，2021🐛🐛🐛啊！&lt;/p&gt;
&lt;p&gt;好像没啥好说的了，那 &lt;strong&gt;最后祝大家身体健康!!科研有成!!&lt;/strong&gt;&lt;/p&gt;
">👨👩💏五周年啦~🥂🍻</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/"" data-c="
          &lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;a href=&#34;https://www.zhihu.com/question/280468724/answer/517329473&#34;&gt;&lt;strong&gt;FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;并行计算，比如每个步骤没有关连性的循环操作；&lt;/li&gt;
&lt;li&gt;算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；&lt;/li&gt;
&lt;li&gt;乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；&lt;/li&gt;
&lt;li&gt;一些特定的矩阵运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;-2&#34;&gt;&lt;a href=&#34;https://www.zhihu.com/question/24174597/answer/138717507&#34;&gt;&lt;strong&gt;如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FPGA 为什么快？「都是同行衬托得好」。&lt;strong&gt;CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存&lt;/strong&gt;，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，&lt;strong&gt;不需要指令&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算密集型任务&lt;/strong&gt;(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当&lt;/li&gt;
&lt;li&gt;浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。&lt;/li&gt;
&lt;li&gt;在数据中心，FPGA 相比 GPU 的核心优势在于&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;FPGA 同时拥有&lt;strong&gt;流水线并行和数据并行&lt;/strong&gt;，而 GPU 几乎只有数据并行（流水线深度受限）。&lt;/li&gt;
&lt;li&gt;数据中心的计算任务是&lt;strong&gt;灵活多变&lt;/strong&gt;的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通信密集型任务&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。&lt;/li&gt;
&lt;li&gt;网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要规模足够大，对 FPGA 价格过高的担心将是不必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。&lt;strong&gt;如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态&lt;/strong&gt;。这时就不如用冯·诺依曼结构的处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 和 CPU 协同工作，&lt;strong&gt;局部性和重复性强的归 FPGA，复杂的归 CPU&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-3&#34;&gt;&lt;a href=&#34;https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf&#34;&gt;&lt;strong&gt;将浮点转为定点大幅降低功耗和成本 - Xilinx&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。&lt;/li&gt;
&lt;li&gt;对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浮点转换为定点的优势&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）&lt;/li&gt;
&lt;li&gt;功耗更低&lt;/li&gt;
&lt;li&gt;材料成本降低&lt;/li&gt;
&lt;li&gt;降低时延&lt;/li&gt;
&lt;li&gt;相近的性能和精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">FPGA用来加速运算的调研</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/"" data-c="
          &lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 &lt;strong&gt;处理器&lt;/strong&gt;和一个传统的现场可编程门阵列（Field Programmable Gate Array，&lt;strong&gt;FPGA&lt;/strong&gt;）逻辑部件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了&lt;strong&gt;高带宽、低延迟&lt;/strong&gt;的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而&lt;strong&gt;不会有&lt;/strong&gt;在两个分立的芯片之间的那种&lt;strong&gt;接口开销&lt;/strong&gt;。同时又能获得系统被简化为单一芯片所带来的好处，包括&lt;strong&gt;物理尺寸&lt;/strong&gt;和整体&lt;strong&gt;成本的降低&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;什么是片上系统/SoC (System on Chip)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。&lt;/li&gt;
&lt;li&gt;常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）&lt;/li&gt;
&lt;li&gt;和板上系统(在pcb板中组合多个元件)对比。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;开发时间和成本&lt;/li&gt;
&lt;li&gt;难以重用，不够灵活（与FPGA不同，直接设计芯片设计）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：手机，PC，平板等的CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理系统（PS）：支持软件程序和/ 或操作系统&lt;/li&gt;
&lt;li&gt;可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统&lt;/li&gt;
&lt;li&gt;工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609400781987.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软硬件系统关系&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609401050095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">The Zynq Book 学习： 引言</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/"" data-c="
          &lt;p&gt;总体架构图为：&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609385485651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PS (Processing System)中对外通信管脚:&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MIO&lt;/strong&gt; (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt; (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在&lt;strong&gt;约束文件中分配管脚&lt;/strong&gt;，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即&lt;strong&gt;PS可以利用EMIO和PL进行通信&lt;/strong&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**PL (Programmable Logic) 和 PS的通信接口 **&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609403066047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通用AXI（General Purpose AXI）&lt;/strong&gt;： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的&lt;strong&gt;中低速通信&lt;/strong&gt;。接口是透传的不带缓冲。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加速器一致性端口（Accelerator Coherency Port）&lt;/strong&gt;： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能端口（High Performance Ports）&lt;/strong&gt;： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。&lt;strong&gt;(PL直接从DDR中获取数据)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt;： 原本是用来连接I2C等协议的外设，也可以给PS使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pynq中python类对应&#34;&gt;PYNQ中python类对应：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GPIO&lt;/strong&gt;： 对应MIO， EMIO。（类似于单片机中的GPIO）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MMIO&lt;/strong&gt;： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xlnk&lt;/strong&gt;： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMA&lt;/strong&gt;： 对应HP AXI，访问DMA，即高性能AXI端口&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;axi-协议&#34;&gt;AXI 协议&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。&lt;/li&gt;
&lt;li&gt;AXI4_LITE： 只支持每次连接传输一个数据（非批量）。&lt;/li&gt;
&lt;li&gt;AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。&lt;/li&gt;
&lt;/ul&gt;
">ZYNQ中的通信接口(包括PS与PL)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/nand-flash-nor-flash/"" data-c="
          &lt;h2 id=&#34;flash-原理&#34;&gt;Flash 原理：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609254997519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609253806308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考&lt;a href=&#34;https://www.youtube.com/watch?v=aO_kBa9DzPQ&#34;&gt;youtube&lt;/a&gt;。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。&lt;/p&gt;
&lt;h2 id=&#34;nand-flash-和-nor-flash-区别&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609253097307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NAND 不能够取指令（类似于硬盘）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NOR 可以取指令（类似于内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于CPU运行时候需要三步：&lt;strong&gt;取指、译码、执行&lt;/strong&gt; 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ssd和u盘区别&#34;&gt;SSD和U盘区别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的&lt;br&gt;
主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么&lt;br&gt;
存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发&lt;br&gt;
接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快&lt;/p&gt;
&lt;p&gt;作者：李诗华&lt;br&gt;
链接：https://www.zhihu.com/question/265335741/answer/292414149&lt;br&gt;
来源：知乎&lt;/p&gt;
&lt;/blockquote&gt;
">NAND Flash, NOR Flash 的区别和应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/"" data-c="
          &lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;主要参考：&lt;a href=&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074&#34;&gt;细说Rust错误处理&lt;/a&gt; 和 &lt;a href=&#34;https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html&#34;&gt;Result 与可恢复的错误&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;tl-dr&#34;&gt;TL; DR&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt; 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）&lt;/li&gt;
&lt;li&gt;自定义一个&lt;code&gt;enum&lt;/code&gt;通常用在需要对错误进行恢复的时候。（容易检测类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;boxdyn-error-方式来聚合error&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn do_something() -&amp;gt; std::result::Result&amp;lt;(),Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt;{
    let path = &amp;quot;./dat&amp;quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&amp;lt;u32&amp;gt;()?;
    println!(&amp;quot;num:{:?}&amp;quot;,u);
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三者分别返回不同的错误类型，但是都可以用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;： 方便书写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“&lt;strong&gt;反射&lt;/strong&gt;”( &lt;code&gt;Any&lt;/code&gt; trait)才能够确定。而不能直接match。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;利用-enum-来聚合error&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;内容来自&lt;a href=&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074&#34;&gt;细说Rust错误处理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自定义一个&lt;code&gt;error&lt;/code&gt;需要实现如下几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Display&lt;/code&gt;的trait,并&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;fmt(...)&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Debug&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;，一般直接添加注解即可：&lt;code&gt;#[derive(Debug)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::error::Error&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;,并根据自身&lt;code&gt;error&lt;/code&gt;级别是否&lt;strong&gt;覆盖&lt;/strong&gt;&lt;code&gt;std::error::Error&lt;/code&gt;中的&lt;code&gt;source()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的内容中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;为我们实现的&lt;strong&gt;自定义Error&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;有三个&lt;strong&gt;子类型Error&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;分别实现了三个&lt;strong&gt;子类型Error&lt;/strong&gt; &lt;code&gt;From&lt;/code&gt;的trait,将其类型包装为&lt;strong&gt;自定义Error&lt;/strong&gt;的子类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，有了自定义的&lt;code&gt;CustomError&lt;/code&gt;，那怎么使用呢? 我们看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&amp;gt; std::result::Result&amp;lt;(),CustomError&amp;gt;{
    let path = &amp;quot;./dat&amp;quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&amp;quot;num:{:?}&amp;quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;String, std::io::Error&amp;gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;amp;[u8]) -&amp;gt; std::result::Result&amp;lt;&amp;amp;str, std::str::Utf8Error&amp;gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;u32, std::num::ParseIntError&amp;gt; {
    v.parse::&amp;lt;u32&amp;gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn std::error::Error + &#39;static)&amp;gt; {
        match &amp;amp;self {
            CustomError::IoError(ref e) =&amp;gt; Some(e),
            CustomError::Utf8Error(ref e) =&amp;gt; Some(e),
            CustomError::ParseIntError(ref e) =&amp;gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; std::fmt::Result {
        match &amp;amp;self {
            CustomError::IoError(ref e) =&amp;gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&amp;gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&amp;gt; e.fmt(f),
        }
    }
}

impl From&amp;lt;ParseIntError&amp;gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&amp;gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&amp;lt;IoError&amp;gt; for CustomError {
    fn from(s: std::io::Error) -&amp;gt; Self {
        CustomError::IoError(s)
    }
}

impl From&amp;lt;Utf8Error&amp;gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&amp;gt; Self {
        CustomError::Utf8Error(s)
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Rust 错误处理中多种类型Error传播的处理方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/"" data-c="
          &lt;p&gt;基于&lt;a href=&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;原作者的一些分析&#34;&gt;原作者的一些分析&lt;/h1&gt;
&lt;p&gt;基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(&lt;strong&gt;指针&lt;/strong&gt;)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优势：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;易于在大多数语言中实现&lt;/li&gt;
&lt;li&gt;没有上下文切换&lt;/li&gt;
&lt;li&gt;相对较低的内存开销(在大多数情况下)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。&lt;/li&gt;
&lt;li&gt;很难理解。许多人已经知道这是“回调地狱”。&lt;/li&gt;
&lt;li&gt;这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。&lt;/li&gt;
&lt;li&gt;由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;p&gt;通过代码，学习到了一些新东西，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_local!&lt;/code&gt; ：用来对每一个线程初始化同一个变量的一个新的副本。&lt;/li&gt;
&lt;li&gt;trait 对象： &lt;code&gt;Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&lt;/code&gt;,  &lt;code&gt;dyn Trait&lt;/code&gt;表示一个类型，强调是动态分发，并且必须是一个&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;
&lt;li&gt;传递闭包可以使用&lt;code&gt;impl Trait&lt;/code&gt;，这也是一个类型，并且该类型是&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread::spawn&lt;/code&gt;会直接新开一个子线程运行，不会造成主线程阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::sync::mpsc::Receiver.iter()&lt;/code&gt; 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的&lt;code&gt;.next()&lt;/code&gt; 才会变成&lt;code&gt;None&lt;/code&gt;，否则会一直等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
fn program_main() {
    // 第一个输出
    println!(&amp;quot;So we start the program here!&amp;quot;);
    // 运行到这儿的时候， 0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(200, || {
        // 第五个输出
        println!(&amp;quot;We create tasks with a callback that runs once the task finished!&amp;quot;);
    });
    // 运行到这儿的时候， 仍然是0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(100, || {
        // 第三个输出
        println!(&amp;quot;We can even chain sub-tasks...&amp;quot;);
        set_timeout(50, || {
            // 第四个输出
            println!(&amp;quot;...like this!&amp;quot;);
        })
    });
    // 运行到这儿的时候， 仍然是0ms
    // 第二个输出
    println!(&amp;quot;While our tasks are executing we can do other stuff instead of waiting.&amp;quot;);
}

fn main() {
    RT.with(|rt| rt.run(program_main));
}

use std::sync::mpsc::{channel, Receiver, Sender};
use std::{cell::RefCell, collections::HashMap, thread};


// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本
// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&amp;lt;Runtime&amp;gt;
// 这儿好像只用到了一个副本
thread_local! {
    static RT: Runtime = Runtime::new();
}

struct Runtime {
    // callbacks 中的Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt; 是一个 trait 对象。 
    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&amp;gt; u32。 
    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。
    callbacks: RefCell&amp;lt;HashMap&amp;lt;usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&amp;gt;&amp;gt;,
    // 储存下一个闭包的id
    next_id: RefCell&amp;lt;usize&amp;gt;,
    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id
    evt_sender: Sender&amp;lt;usize&amp;gt;,
    // 接受下一个该运行的闭包的id
    evt_reciever: Receiver&amp;lt;usize&amp;gt;,
}

// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &amp;quot;a concrete type that implements this trait&amp;quot;. 
// Its primary use is working with closures, which have type definitions generated at compile time that can&#39;t be simply typed out.
// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait
// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html
fn set_timeout(ms: u64, cb: impl FnOnce() + &#39;static) {
    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。
    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。
    // 相当于用.with()就是在使用该变量的函数。
    RT.with(|rt| {
        let id = *rt.next_id.borrow();
        // next_id递增
        *rt.next_id.borrow_mut() += 1;
        // callbacks存 (id: usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;)
        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知
        // cb 在输入参数中用的impl FnOnce() + &#39;static 来限定。
        rt.callbacks.borrow_mut().insert(id, Box::new(cb));
        // The sending-half of Rust&#39;s asynchronous channel type. 
        // This half can only be owned by one thread, but it can be cloned to send to other threads.
        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个
        let evt_sender = rt.evt_sender.clone();
        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去
        thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(ms));
            // 在延时结束后，发送当前延时结束的任务id
            evt_sender.send(id).unwrap();
        });
    });
}


impl Runtime {
    fn new() -&amp;gt; Self {
        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver
        let (evt_sender, evt_reciever) = channel();
        Runtime {
            callbacks: RefCell::new(HashMap::new()),
            next_id: RefCell::new(1),
            evt_sender,
            evt_reciever,
        }
    }

    // 这儿是在运行一个函数.
    fn run(&amp;amp;self, program: fn()) {
        // 直接运行， 
        program();
        // 0ms 运行到这儿
        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。
        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.
        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None
        for evt_id in &amp;amp;self.evt_reciever {
            // 这儿直接从HashMap里remove出对应编号的闭包。
            let cb = self.callbacks.borrow_mut().remove(&amp;amp;evt_id).unwrap();
            cb();
            // 是不是也不需要这句话？
            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了
            if self.callbacks.borrow().is_empty() {
                break;
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&amp;quot;学歌&amp;quot;。所以，在回调逻辑中 &lt;code&gt;sing_song()&lt;/code&gt;作为闭包， &lt;code&gt;learn_song()&lt;/code&gt; 作为子线程，主线程运行&lt;code&gt;dance()&lt;/code&gt; 。子线程结束后再运行这个闭包。运行顺序是 &lt;code&gt;learn_song()&lt;/code&gt; （子线程）和 &lt;code&gt;dance()&lt;/code&gt;  （主线程）同时运行，在两个任务均完成后， 再回调&lt;code&gt;sing_song()&lt;/code&gt;这个闭包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子线程&lt;/strong&gt;对应 &lt;strong&gt;“等待资源”&lt;/strong&gt; ； &lt;strong&gt;闭包&lt;/strong&gt;对应“&lt;strong&gt;接收到等待资源后的操作”&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;async fn learn_and_sing() {
    // 在唱歌之前等待学歌完成
    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。
    let song = learn_song().await;
    sing_song(song).await;
}
 async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成
     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞
     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，
     // 这个‘async_main&#39;函数就会变成阻塞状态，并生成一个执行器
    futures::join!(f1, f2)
}
 fn main() {
    block_on(async_main());
}
&lt;/code&gt;&lt;/pre&gt;
">Rust 基于回调的异步方法分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/"" data-c="
          &lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;const_unit_poc-利用const-generics实现的物理单位库&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const_unit_poc&lt;/code&gt;  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(const_generics, const_evaluatable_checked)]
use const_unit_poc::values::{m, kg, s, N};

let distance = 1.0 * m;
let mass = 18.0 * kg;
let force = distance * mass / (1.8 * s * 2.0 * s);
assert_eq!(force, 5.0 * N);

let mut mutable_distance = 3.2 * m;
mutable_distance -= 0.2 * m;
mutable_distance += 2.0 * m;

assert_eq!(mutable_distance, 5.0 * m);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。&lt;/p&gt;
&lt;h2 id=&#34;const_unit_poc-源码分析&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(const_generics, const_evaluatable_checked, doc_cfg)]
#![allow(incomplete_features)]
#![cfg_attr(feature = &amp;quot;non_ascii&amp;quot;, feature(non_ascii_idents))]

use std::ops;

pub mod units;
pub mod values;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_snake_case)]
pub struct SiUnit {
    m: i8,
    kg: i8,
    s: i8,
    A: i8,
    K: i8,
    mol: i8,
    cd: i8,
}

// 后面还有内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里引入了&lt;code&gt;units&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;两个mod，并且声明了&lt;code&gt;SiUnit&lt;/code&gt; 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。&lt;/p&gt;
&lt;p&gt;看到这儿，笔者推测应该是使用 &lt;code&gt;SiUnit&lt;/code&gt; 这个结构体来实例化各种常用的单位（如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），其中成员的值表示该单位表示成基本单位后的指数的值（如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N=m*s^{-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;， 则&lt;code&gt;N.m == 1; N.s == -2&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;再看一下引入的模块&lt;code&gt;units&lt;/code&gt;的内容&lt;/p&gt;
&lt;h3 id=&#34;units的实现&#34;&gt;units的实现&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs&#34;&gt;&lt;code&gt;./src/units.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![allow(non_upper_case_globals)]
use super::SiUnit;
const NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };
/// meter
pub const m: SiUnit = SiUnit { m: 1, ..NONE };
/// 中间内容省略
/// lux
pub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };
/// square meter
pub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };
/// cubic meter
pub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的确和猜想一致！注意结构体实例化时候这儿使用了&lt;code&gt;..NONE&lt;/code&gt;，这是用已经创建的实例None上&lt;strong&gt;更新部分参数&lt;/strong&gt;，创建新的实例，见&lt;a href=&#34;https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B&#34;&gt;使用结构体更新语法从其他实例创建实例&lt;/a&gt;。这儿使用了const使得各个单位全局可见且不可变。&lt;/p&gt;
&lt;p&gt;现在已经有了单位，但是我们注意到代码中&lt;code&gt;assert_eq!(mutable_distance, 5.0 * m);&lt;/code&gt;不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。&lt;/p&gt;
&lt;h3 id=&#34;对单位系数的包装&#34;&gt;对单位系数的包装&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs&#34;&gt;&lt;code&gt;./src/values.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![allow(non_upper_case_globals)]
use crate::{units, Quantity};
// base
/// 1 meter
pub const m: Quantity&amp;lt;{ units::m }&amp;gt; = Quantity { raw_value: 1.0 };
/// 1 kilogram
pub const kg: Quantity&amp;lt;{ units::kg }&amp;gt; = Quantity { raw_value: 1.0 };
/// 1 second
pub const s: Quantity&amp;lt;{ units::s }&amp;gt; = Quantity { raw_value: 1.0 };
/// 后面还有
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;use crate::{units, Quantity}&lt;/code&gt;, 代表的是导入的当前&lt;code&gt;crate&lt;/code&gt;中的&lt;code&gt;units&lt;/code&gt;和&lt;code&gt;Quantity&lt;/code&gt;。&lt;br&gt;
&lt;strong&gt;const 泛型&lt;/strong&gt;: 从这儿的可以大概可以看出，&lt;code&gt;Quantity&lt;/code&gt;的泛型参数是一个const常量，包装每一个&lt;code&gt;units.rs&lt;/code&gt;中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：&lt;code&gt;Quantity&amp;lt;{ units::m }&amp;gt; { raw_value: 1.0 }&lt;/code&gt;。 所以是用&lt;code&gt;raw_value&lt;/code&gt;来表示每一个单位的系数。&lt;/p&gt;
&lt;p&gt;所以再来看看&lt;code&gt;Quantity&lt;/code&gt;的定义吧。&lt;/p&gt;
&lt;p&gt;###结构体 &lt;code&gt;Quantity&lt;/code&gt;的定义&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Quantity&amp;lt;const U: SiUnit&amp;gt; {
    pub raw_value: f64,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单干脆的使用const 类型作为泛型参数。&lt;/p&gt;
&lt;h3 id=&#34;加减运算&#34;&gt;加减运算&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Add for Quantity&amp;lt;U&amp;gt; {
    type Output = Self;

    fn add(self, rhs: Self) -&amp;gt; Self {
        Self { raw_value: self.raw_value + rhs.raw_value }
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::AddAssign for Quantity&amp;lt;U&amp;gt; {
    fn add_assign(&amp;amp;mut self, rhs: Self) {
        self.raw_value += rhs.raw_value;
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::Sub for Quantity&amp;lt;U&amp;gt; {
    type Output = Self;

    fn sub(self, rhs: Self) -&amp;gt; Self {
        Self { raw_value: self.raw_value - rhs.raw_value }
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::SubAssign for Quantity&amp;lt;U&amp;gt; {
    fn sub_assign(&amp;amp;mut self, rhs: Self) {
        self.raw_value -= rhs.raw_value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于加减运算并不会变单位，所以就是对系数的加减，非常直接。&lt;/p&gt;
&lt;h3 id=&#34;乘除运算&#34;&gt;乘除运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个数字与一个Quantity相乘，单位不变：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Mul&amp;lt;f64&amp;gt; for Quantity&amp;lt;U&amp;gt; {
    type Output = Quantity&amp;lt;U&amp;gt;;

    fn mul(self, rhs: f64) -&amp;gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;两个带单位的量相乘，单位发生变化，也就是&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;的泛型参数发生了变化，此时需要重新实例化一个&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;结构体：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Quantity相乘转换为unit相乘，UL.unit_mul(UR)
impl&amp;lt;const UL: SiUnit, const UR: SiUnit&amp;gt; ops::Mul&amp;lt;Quantity&amp;lt;UR&amp;gt;&amp;gt; for Quantity&amp;lt;UL&amp;gt;
where
    Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;: ,
{
    type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;

    fn mul(self, rhs: Quantity&amp;lt;UR&amp;gt;) -&amp;gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs.raw_value }
    }
}
// unit相乘
impl SiUnit {
    const fn unit_mul(self, rhs: Self) -&amp;gt; Self {
        Self {
            m: self.m + rhs.m,
            kg: self.kg + rhs.kg,
            s: self.s + rhs.s,
            A: self.A + rhs.A,
            K: self.K + rhs.K,
            mol: self.mol + rhs.mol,
            cd: self.cd + rhs.cd,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这儿对泛型的约束很神奇，竟然是这样写&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;:&lt;/code&gt; ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;error: unconstrained generic constant
   --&amp;gt; src\lib.rs:156:5
    |
156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
    |
help: consider adding a `where` bound for this expression  
   --&amp;gt; src\lib.rs:156:28
    |
156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     
    |                            ^^^^^^^^^^^^^^^^^^^     
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;&lt;/code&gt; ，否则也会出错。这在最近的&lt;a href=&#34;https://github.com/rust-lang/rust/pull/79135&#34;&gt;Stabilization report&lt;/a&gt;里面也有提到。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Const arguments&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, &lt;strong&gt;most expressions must be contained within a block&lt;/strong&gt;, with two exceptions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;literals and single-segment path expressions&lt;/li&gt;
&lt;li&gt;array lengths&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.&lt;/p&gt;
&lt;p&gt;In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;type N = u32;
struct Foo&amp;lt;const N: usize&amp;gt;;
fn foo&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;N&amp;gt; { todo!() } // ERR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;type N = u32;
struct Foo&amp;lt;const N: usize&amp;gt;;
fn bar&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;{ N }&amp;gt; { todo!() } // ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是了解了const 泛型在做啥，以及如何做的。&lt;/p&gt;
&lt;p&gt;通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。&lt;/p&gt;
">Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-yi-bu/"" data-c="
          &lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;
Rust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-为什么需要异步编程&#34;&gt;1. 为什么需要异步编程？&lt;/h1&gt;
&lt;p&gt;刚开始一直有一个疑问：&lt;strong&gt;既然已经有了多线程技术，多用户访问直接使用多线程，为什么还需要异步呢？&lt;/strong&gt; 后来终于明白，异步是用在多用户&lt;strong&gt;同时处理同一资源&lt;/strong&gt;时候发挥作用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;现在用100个用户同时修改一个文件来举例：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;(一般也是&lt;strong&gt;阻塞&lt;/strong&gt;)： 程序需要实现&lt;strong&gt;读写锁(&lt;code&gt;std::sync::RwLock&lt;/code&gt;)&lt;strong&gt;或&lt;/strong&gt;互斥锁(&lt;code&gt;std::sync::Mutex&lt;/code&gt;)&lt;/strong&gt;，程序会同时产生100个线程，但是只能有一个线程拥有写锁，其他的99个线程均&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处于&lt;strong&gt;等待状态&lt;/strong&gt;，线程不会sleep，会循环获取锁(自旋锁Spinlock)。
&lt;ul&gt;
&lt;li&gt;阻塞的线程还来参与操作系统的抢占式调度，很不科学！为什么不先排好队，用一个线程呢（这也是协程干的事）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;或者有起始的&lt;strong&gt;加锁开销&lt;/strong&gt;(通常是对互斥锁：①线程会从sleep（加锁）——&amp;gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；②互斥锁在sleep时会陷入到内核态，需要昂贵的系统调用；线程向操作系统请求被挂起是通过一个系统调用，在linux上的实现就是futex)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;(一般也是&lt;strong&gt;非阻塞&lt;/strong&gt;)： 将100个线程根据一定的先后次序&lt;strong&gt;合并成一个线程&lt;/strong&gt;(也可能是多个线程？)， 就可以避免锁的产生，从而减少操作系统对线程调用的开销。但是，当线程之间对资源的依赖关系比较复杂的时候，程序的编写就会&lt;strong&gt;十分复杂&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt;(coroutine)： 实现异步编程的一种方式，是在线程之下的一个单位。协程是语言层面控制数据流的一种“调度”（处理公共资源的时候，相当于&lt;strong&gt;用户态的锁&lt;/strong&gt;）， 线程是操作系统层面的“调度”（处理公共资源，使用&lt;strong&gt;操作系统或者硬件的锁(即Mutex或者Spinlock)&lt;/strong&gt;）。协程的调度是编译器通过组织运算顺序实现的（通过生成器（等同于一个状态机）实现），线程是通过操作系统来进行抢占式调度的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B&#34;&gt;协程wiki&lt;/a&gt;：协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/332113890/answer/1052024052&#34;&gt;互斥锁（mutex）的底层原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/50185085/answer/1342613525&#34;&gt;出于什么样的原因，诞生了「协程」这一概念？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，异步编程是可以直接用复杂的代码结构直接写出来的。比如上面的例子就是在一个线程里面去依次读写100次。而Rust的&lt;code&gt;async/.await&lt;/code&gt;解决方案做的工作是 &lt;strong&gt;“将复杂的异步代码 ===&amp;gt; 利用语法糖 ===&amp;gt; 转化为类似于同步的代码(更容易coding)”&lt;/strong&gt;  即 &lt;strong&gt;“用同步的语义解决异步问题”&lt;/strong&gt; 。&lt;/p&gt;
"> Rust 异步并发（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;一个自说自话的地方。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;一只在毕业边缘挣扎的秃头怪。&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;coding~&lt;br&gt;
以及一切有趣的事情们~&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;thubzy15@foxmail.com&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/2020112-yi-shi/"" data-c="
          &lt;p&gt;从&lt;strong&gt;今天&lt;/strong&gt;开始记录学习和生活。&lt;/p&gt;
&lt;p&gt;我也是一个懒惰的小博主啦~😋&lt;/p&gt;
">2020.11.22 伊始</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;找了一会儿才找到, 所以记录下来。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;用HLS生成的ip核，使用axi-lite协议，找不到pynq中top函数变量对应的内存空间地址。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;HLS中，Synthesis Summary的最后一项可以看到HW info.&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1610012440636.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;HLS生成的verilog文件(XXXXX_control_s_axi.v)中，有接口地址信息的注释。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;//------------------------Address Info-------------------\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of a\n//        bit 31~0 - a[31:0] (Read/Write)\n// 0x14 : reserved\n// 0x18 : Data signal of b\n//        bit 31~0 - b[31:0] (Read/Write)\n// 0x1c : reserved\n// 0x20 : Data signal of c\n//        bit 31~0 - c[31:0] (Read)\n// 0x24 : Control signal of c\n//        bit 0  - c_ap_vld (Read/COR)\n//        others - reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;pynq中，可通过&lt;code&gt;register_map&lt;/code&gt;直接查看地址，或者直接操作变量。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-python\&#34;&gt;from pynq import Overlay\noverlay = Overlay(&#39;./design_1.bit&#39;)\nadd_ip = overlay.add_0\n\nadd_ip.register_map.a = 3\nadd_ip.register_map.b = 4\nc = add_ip.register_map.c\nc.address\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;zynq-zhong-cha-kan-yong-hls-sheng-cheng-de-ip-he-duan-kou-dui-ying-de-nei-cun-kong-jian&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;找了一会儿才找到, 所以记录下来。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Zynq 中查看用HLS 生成的IP核端口对应的内存空间&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;HLS&#34;,&#34;slug&#34;:&#34;pm9HjSOZ32&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/pm9HjSOZ32/&#34;},{&#34;name&#34;:&#34;zynq&#34;,&#34;slug&#34;:&#34;VR993R9Vz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/VR993R9Vz/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2021-01-07 17:34:33&#34;,&#34;dateFormat&#34;:&#34;2021-01-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/zynq-zhong-cha-kan-yong-hls-sheng-cheng-de-ip-he-duan-kou-dui-ying-de-nei-cun-kong-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:60000,&#34;words&#34;:201,&#34;minutes&#34;:2},&#34;description&#34;:&#34;找了一会儿才找到, 所以记录下来。\n\n用HLS生成的ip核，使用axi-lite协议，找不到pynq中top函数变量对应的内存空间地址。\n\nHLS中，Synthesis Summary的最后一项可以看到HW info.\n\nHLS生成的ver...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;参考Xilinx文档，&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html\&#34;&gt;Vitis HLS Coding Styles&lt;/a&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;不支持的cc部分\&#34;&gt;不支持的C/C++部分&lt;/h1&gt;\n&lt;h2 id=\&#34;系统调用\&#34;&gt;系统调用&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;printf()&lt;/code&gt;， &lt;code&gt;fprintf(stdout,)&lt;/code&gt;等不会影响算法执行的系统调用——忽略掉。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;getc()&lt;/code&gt;, &lt;code&gt;time()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt; 等系统调用——不被接受。&lt;/li&gt;\n&lt;li&gt;可以使用&lt;code&gt;__SYNTHESIS__&lt;/code&gt;宏来区分&lt;strong&gt;综合&lt;/strong&gt;与&lt;strong&gt;调试&lt;/strong&gt;过程&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-c\&#34;&gt;void hier_func4(din_t A, din_t B, dout_t *C, dout_t *D)\n{\n    dint_t apb, amb;\n\n    sumsub_func(&amp;amp;A, &amp;amp;B, &amp;amp;apb, &amp;amp;amb);\n#ifndef __SYNTHESIS__\n    FILE *fp1; // The following code is ignored for synthesis\n    char filename[255];\n    sprintf(filename, Out_apb_ % 03d.dat, apb);\n    fp1 = fopen(filename, w);\n    fprintf(fp1, % d \\n, apb);\n    fclose(fp1);\n#endif\n    shift_func(&amp;amp;apb, &amp;amp;amb, C, D);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;动态内存\&#34;&gt;动态内存&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;malloc()&lt;/code&gt;， &lt;code&gt;new&lt;/code&gt; 等动态分配内存的不行, 不能在堆上分配内存，必须在栈上。（因为该HLS技术是静态分析）&lt;/li&gt;\n&lt;li&gt;一种改动方法是直接对栈上变量取指针：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C\&#34;&gt;#include &amp;quot;malloc_removed.h&amp;quot;\n#include &amp;lt;stdlib.h&amp;gt;\n//#define NO_SYNTH\n\ndout_t malloc_removed(din_t din[N], dsel_t width) {  \n\n#ifdef NO_SYNTH\n long long *out_accum = malloc (sizeof(long long));\n int* array_local = malloc (64 * sizeof(int));\n#else\n long long _out_accum;\n long long *out_accum = &amp;amp;_out_accum;\n int _array_local[64];\n int* array_local = &amp;amp;_array_local[0];\n#endif\n// 中间计算省略\n return *out_accum;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;指针的一些限制\&#34;&gt;指针的一些限制&lt;/h2&gt;\n&lt;h3 id=\&#34;通用指针类型转换\&#34;&gt;通用指针类型转换&lt;/h3&gt;\n&lt;p&gt;HLS 只支持C/C++原生类型的转换&lt;/p&gt;\n&lt;h3 id=\&#34;指针数组\&#34;&gt;指针数组&lt;/h3&gt;\n&lt;p&gt;如果每个指针指向一个标量或一个标量数组，则Vitis HLS支持指针数组的综合。但指针数组不能指向额外的指针（应该类似二维数组的行、列指针）&lt;/p&gt;\n&lt;h3 id=\&#34;函数指针\&#34;&gt;函数指针&lt;/h3&gt;\n&lt;p&gt;不支持&lt;/p&gt;\n&lt;h2 id=\&#34;递归函数\&#34;&gt;递归函数&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;不支持。不管最后递归次数是不是有限的。&lt;/li&gt;\n&lt;li&gt;可以使用C++模板来构造&lt;strong&gt;可以用来综合的尾递归&lt;/strong&gt;，因为C++中支持非类型模板参数（Nontype Template Parameters），类似Rust中的const泛型，这儿的模板参数为&lt;code&gt;data_t&lt;/code&gt;类型的一个值 N。&lt;a href=\&#34;https://github.com/Xilinx/HLS-Tiny-Tutorials/tree/master/algorithm_template_fir_filter\&#34;&gt;例子如下&lt;/a&gt;：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;// Tail recursive call\ntemplate&amp;lt;data_t N&amp;gt; \n\tstruct fibon_s {\n    template&amp;lt;typename T&amp;gt;\n    static T fibon_f(T a, T b) {\n\t\treturn fibon_s&amp;lt;N-1&amp;gt;::fibon_f(b, (a+b));\n  }\n};\n\n// Termination condition\ntemplate&amp;lt;&amp;gt; struct fibon_s&amp;lt;1&amp;gt; {\n  template&amp;lt;typename T&amp;gt;\n  static T fibon_f(T a, T b) {\n    return b;\n  }\n};\n\nvoid cpp_template(data_t a, data_t b, data_t &amp;amp;dout){\n  dout = fibon_s&amp;lt;FIB_N&amp;gt;::fibon_f(a,b);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;stl\&#34;&gt;STL&lt;/h2&gt;\n&lt;p&gt;有动态内存和递归，不能使用。&lt;/p&gt;\n&lt;h1 id=\&#34;函数\&#34;&gt;函数&lt;/h1&gt;\n&lt;p&gt;顶层函数不能是静态的。&lt;/p&gt;\n&lt;h2 id=\&#34;内联函数\&#34;&gt;内联函数&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;综合时候花费时间、内存较多，但效果更好。&lt;/li&gt;\n&lt;li&gt;没有独立的RTL文件和报告了。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;代码风格的影响\&#34;&gt;代码风格的影响&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;影响函数参数和接口&lt;/li&gt;\n&lt;li&gt;直接用函数接口的输入量来驱动变量时候，程序就不会使用某些优化手段。（如输入量是循环索引的上限）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\n\nap_int&amp;lt;24&amp;gt; foo(int x, int y) {  \n int tmp;\n\n tmp = (x * y);\n return tmp\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码这会导致一个32-bit乘法器，输出再被截取。&lt;br&gt;\n下面这个代码直接产生一个24-bit乘法器。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\ntypedef ap_int&amp;lt;12&amp;gt; din_t;\ntypedef ap_int&amp;lt;24&amp;gt; dout_t;\n\ndout_t func_sized(din_t x, din_t y) {  \n int tmp;\n\n tmp = (x * y);\n return tmp\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;cc内置函数\&#34;&gt;C/C++内置函数&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;只支持以下两个&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;__builtin_clz(unsigned int x)&lt;/code&gt;: Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;__builtin_ctz(unsigned int x)&lt;/code&gt;: Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;循环\&#34;&gt;循环&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;支持得很好。可以切流水线，展开、部分展开、合并和扁平化&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;不要使用全局变量作为循环变量&lt;/strong&gt;，否则会阻碍代码优化&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;循环变量范围\&#34;&gt;循环变量范围&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;循环变量的上限如果是变量，就难以在综合时候优化。&lt;/li&gt;\n&lt;li&gt;循环变量的上限如果是变量，循环的latency无法确定。&lt;/li&gt;\n&lt;li&gt;循环变量的上限如果是变量，设计的性能未知。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\n#define N 32\n\ntypedef ap_int&amp;lt;8&amp;gt; din_t;\ntypedef ap_int&amp;lt;13&amp;gt; dout_t;\ntypedef ap_uint&amp;lt;5&amp;gt; dsel_t;\n\ndout_t code028(din_t A[N], dsel_t width) {  \n\n dout_t out_accum=0;\n dsel_t x;\n\n LOOP_X:for (x=0;x&amp;lt;width; x++) {\n out_accum += A[x];\n }\n\n return out_accum;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;为了克服无法分析性能的缺点，一般是加上&lt;br&gt;\n&lt;code&gt;#pragma HLS loop_tripcount min=&amp;lt;int&amp;gt; max=&amp;lt;int&amp;gt; avg=&amp;lt;int&amp;gt;&lt;/code&gt;&lt;br&gt;\n或者是使用断言&lt;code&gt;assert&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;void foo (num_samples, ...) {\n  int i;\n  ...\n  loop_1: for(i=0;i&amp;lt; num_samples;i++) {\n   #pragma HLS loop_tripcount min=12 max=16\n   ...\n    result = a + b;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：该编译选项只用于分析，不会用于综合。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;对于具有可变边界的循环的解决方案是：在循环中有条件地执行，并且令循环迭代的次数为固定值。&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\n#define N 32\n\ntypedef ap_int&amp;lt;8&amp;gt; din_t;\ntypedef ap_int&amp;lt;13&amp;gt; dout_t;\ntypedef ap_uint&amp;lt;5&amp;gt; dsel_t;\n\ndout_t loop_max_bounds(din_t A[N], dsel_t width) {  \n\n dout_t out_accum=0;\n dsel_t x;\n\n LOOP_X:for (x=0; x&amp;lt;N; x++) {\n if (x&amp;lt;width) {\n  out_accum += A[x];\n }\n }\n\n return out_accum;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;将循环流水线化\&#34;&gt;将循环流水线化&lt;/h2&gt;\n&lt;p&gt;通常通过流水线最内层的循环来找到面积和性能之间的最佳平衡。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;loop_pipeline.h&amp;quot;\n\ndout_t loop_pipeline(din_t A[N]) {  \n\n int i,j;\n static dout_t acc;\n\n LOOP_I:for(i=0; i &amp;lt; 20; i++){\n LOOP_J: for(j=0; j &amp;lt; 20; j++){\n acc += A[i] * j;\n }\n }\n\n return acc;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Pipeline &lt;code&gt;LOOP_J&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;只需调度一个乘法器操作和一个数组访问&lt;/li&gt;\n&lt;li&gt;Latency is approximately 400 cycles (20x20) and requires less than 100 LUTs and registers (the I/O control and FSM are always present).&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Pipeline &lt;code&gt;LOOP_I&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;内部循环展开20次。&lt;/li&gt;\n&lt;li&gt;需调度20个乘法器操作和20个数组访问&lt;/li&gt;\n&lt;li&gt;Latency is approximately 20 cycles but requires a few hundred LUTs and registers. About 20 times the logic as first option, minus any logic optimizations that can be made.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Pipeline &lt;code&gt;function loop_pipeline&lt;/code&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;需调度400个乘法器操作和400个数组访问&lt;/li&gt;\n&lt;li&gt;Latency is approximately 10 (20 dual-port accesses) but requires thousands of LUTs and registers (about 400 times the logic of the first option minus any optimizations that can be made)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;不完美的循环嵌套\&#34;&gt;不完美的循环嵌套&lt;/h3&gt;\n&lt;p&gt;不完美的循环嵌套，或者无法将循环嵌套展开，会导致进入和退出循环的额外时钟周期。&lt;/p&gt;\n&lt;h2 id=\&#34;循环并行\&#34;&gt;循环并行&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;HLS会使得逻辑和函数并行，但是并不会调度循环来并行。&lt;/li&gt;\n&lt;li&gt;例子中SUM_X和SUM_Y不会并行调度，而是顺序的。（因为两个循环变量有不同的上限）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;loop_sequential.h&amp;quot;\n\nvoid loop_sequential(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], \n dsel_t xlimit, dsel_t ylimit) {  \n\n dout_t X_accum=0;\n dout_t Y_accum=0;\n int i,j;\n\n SUM_X:for (i=0;i&amp;lt;xlimit; i++) {\n X_accum += A[i];\n X[i] = X_accum;\n}\n\n SUM_Y:for (i=0;i&amp;lt;ylimit; i++) {\n Y_accum += B[i];\n Y[i] = Y_accum;\n }\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;把两个循环装在function里面就可以并行了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;loop_functions.h&amp;quot;\n\nvoid sub_func(din_t I[N], dout_t O[N], dsel_t limit) {\n int i;\n dout_t accum=0;\n  \n SUM:for (i=0;i&amp;lt;limit; i++) {\n accum += I[i];\n O[i] = accum;\n }\n\n}\n\nvoid loop_functions(din_t A[N], din_t B[N], dout_t X[N], dout_t Y[N], \n dsel_t xlimit, dsel_t ylimit) {\n\n sub_func(A,X,xlimit);\n sub_func(B,Y,ylimit);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;这是在函数中捕获循环以利用并行性的原则&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;循环依赖\&#34;&gt;循环依赖&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;一次循环开始可能会依赖上一次循环的结束。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt; Minim_Loop: while (a != b) { \n if (a &amp;gt; b) \n a -= b; \n else \n b -= a;\n }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;解决方案是&lt;strong&gt;尽量确保初始操作尽早执行&lt;/strong&gt;(应该就是对循环变量做修改等)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;在c类中不会展开循环\&#34;&gt;在c++类中不会展开循环&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;应小心确保循环归纳变量不是类的数据成员，因为这会防止循环被展开。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;template &amp;lt;typename T0, typename T1, typename T2, typename T3, int N&amp;gt;\nclass foo_class\n{\nprivate:\n    pe_mac&amp;lt;T0, T1, T2&amp;gt; mac;\n\npublic:\n    T0 areg;\n    T0 breg;\n    T2 mreg;\n    T1 preg;\n    T0 shift[N];\n    int k; // Class Member\n    T0 shift_output;\n    void exec(T1 *pcout, T0 *dataOut, T1 pcin, T3 coeff, T0 data, int col)\n    {\n    Function_label0:;\n#pragma HLS inline off\n    SRL:\n        for (k = N - 1; k &amp;gt;= 0; --k)\n        {\n#pragma HLS unroll // Loop will fail UNROLL\n            if (k &amp;gt; 0)\n                shift[k] = shift[k - 1];\n            else\n                shift[k] = data;\n        }\n\n        *dataOut = shift_output;\n        shift_output = shift[N - 1];\n    }\n\n    *pcout = mac.exec1(shift[4 * col], coeff, pcin);\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;数组\&#34;&gt;数组&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;仿真时候内存不够怎么办？一个妥协的方法是动态内存。&lt;/li&gt;\n&lt;li&gt;定点数占用内存 &amp;gt;  arbitrary precision type &amp;gt; C自带类型&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\n  \n  int i, acc; \n#ifdef __SYNTHESIS__\n  // Use an arbitrary precision type &amp;amp; array for synthesis\n  ap_int&amp;lt;32&amp;gt;  la0[10000000], la1[10000000]; \n#else \n  // Use an arbitrary precision type &amp;amp; dynamic memory for simulation\n ap_int&amp;lt;int32&amp;gt; *la0 = malloc(10000000  * sizeof(ap_int&amp;lt;32&amp;gt;));\n ap_int&amp;lt;int32&amp;gt; *la1 = malloc(10000000  * sizeof(ap_int&amp;lt;32&amp;gt;));\n#endif\n  for (i=0 ; i &amp;lt; 10000000; i++) { \n      acc = acc + la0[i] + la1[i]; \n  } \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;数组长度小于1024&lt;/strong&gt;：实例化为FIFO&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;数组长度大于1024&lt;/strong&gt;： 保存在block RAM或LUTRAM或UltraRAM&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;数组访问和性能\&#34;&gt;数组访问和性能&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;对数组访问次数越多，越会限制性能。（尤其是在一个循环中的情况）&lt;/li&gt;\n&lt;li&gt;所以有如下的更改策略：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;array_mem_bottleneck.h&amp;quot;\n \ndout_t array_mem_bottleneck(din_t mem[N]) {  \n\n dout_t sum=0;\n int i;\n\n SUM_LOOP:for(i=2;i&amp;lt;N;++i)\n   sum += mem[i] + mem[i-1] + mem[i-2];\n    \n return sum;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;array_mem_perform.h&amp;quot;\n \ndout_t array_mem_perform(din_t mem[N]) {  \n\n din_t tmp0, tmp1, tmp2;\n dout_t sum=0;\n int i;\n\n tmp0 = mem[0];\n tmp1 = mem[1];\n SUM_LOOP:for (i = 2; i &amp;lt; N; i++) { \n tmp2 = mem[i];\n sum += tmp2 + tmp1 + tmp0;\n tmp0 = tmp1;\n tmp1 = tmp2;\n } \n    \n return sum;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;fifo访问\&#34;&gt;FIFO访问&lt;/h3&gt;\n&lt;p&gt;因为是先入先出，所以必须要从0开始顺序访问。&lt;/p&gt;\n&lt;h2 id=\&#34;接口上的数组top函数参数\&#34;&gt;接口上的数组（top函数参数）&lt;/h2&gt;\n&lt;p&gt;HLS会默认会将接口上数组认为是内存。HLS有两种假设的实现方式&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;off-chip的内存&lt;/strong&gt;：&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;标准的block RAM，延迟只有1clock&lt;/strong&gt;： 数据会在地址给定后一个周期准备好。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;所以需要：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;指定是RAM还是FIFO的接口&lt;/li&gt;\n&lt;li&gt;指定RAM是单端口还是双端口的RAM，预编译选项中的&lt;code&gt;storage_type&lt;/code&gt;，语法是&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html#jit1504034365862__ad411155\&#34;&gt;#pragma HLS interface&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;指定RAM延时， &lt;code&gt;latency&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;ARRAY_PARTITION, ARRAY_RESHAPE 两个优化输入的命令。语法是&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html?#ariaid-title4\&#34;&gt;#pragma HLS array_partition&lt;/a&gt;， 相当于&lt;strong&gt;用寄存器代替RAM&lt;/strong&gt;，或者用更小的RAM来代替大的RAM。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;默认情况下&lt;/strong&gt;：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;默认是单端口的RAM。&lt;/li&gt;\n&lt;li&gt;如果initiation interval or latency可以被减少，则使用双端口的RAM&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;数组初始化\&#34;&gt;数组初始化&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;建议使用&lt;code&gt;static&lt;/code&gt;关键字来建立数组，保证HLS将其变成内存。&lt;/li&gt;\n&lt;li&gt;确保初始化大内存不会造成操作开销。不用static会在初始化时候，写入这些值，有一定时间开销。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;实例化一个rom\&#34;&gt;实例化一个ROM&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;建议使用&lt;code&gt;const&lt;/code&gt;来做一个只读的ROM，如果不加，也没有问题。综合过程自己会进行优化。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;数据类型\&#34;&gt;数据类型&lt;/h1&gt;\n&lt;h2 id=\&#34;cc-类型\&#34;&gt;C/C++ 类型&lt;/h2&gt;\n&lt;p&gt;略&lt;/p&gt;\n&lt;h2 id=\&#34;arbitrary-precision-ap-data-types-任意精度数据类型\&#34;&gt;Arbitrary Precision (AP) Data Types 任意精度数据类型&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C语言可以这样写&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;types.h&amp;quot;\n\ntypedef int6 dinA_t;\ntypedef int12 dinB_t;\ntypedef int22 dinC_t;\ntypedef int33 dinD_t;\ntypedef int18 dout1_t;\ntypedef uint13 dout2_t;\ntypedef int22 dout3_t;\ntypedef int6 dout4_t;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;C++模版这样写&lt;/strong&gt;，还有一个好处是可以定义超大的数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;ap_int.h&amp;quot;\nvoid foo_top (…) {\n  \n ap_int&amp;lt;9&amp;gt;  var1;           // 9-bit\n ap_uint&amp;lt;10&amp;gt;  var2;         // 10-bit unsigned\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;定点数-arbitrary-precision-fixed-point-data-types\&#34;&gt;定点数 Arbitrary Precision Fixed-Point Data Types&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;lt;ap_fixed.h&amp;gt;\n...\nap_fixed&amp;lt;18,6,AP_RND &amp;gt; my_type;\n...\nap_fixed&amp;lt;2, 0&amp;gt; a = -0.5;    // a can be -0.5,\nap_ufixed&amp;lt;1, 0&amp;gt; x = 0.5;    // 1-bit representation. x can be 0 or 0.5\nap_ufixed&amp;lt;1, -1&amp;gt; y = 0.25;  // 1-bit representation. y can be 0 or 0.25\nconst ap_fixed&amp;lt;1, -7&amp;gt; z = 1.0/256;  // 1-bit representation for z = 2^-8\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;四个泛型参数分别为，见&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/use_arbitrary_precision_data_type.html#guo1585572335601\&#34;&gt;Fixed-Point Identifier Summary&lt;/a&gt;：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;总长度&lt;/li&gt;\n&lt;li&gt;整数位数（可以为负数，见例子）&lt;/li&gt;\n&lt;li&gt;量化模式&lt;/li&gt;\n&lt;li&gt;溢出饱和位数量&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;复合数据类型\&#34;&gt;复合数据类型&lt;/h2&gt;\n&lt;h3 id=\&#34;struct\&#34;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;默认成员是分解的。&lt;strong&gt;结构体的数组实现为多个数组&lt;/strong&gt;，结构体的每个成员都有一个单独的数组。&lt;/li&gt;\n&lt;li&gt;利用pragma指令控制是否分解。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;enum\&#34;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;略&lt;/p&gt;\n&lt;h3 id=\&#34;unions\&#34;&gt;&lt;code&gt;unions&lt;/code&gt;&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;HLS综合并不保证使用相同的内存或者寄存器&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;类型限定符\&#34;&gt;类型限定符&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;：\n&lt;ul&gt;\n&lt;li&gt;综合不会进行优化&lt;/li&gt;\n&lt;li&gt;Arbitrary precision types do not support the volatile qualifier（计算时候）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;static&lt;/code&gt;：\n&lt;ul&gt;\n&lt;li&gt;RTL等价是寄存器、触发器和内存。&lt;/li&gt;\n&lt;li&gt;config_rtl 需要配置，不然默认复位不会初始化。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;const&lt;/code&gt;：\n&lt;ul&gt;\n&lt;li&gt;常量或者ROM&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;全局变量\&#34;&gt;全局变量&lt;/h2&gt;\n&lt;p&gt;自由使用，但是只存在该ip核内部。&lt;/p&gt;\n&lt;h2 id=\&#34;指针\&#34;&gt;指针&lt;/h2&gt;\n&lt;p&gt;可以综合，但尽量避免使用。尤其是以下情况：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;同一个函数中，一个指针被读写多次&lt;/li&gt;\n&lt;li&gt;指针类型转换仅限C/C++标准类型&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;接口处使用指针top函数的参数中\&#34;&gt;接口处使用指针（top函数的参数中）&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;基本指针：\n&lt;ul&gt;\n&lt;li&gt;指针可以合成为一个简单的&lt;strong&gt;线接口&lt;/strong&gt;或使用握手的接口协议。&lt;/li&gt;\n&lt;li&gt;要合成一个FIFO接口，指针必须是只读或只写的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;指针运算：\n&lt;ul&gt;\n&lt;li&gt;不能实现，不能实现无序访问。&lt;/li&gt;\n&lt;li&gt;需要变成数组，用RAM实现。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;流数据\n&lt;ul&gt;\n&lt;li&gt;C++ 编译器可能会优化指针的访问，所以需要加volatile。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;pointer_stream_good.h&amp;quot;\n\nvoid pointer_stream_good ( volatile dout_t *d_o,  volatile din_t *d_i) {\n din_t acc = 0;\n\n acc += *d_i;\n acc += *(d_i+1);\n *d_o = acc;\n acc += *(d_i+2);\n acc += *(d_i+3);\n *(d_o+1) = acc;\n} \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;vector类型\&#34;&gt;Vector类型&lt;/h2&gt;\n&lt;h3 id=\&#34;hls的vector类型是为了simd操作\&#34;&gt;HLS的Vector类型是为了SIMD操作&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;single-instruction multiple-data (SIMD)： 单指令，多数据。&lt;/li&gt;\n&lt;li&gt;Vitis HLS提供的一个模版类型&lt;code&gt;hls::vector&amp;lt;T, N&amp;gt;&lt;/code&gt;: 一个有N个T类型的元素，T必须重载了数学运算。&lt;/li&gt;\n&lt;li&gt;最佳性能是在&lt;strong&gt;T的位宽&lt;/strong&gt;和&lt;strong&gt;N的值&lt;/strong&gt;均为2的幂时。&lt;/li&gt;\n&lt;li&gt;在&lt;code&gt;hls::vector&lt;/code&gt;上的运算操作都会被并行化，所以矩阵运算一般使用这个。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;lt;hls_vector.h&amp;gt;\nhls::vector&amp;lt;T,N&amp;gt;  aVec;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;vector-内存布局\&#34;&gt;Vector 内存布局&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Vctor储存是对齐到2的n次方的。所以性能最好的时候是大小和位宽都为2的幂的时候。&lt;/li&gt;\n&lt;li&gt;实现方式如下：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;constexpr size_t gp2(size_t N)\n{\n    return (N &amp;gt; 0 &amp;amp;&amp;amp; N % 2 == 0) ? 2 * gp2(N / 2) : 1;\n}\n \ntemplate&amp;lt;typename T, size_t N&amp;gt; class alignas(gp2(sizeof(T) * N)) vector\n{\n    std::array&amp;lt;T, N&amp;gt; data;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;c类和模版\&#34;&gt;C++类和模版&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;类是完全支持的。&lt;/li&gt;\n&lt;li&gt;不建议在类中使用全局变量，会阻碍优化&lt;/li&gt;\n&lt;li&gt;模版是支持的。但不能作为顶层函数。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;断言\&#34;&gt;断言&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;断言可以用在综合中，提供范围的信息。如循环上限等。（不像tripcount 只能用于分析）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;高性能hls\&#34;&gt;高性能HLS&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;是最大程度地减少对顶层函数参数的访问。&lt;/li&gt;\n&lt;li&gt;在阵列中设置默认值会花费时钟周期和性能。&lt;/li&gt;\n&lt;li&gt;多次读取和重新读取数据会消耗时钟周期和性能。&lt;/li&gt;\n&lt;li&gt;以任意或随机访问方式访问数据要求将数据存储在本地数组中，浪费资源。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;确保数据的连续流和数据重用\&#34;&gt;确保数据的连续流和数据重用&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;将数据从CPU或系统内存传输到FPGA，则通常会以&lt;strong&gt;流传输方式&lt;/strong&gt;进行传输。从FPGA传输回系统的数据也应以这种方式执行。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;hls::stream&lt;/code&gt; , 顺序访问，表现为一个无限深度的FIFO。&lt;/li&gt;\n&lt;li&gt;在CPU体系结构中，通常避免有条件或分支操作。当程序需要分支时，它将丢失存储在CPU提取管线中的所有指令。&lt;strong&gt;在FPGA体系结构中，每个条件分支的硬件中已经存在一条单独的路径，并且不会与流水线任务内部的分支相关的性能下降。这只是选择要使用哪个分支的一种情况。&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html\&#34;&gt;HLS Pragmas&lt;/a&gt;的使用。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;vitis-hls-coding-styles&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;参考Xilinx文档，&lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/vitis_hls_coding_styles.html\&#34;&gt;Vitis HLS Coding Styles&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Vitis HLS Coding Styles&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Verilog&#34;,&#34;slug&#34;:&#34;oen4TO7lh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/oen4TO7lh/&#34;},{&#34;name&#34;:&#34;HLS&#34;,&#34;slug&#34;:&#34;pm9HjSOZ32&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/pm9HjSOZ32/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2021-01-04 16:57:57&#34;,&#34;dateFormat&#34;:&#34;2021-01-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/vitis-hls-coding-styles/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;16 min read&#34;,&#34;time&#34;:942000,&#34;words&#34;:3533,&#34;minutes&#34;:16},&#34;description&#34;:&#34;参考Xilinx文档，Vitis HLS Coding Styles\n\n不支持的C/C++部分\n系统调用\n\nprintf()， fprintf(stdout,)等不会影响算法执行的系统调用——忽略掉。\ngetc(), time(), sle...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84cc%E9%83%A8%E5%88%86\&#34;&gt;不支持的C/C++部分&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\&#34;&gt;系统调用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98\&#34;&gt;动态内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%99%90%E5%88%B6\&#34;&gt;指针的一些限制&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E7%94%A8%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\&#34;&gt;通用指针类型转换&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84\&#34;&gt;指针数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88\&#34;&gt;函数指针&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0\&#34;&gt;递归函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#stl\&#34;&gt;STL&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0\&#34;&gt;函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\&#34;&gt;内联函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%BD%B1%E5%93%8D\&#34;&gt;代码风格的影响&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cc%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\&#34;&gt;C/C++内置函数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AA%E7%8E%AF\&#34;&gt;循环&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E8%8C%83%E5%9B%B4\&#34;&gt;循环变量范围&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%86%E5%BE%AA%E7%8E%AF%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8C%96\&#34;&gt;将循环流水线化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97\&#34;&gt;不完美的循环嵌套&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AA%E7%8E%AF%E5%B9%B6%E8%A1%8C\&#34;&gt;循环并行&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96\&#34;&gt;循环依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8c%E7%B1%BB%E4%B8%AD%E4%B8%8D%E4%BC%9A%E5%B1%95%E5%BC%80%E5%BE%AA%E7%8E%AF\&#34;&gt;在c++类中不会展开循环&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84\&#34;&gt;数组&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E8%AE%BF%E9%97%AE%E5%92%8C%E6%80%A7%E8%83%BD\&#34;&gt;数组访问和性能&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#fifo%E8%AE%BF%E9%97%AE\&#34;&gt;FIFO访问&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E4%B8%8A%E7%9A%84%E6%95%B0%E7%BB%84top%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\&#34;&gt;接口上的数组（top函数参数）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96\&#34;&gt;数组初始化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AArom\&#34;&gt;实例化一个ROM&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;数据类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#cc-%E7%B1%BB%E5%9E%8B\&#34;&gt;C/C++ 类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arbitrary-precision-ap-data-types-%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;Arbitrary Precision (AP) Data Types 任意精度数据类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E7%82%B9%E6%95%B0-arbitrary-precision-fixed-point-data-types\&#34;&gt;定点数 Arbitrary Precision Fixed-Point Data Types&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;复合数据类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#struct\&#34;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#enum\&#34;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#unions\&#34;&gt;&lt;code&gt;unions&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6\&#34;&gt;类型限定符&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\&#34;&gt;全局变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E9%92%88\&#34;&gt;指针&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A5%E5%8F%A3%E5%A4%84%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88top%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AD\&#34;&gt;接口处使用指针（top函数的参数中）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vector%E7%B1%BB%E5%9E%8B\&#34;&gt;Vector类型&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#hls%E7%9A%84vector%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%BA%E4%BA%86simd%E6%93%8D%E4%BD%9C\&#34;&gt;HLS的Vector类型是为了SIMD操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vector-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\&#34;&gt;Vector 内存布局&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#c%E7%B1%BB%E5%92%8C%E6%A8%A1%E7%89%88\&#34;&gt;C++类和模版&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%AD%E8%A8%80\&#34;&gt;断言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%AB%98%E6%80%A7%E8%83%BDhls\&#34;&gt;高性能HLS&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A1%AE%E4%BF%9D%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%B5%81%E5%92%8C%E6%95%B0%E6%8D%AE%E9%87%8D%E7%94%A8\&#34;&gt;确保数据的连续流和数据重用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;对例子中的语法等的一点记录&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;背景介绍\&#34;&gt;背景介绍&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;HLS&lt;/strong&gt; (high-level synthesis)： 高级综合, 用 C/C++为FPGA开发 RTL IP.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Vitis HLS&lt;/strong&gt;:  在Vivado 2020版本中替代原先的Vivado HLS, 功能略有差异，在Vivado HLS中的例子直接在Vitis HLS上跑会报错。详细比较见&lt;a href=\&#34;https://cloud.tencent.com/developer/article/1745199\&#34;&gt;Vivado HLS和Vitis HLS什么区别？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;HLS中的pragma语法&lt;/strong&gt;: &lt;a href=\&#34;https://www.xilinx.com/html_docs/xilinx2020_2/vitis_doc/hls_pragmas.html\&#34;&gt;HLS Pragmas&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;内容\&#34;&gt;内容&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;#pragma HLS dataflow&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;默认情况下，Vitis HLS工具试图最小化延迟并提高并发性。但是，数据依赖性可能会限制这一点。DATAFLOW优化使&lt;strong&gt;函数或循环中的操作能够在上一个函数或循环完成其所有操作之前开始操作&lt;/strong&gt;。（能够分析更细）。&lt;/li&gt;\n&lt;li&gt;也能够解决两个不依赖循环不并行情况（类似于封装进函数）。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;void diamond(data_t vecIn[N], data_t vecOut[N])\n{\n  data_t c1[N], c2[N], c3[N], c4[N];\n#pragma HLS dataflow\n  funcA(vecIn, c1, c2);\n  funcB(c1, c3);\n  funcC(c2, c4);\n  funcD(c3, c4, vecOut);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609835551513.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;#pragma HLS pipeline rewind&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;构造一个连续循环的流水线。两次循环之间没有暂停。&lt;/li&gt;\n&lt;li&gt;不能包含条件分支 (if-else)&lt;/li&gt;\n&lt;li&gt;只支持循环，不支持函数的流水线化。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;  for (int i = 0; i &amp;lt; N; i++)\n  {\n#pragma HLS pipeline rewind\n#pragma HLS unroll factor = 2\n    data_t t = in[i] * 3;\n    out1[i] = t;\n    out2[i] = t;\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;#pragma HLS unroll factor = 2&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;将循环展开多少次&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;for(int i = 0; i &amp;lt; X; i++) {\n  pragma HLS unroll factor=2\n  a[i] = b[i] + c[i];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变成：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;for(int i = 0; i &amp;lt; X; i += 2) {\n  a[i] = b[i] + c[i];\n  if (i+1 &amp;gt;= X) break;\n  a[i+1] = b[i+1] + c[i+1];\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;#pragma HLS function_instantiate variable=&amp;lt;variable&amp;gt;&lt;/code&gt;\n&lt;ul&gt;\n&lt;li&gt;FUNCTION_INSTANTIATE编译指示用于为函数的每个实例创建唯一的RTL实现，从而可以根据函数调用对每个实例进行本地优化。因为：调用函数时，&lt;strong&gt;函数的某些输入可以是恒定值&lt;/strong&gt;，并使用它来简化周围的控制结构并&lt;strong&gt;生成更小的&lt;/strong&gt;，&lt;strong&gt;更优化的功能块&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;variable&lt;/code&gt;是必需的参数，用于定义要用作常量的函数参数。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;char foo(char inval, char incr) {\n#pragma HLS INLINE OFF\n#pragma HLS FUNCTION_INSTANTIATE variable=incr\n return inval + incr;\n}\n\nvoid top(char inval1, char inval2, char inval3,\n char *outval1, char *outval2, char *outval3)\n{\n *outval1 = foo(inval1,   0);\n *outval2 = foo(inval2,   1);\n *outval3 = foo(inval3, 100);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;不完美的循环(imperfect loop)&lt;/strong&gt;:\n&lt;ul&gt;\n&lt;li&gt;内层循环上限是一个变量。&lt;/li&gt;\n&lt;li&gt;循环体并非全部在最里层循环中。&lt;/li&gt;\n&lt;li&gt;所以&lt;strong&gt;没法展开&lt;/strong&gt;，会造成额外的进出循环的时钟周期。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;    LOOP_I:for(i=0; i &amp;lt; 20; i++){\n        acc = 0;\n        LOOP_J: for(j=0; j &amp;lt; 20; j++){\n            acc += A[j] * j;\n        }\n        if (i%2 == 0)\n            B[i] = acc / 20;\n        else\n            B[i] = 0;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;将不完美循环改写成完美循环的trick：&lt;strong&gt;使用条件语句&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;    LOOP_I:for(i=0; i &amp;lt; 20; i++){\n        LOOP_J: for(j=0; j &amp;lt; 20; j++){\n            if(j==0) acc = 0;\n            acc += A[j] * j;\n            if(j==19) {\n                if (i%2 == 0)\n                    B[i] = acc / 20;\n                else\n                    B[i] = 0;\n            }\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;循环可以没有label，HLS会生成默认label。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;循环上限为变量的优化方法： &lt;strong&gt;使用条件语句&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;  LOOP_X:for (x=0;x&amp;lt;N-1; x++) {\n    if (x&amp;lt;width) {\n      out_accum += A[x];\n    }\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;可以利用两个独立的模块来压缩流水的II （用模版实现较为方便，需要配合上多路选择器）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;//                    +--proc--&amp;gt;[ II=2 ]--+\n//                   /                     \\               \n// in --&amp;gt;[demux II=1]                       [mux II=1]---&amp;gt; out\n//                   \\                     /\n//                    +--proc--&amp;gt;[ II=2 ]--+\n\n#include &amp;quot;example.h&amp;quot;\n\n//--------------------------------------------\ntemplate &amp;lt;int ID&amp;gt;\nvoid proc(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; &amp;amp;out)\n{\n    for (int i = 0; i &amp;lt; 25; i++)\n    {\n#pragma HLS PIPELINE II=2\n#pragma HLS LATENCY min=2 max=2\n        int var;\n        in.read(var);\n        out.write(var);\n    }\n}\n\n//--------------------------------------------\nvoid mux(stream&amp;lt;int&amp;gt; (&amp;amp;inter)[2], stream&amp;lt;int&amp;gt; &amp;amp;mux_output)\n{\n    int mux_sel = 0;\n    for (int i = 0; i &amp;lt; 50; i++)\n    {\n#pragma HLS PIPELINE II=1\n        int var;\n        inter[mux_sel].read(var);\n        mux_output.write(var);\n        mux_sel = (mux_sel == 0) ? (1) : (0);\n    }\n}\n\n//--------------------------------------------\nvoid demux(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; (&amp;amp;inter)[2])\n{\n    int demux_sel = 0;\n    for (int i = 0; i &amp;lt; 50; i++)\n    {\n#pragma HLS PIPELINE II=1\n\n        int var;\n        in.read(var);\n        inter[demux_sel].write(var);\n        demux_sel = (demux_sel == 0) ? 1 : 0;\n    }\n}\n\nvoid example(stream&amp;lt;int&amp;gt; &amp;amp;in, stream&amp;lt;int&amp;gt; &amp;amp;out)\n{\n#pragma HLS DATAFLOW\n\n    stream&amp;lt;int&amp;gt; inter[2];\n    stream&amp;lt;int&amp;gt; mux_in[2];\n\n#pragma HLS STREAM variable = inter depth = 16\n#pragma HLS STREAM variable = mux_in depth = 16\n\n    demux(in, inter);\n    proc&amp;lt;0&amp;gt;(inter[0], mux_in[0]);\n    proc&amp;lt;1&amp;gt;(inter[1], mux_in[1]);\n    mux(mux_in, out);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;对例子中的语法等的一点记录&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Vitis HLS 的Tiny Tutorial部分代码分析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Verilog&#34;,&#34;slug&#34;:&#34;oen4TO7lh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/oen4TO7lh/&#34;},{&#34;name&#34;:&#34;HLS&#34;,&#34;slug&#34;:&#34;pm9HjSOZ32&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/pm9HjSOZ32/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2021-01-04 14:15:07&#34;,&#34;dateFormat&#34;:&#34;2021-01-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/vitis-hls-de-tiny-tutorial-bu-fen-dai-ma-fen-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:291000,&#34;words&#34;:997,&#34;minutes&#34;:5},&#34;description&#34;:&#34;对例子中的语法等的一点记录\n\n背景介绍\n\nHLS (high-level synthesis)： 高级综合, 用 C/C++为FPGA开发 RTL IP.\nVitis HLS:  在Vivado 2020版本中替代原先的Vivado HLS...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D\&#34;&gt;背景介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AE%B9\&#34;&gt;内容&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609601219382.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;2020年的一月那么近又那么远\&#34;&gt;2020年的一月，那么近又那么远&lt;/h1&gt;\n&lt;p&gt;2020年跨年这一天，乡村教师吉返回北京，和被无数考试摧残的臭第一次跨年+参加学校的跨年晚会~&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609590165354.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;新新廿廿&lt;/strong&gt;的2020来啦&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609590219882.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那时的我们还不知道2020会是一团糟🙊🙉🙈&lt;/p&gt;\n&lt;br&gt;\n&lt;p&gt;回新津(恰好错过了途径武汉的火车)，一起去看望了水吉妈妈家的小泰迪~🐶🐶🐶&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609592085383.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;二月三月家里蹲\&#34;&gt;二月三月家里蹲&lt;/h1&gt;\n&lt;p&gt;一月末，疫情开始严重起来了。我们就只能骑着小电驴在两个家间穿梭，一三五在臭臭家，二四六在水吉家。就这样开开心心地度过了两个月~(监管最严格的时候甚至只能在超市碰头....)&lt;/p&gt;\n&lt;p&gt;情人节的礼物是山地玫瑰！&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609591290870.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;还有小相机~ 这样坏记性的水吉就能够记录下更多在一起的美好回忆啦~&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609592821850.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;当然还有：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;在家里一起吃火锅&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609593178211.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;一起穿睡衣一起刷剧一起比心&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609593229660.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;一起泡jio&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609593307478.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;一起尬舞，第一次也是唯一的一次两个人同时MEGASTAR&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609594381621.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;一起玩耍&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609593946953.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;一起做饭&lt;/strong&gt;&lt;br&gt;\n都被吃掉了，没有图了😂&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;四月五月深圳happy\&#34;&gt;四月五月深圳happy&lt;/h1&gt;\n&lt;p&gt;四月五月，水吉的哥哥让水吉去深圳帮忙，我也一并去蹭吃蹭喝:)🍎🍖🍗🍤🍨🍡🍜&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;吃&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595003396.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;吃&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595010299.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;做饭，然后吃&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595046890.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;再做饭，然后吃&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595058832.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;最后在办公室插满了水吉喜欢的花花~&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595105586.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;六月七月是分开的两个月\&#34;&gt;六月七月是分开的两个月&lt;/h1&gt;\n&lt;p&gt;疫情控制住了，乡村女教师吉吉水结束了网上上课，又回到了山西，成为了落水河最强的地理老师！&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;唯一的约会地点是召唤师峡谷&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595665922.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;水吉给家里买了一堆肉肉~&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595729442.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;八月-老司机嘟嘟嘟\&#34;&gt;八月 老司机嘟嘟嘟&lt;/h1&gt;\n&lt;p&gt;水吉回来啦！我们也开始学车车！科一我们都考了一样的分数~&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;嘟嘟嘟，开车啦&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609595988555.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;也去了广安的猫猫咖啡厅，不过还有人抽烟....&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596042550.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;九月-返校吃吃吃\&#34;&gt;九月 返校吃吃吃&lt;/h1&gt;\n&lt;p&gt;八月末终于可以返校了，水吉爸爸去西藏玩啦，可怜吉只好住在我家。白天学车做饭，晚上和妈妈一起刷剧，最后惊险通过科二， 而我在学校吃吃吃吃吃吃吃🤤🤤🤤&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;半年多没有浇水的肉肉们&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596722960.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n水吉送的肉肉们竟然基本还是好好的，除了实验室的那个小个子顶不住了~&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596772512.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;和室友返校第一餐&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596564140.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;返校后和大家吃吃吃&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596800689.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596808591.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596818858.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;水吉回来啦，去水吉最喜欢的重八~&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609596866823.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;十月-出游-生日和桌游\&#34;&gt;十月 出游、生日和桌游&lt;/h1&gt;\n&lt;p&gt;每年十月，都是天高气爽的好日子，非常适合出去玩。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;再爬蟒山&lt;s&gt;大爷&lt;/s&gt;小弟&lt;/strong&gt;&lt;br&gt;\n今天的十一又去了蟒山，蟒山大爷似乎今年格外的矮小，一会就登顶啦！&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597594730.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;去野鸭湖！&lt;/strong&gt;&lt;br&gt;\n担任小学期助教的意外之喜，秋天的野鸭湖真的好漂亮~&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597706914.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597713248.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597735946.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;臭臭的生日&lt;/strong&gt;&lt;br&gt;\n这一天，水吉因为有篮球比赛早早离开啦~和大为、sff在宿舍快乐嚯奶茶，开心卡卡颂！&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597802417.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;提前送给水吉的生日礼物&lt;/strong&gt;&lt;br&gt;\n今年送给水吉的礼物是一个能够放进书包的itx主机~老夫老妻了，早送早享受💻从此水吉的0-12快乐提莫再也不能找电脑卡的理由了hhhhhhhhh&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609597946418.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;桌游、桌游！&lt;/strong&gt;&lt;br&gt;\n今年是水吉爱玩的一年，从塞尔达到卡卡颂、卡坦岛，水吉玩个不停！&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609598264941.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n（被迫加入游戏的我）&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;十一-十二月-吃吃吃和水吉的生日\&#34;&gt;十一、十二月 吃吃吃和水吉的生日&lt;/h1&gt;\n&lt;p&gt;今年的冬天格外的冷，所以涮肉要吃起来啊！&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;听说，初雪和涮肉更配哦&lt;/strong&gt;&lt;br&gt;\n初雪，我们去了四道口最好吃的涮肉，排队到了下午两点.....&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609598677322.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;繁忙的十二月，我们终于在五道口找了一家咖啡厅&lt;/strong&gt;&lt;br&gt;\n今年因为校园封闭，不能再到校园里面来学习了，经过几番辗转，终于在五道口找到了新的落脚之地，又可以一起学习了。&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609598757515.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;圣诞——水吉的生日&lt;/strong&gt;&lt;br&gt;\n和水吉以及水吉的室友们一起吃饭唱K，没错我就是K歌之王&lt;sub&gt;(的老公)&lt;/sub&gt;。&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609600194043.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;br&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;再次封校前的最后一次见面&lt;/strong&gt;&lt;br&gt;\n学校又要封闭了，赶在最后一天和水吉见了一面，还吃了小宇哥推荐的好吃串串！（当天因为寒冷变成胆小菇的我↓）&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609600950737.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;2021\&#34;&gt;2021💑💏&lt;/h1&gt;\n&lt;p&gt;新的一年，2021🐛🐛🐛啊！&lt;/p&gt;\n&lt;p&gt;好像没啥好说的了，那 &lt;strong&gt;最后祝大家身体健康!!科研有成!!&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wu-zhou-nian-la&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609601219382.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;👨👩💏五周年啦~🥂🍻&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;随便写写&#34;,&#34;slug&#34;:&#34;xMGkC-iLRF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/xMGkC-iLRF/&#34;}],&#34;date&#34;:&#34;2021-01-03 00:00:00&#34;,&#34;dateFormat&#34;:&#34;2021-01-03&#34;,&#34;feature&#34;:&#34;https://Busy-Bob.github.io/post-images/wu-zhou-nian-la.jpg&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/wu-zhou-nian-la/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:230000,&#34;words&#34;:1138,&#34;minutes&#34;:4},&#34;description&#34;:&#34;2021-1-3： 水吉和臭臭五周年啦！\n\n\n2020年的一月，那么近又那么远\n2020年跨年这一天，乡村教师吉返回北京，和被无数考试摧残的臭第一次跨年+参加学校的跨年晚会~\n\n新新廿廿的2020来啦\n\n那时的我们还不知道2020会是一团糟...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#2020%E5%B9%B4%E7%9A%84%E4%B8%80%E6%9C%88%E9%82%A3%E4%B9%88%E8%BF%91%E5%8F%88%E9%82%A3%E4%B9%88%E8%BF%9C\&#34;&gt;2020年的一月，那么近又那么远&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E6%9C%88%E4%B8%89%E6%9C%88%E5%AE%B6%E9%87%8C%E8%B9%B2\&#34;&gt;二月三月家里蹲&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B%E6%9C%88%E4%BA%94%E6%9C%88%E6%B7%B1%E5%9C%B3happy\&#34;&gt;四月五月深圳happy&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AD%E6%9C%88%E4%B8%83%E6%9C%88%E6%98%AF%E5%88%86%E5%BC%80%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%88\&#34;&gt;六月七月是分开的两个月&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%AB%E6%9C%88-%E8%80%81%E5%8F%B8%E6%9C%BA%E5%98%9F%E5%98%9F%E5%98%9F\&#34;&gt;八月 老司机嘟嘟嘟&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B9%9D%E6%9C%88-%E8%BF%94%E6%A0%A1%E5%90%83%E5%90%83%E5%90%83\&#34;&gt;九月 返校吃吃吃&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%81%E6%9C%88-%E5%87%BA%E6%B8%B8-%E7%94%9F%E6%97%A5%E5%92%8C%E6%A1%8C%E6%B8%B8\&#34;&gt;十月 出游、生日和桌游&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%81%E4%B8%80-%E5%8D%81%E4%BA%8C%E6%9C%88-%E5%90%83%E5%90%83%E5%90%83%E5%92%8C%E6%B0%B4%E5%90%89%E7%9A%84%E7%94%9F%E6%97%A5\&#34;&gt;十一、十二月 吃吃吃和水吉的生日&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2021\&#34;&gt;2021💑💏&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;\&#34;&gt;&lt;a href=\&#34;https://www.zhihu.com/question/280468724/answer/517329473\&#34;&gt;&lt;strong&gt;FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;并行计算，比如每个步骤没有关连性的循环操作；&lt;/li&gt;\n&lt;li&gt;算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；&lt;/li&gt;\n&lt;li&gt;乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；&lt;/li&gt;\n&lt;li&gt;一些特定的矩阵运算。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;-2\&#34;&gt;&lt;a href=\&#34;https://www.zhihu.com/question/24174597/answer/138717507\&#34;&gt;&lt;strong&gt;如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 为什么快？「都是同行衬托得好」。&lt;strong&gt;CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存&lt;/strong&gt;，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，&lt;strong&gt;不需要指令&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;计算密集型任务&lt;/strong&gt;(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当&lt;/li&gt;\n&lt;li&gt;浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。&lt;/li&gt;\n&lt;li&gt;在数据中心，FPGA 相比 GPU 的核心优势在于&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;FPGA 同时拥有&lt;strong&gt;流水线并行和数据并行&lt;/strong&gt;，而 GPU 几乎只有数据并行（流水线深度受限）。&lt;/li&gt;\n&lt;li&gt;数据中心的计算任务是&lt;strong&gt;灵活多变&lt;/strong&gt;的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;通信密集型任务&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。&lt;/li&gt;\n&lt;li&gt;网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;只要规模足够大，对 FPGA 价格过高的担心将是不必要的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。&lt;strong&gt;如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态&lt;/strong&gt;。这时就不如用冯·诺依曼结构的处理器。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 和 CPU 协同工作，&lt;strong&gt;局部性和重复性强的归 FPGA，复杂的归 CPU&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;-3\&#34;&gt;&lt;a href=\&#34;https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf\&#34;&gt;&lt;strong&gt;将浮点转为定点大幅降低功耗和成本 - Xilinx&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。&lt;/li&gt;\n&lt;li&gt;对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;浮点转换为定点的优势&lt;/strong&gt;:\n&lt;ul&gt;\n&lt;li&gt;减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）&lt;/li&gt;\n&lt;li&gt;功耗更低&lt;/li&gt;\n&lt;li&gt;材料成本降低&lt;/li&gt;\n&lt;li&gt;降低时延&lt;/li&gt;\n&lt;li&gt;相近的性能和精度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;fpga-yong-lai-jia-su-yun-suan-de-diao-yan&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;FPGA用来加速运算的调研&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2021-01-02 13:53:42&#34;,&#34;dateFormat&#34;:&#34;2021-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:202000,&#34;words&#34;:963,&#34;minutes&#34;:4},&#34;description&#34;:&#34;FPGA用来加速运算的调研.😁\n\nFPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎\n\n并行计算，比如每个步骤没有关连性的循环操作；\n算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 &lt;strong&gt;处理器&lt;/strong&gt;和一个传统的现场可编程门阵列（Field Programmable Gate Array，&lt;strong&gt;FPGA&lt;/strong&gt;）逻辑部件。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了&lt;strong&gt;高带宽、低延迟&lt;/strong&gt;的连接。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而&lt;strong&gt;不会有&lt;/strong&gt;在两个分立的芯片之间的那种&lt;strong&gt;接口开销&lt;/strong&gt;。同时又能获得系统被简化为单一芯片所带来的好处，包括&lt;strong&gt;物理尺寸&lt;/strong&gt;和整体&lt;strong&gt;成本的降低&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;什么是片上系统/SoC (System on Chip)&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。&lt;/li&gt;\n&lt;li&gt;常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）&lt;/li&gt;\n&lt;li&gt;和板上系统(在pcb板中组合多个元件)对比。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：\n&lt;ul&gt;\n&lt;li&gt;开发时间和成本&lt;/li&gt;\n&lt;li&gt;难以重用，不够灵活（与FPGA不同，直接设计芯片设计）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：手机，PC，平板等的CPU&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;处理系统（PS）：支持软件程序和/ 或操作系统&lt;/li&gt;\n&lt;li&gt;可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统&lt;/li&gt;\n&lt;li&gt;工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609400781987.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;软硬件系统关系&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609401050095.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;the-zynq-book-xue-xi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;The Zynq Book 学习： 引言&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;zynq&#34;,&#34;slug&#34;:&#34;VR993R9Vz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/VR993R9Vz/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2020-12-31 15:25:06&#34;,&#34;dateFormat&#34;:&#34;2020-12-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:81000,&#34;words&#34;:375,&#34;minutes&#34;:2},&#34;description&#34;:&#34;学习The Zynq Book第一章时的一些笔记\n\n\n\nZynq 的本质特征，是它组合了一个双核ARM Cortex-A9 处理器和一个传统的现场可编程门阵列（Field Programmable Gate Array，FPGA）逻辑部件。...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;总体架构图为：&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609385485651.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;PS (Processing System)中对外通信管脚:&lt;/strong&gt;：\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;MIO&lt;/strong&gt; (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt; (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在&lt;strong&gt;约束文件中分配管脚&lt;/strong&gt;，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;em&gt;当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即&lt;strong&gt;PS可以利用EMIO和PL进行通信&lt;/strong&gt;)&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;**PL (Programmable Logic) 和 PS的通信接口 **&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609403066047.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;通用AXI（General Purpose AXI）&lt;/strong&gt;： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的&lt;strong&gt;中低速通信&lt;/strong&gt;。接口是透传的不带缓冲。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;加速器一致性端口（Accelerator Coherency Port）&lt;/strong&gt;： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;高性能端口（High Performance Ports）&lt;/strong&gt;： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。&lt;strong&gt;(PL直接从DDR中获取数据)&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt;： 原本是用来连接I2C等协议的外设，也可以给PS使用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;pynq中python类对应\&#34;&gt;PYNQ中python类对应：&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;GPIO&lt;/strong&gt;： 对应MIO， EMIO。（类似于单片机中的GPIO）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;MMIO&lt;/strong&gt;： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Xlnk&lt;/strong&gt;： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;DMA&lt;/strong&gt;： 对应HP AXI，访问DMA，即高性能AXI端口&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;axi-协议\&#34;&gt;AXI 协议&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。&lt;/li&gt;\n&lt;li&gt;AXI4_LITE： 只支持每次连接传输一个数据（非批量）。&lt;/li&gt;\n&lt;li&gt;AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;zynq-zhong-de-si-chong-tong-xin-jie-kou__&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;ZYNQ中的通信接口(包括PS与PL)&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;zynq&#34;,&#34;slug&#34;:&#34;VR993R9Vz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/VR993R9Vz/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2020-12-31 10:45:05&#34;,&#34;dateFormat&#34;:&#34;2020-12-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:139000,&#34;words&#34;:608,&#34;minutes&#34;:3},&#34;description&#34;:&#34;总体架构图为：\n\n\nPS (Processing System)中对外通信管脚:：\n\nMIO (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#pynq%E4%B8%ADpython%E7%B1%BB%E5%AF%B9%E5%BA%94\&#34;&gt;PYNQ中python类对应：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#axi-%E5%8D%8F%E8%AE%AE\&#34;&gt;AXI 协议&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;flash-原理\&#34;&gt;Flash 原理：&lt;/h2&gt;\n&lt;p&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609254997519.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609253806308.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n参考&lt;a href=\&#34;https://www.youtube.com/watch?v=aO_kBa9DzPQ\&#34;&gt;youtube&lt;/a&gt;。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。&lt;/p&gt;\n&lt;h2 id=\&#34;nand-flash-和-nor-flash-区别\&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609253097307.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;NAND 不能够取指令（类似于硬盘）&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;NOR 可以取指令（类似于内存）&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;由于CPU运行时候需要三步：&lt;strong&gt;取指、译码、执行&lt;/strong&gt; 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。&lt;/p&gt;\n&lt;h2 id=\&#34;应用场景\&#34;&gt;应用场景&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;ssd和u盘区别\&#34;&gt;SSD和U盘区别&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的&lt;br&gt;\n主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么&lt;br&gt;\n存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发&lt;br&gt;\n接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快&lt;/p&gt;\n&lt;p&gt;作者：李诗华&lt;br&gt;\n链接：https://www.zhihu.com/question/265335741/answer/292414149&lt;br&gt;\n来源：知乎&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;nand-flash-nor-flash&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;NAND Flash, NOR Flash 的区别和应用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Flash&#34;,&#34;slug&#34;:&#34;gtSmWzfNV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/gtSmWzfNV/&#34;},{&#34;name&#34;:&#34;NAND&#34;,&#34;slug&#34;:&#34;9Zg0ckvoQ0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9Zg0ckvoQ0/&#34;},{&#34;name&#34;:&#34;NOR&#34;,&#34;slug&#34;:&#34;7JP4e5yowm&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/7JP4e5yowm/&#34;}],&#34;date&#34;:&#34;2020-12-29 22:06:01&#34;,&#34;dateFormat&#34;:&#34;2020-12-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/nand-flash-nor-flash/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:104000,&#34;words&#34;:480,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Flash 原理：\n\n\n参考youtube。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#flash-%E5%8E%9F%E7%90%86\&#34;&gt;Flash 原理：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nand-flash-%E5%92%8C-nor-flash-%E5%8C%BA%E5%88%AB\&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;应用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ssd%E5%92%8Cu%E7%9B%98%E5%8C%BA%E5%88%AB\&#34;&gt;SSD和U盘区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;主要参考：&lt;a href=\&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074\&#34;&gt;细说Rust错误处理&lt;/a&gt; 和 &lt;a href=\&#34;https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html\&#34;&gt;Result 与可恢复的错误&lt;/a&gt;.&lt;/p&gt;\n&lt;h1 id=\&#34;tl-dr\&#34;&gt;TL; DR&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt; 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）&lt;/li&gt;\n&lt;li&gt;自定义一个&lt;code&gt;enum&lt;/code&gt;通常用在需要对错误进行恢复的时候。（容易检测类型）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;boxdyn-error-方式来聚合error\&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;fn do_something() -&amp;gt; std::result::Result&amp;lt;(),Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt;{\n    let path = &amp;quot;./dat&amp;quot;;\n    let v = std::fs::read_to_string(path)?;\n    let x = std::str::from_utf8(v.as_bytes())?;\n    let u = x.parse::&amp;lt;u32&amp;gt;()?;\n    println!(&amp;quot;num:{:?}&amp;quot;,u);\n    Ok(())\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;三者分别返回不同的错误类型，但是都可以用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来装。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;： 方便书写。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“&lt;strong&gt;反射&lt;/strong&gt;”( &lt;code&gt;Any&lt;/code&gt; trait)才能够确定。而不能直接match。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;利用-enum-来聚合error\&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;内容来自&lt;a href=\&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074\&#34;&gt;细说Rust错误处理&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;自定义一个&lt;code&gt;error&lt;/code&gt;需要实现如下几步：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Display&lt;/code&gt;的trait,并&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;fmt(...)&lt;/code&gt;方法。&lt;/li&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Debug&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;，一般直接添加注解即可：&lt;code&gt;#[derive(Debug)]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::error::Error&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;,并根据自身&lt;code&gt;error&lt;/code&gt;级别是否&lt;strong&gt;覆盖&lt;/strong&gt;&lt;code&gt;std::error::Error&lt;/code&gt;中的&lt;code&gt;source()&lt;/code&gt;方法。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面的内容中：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;为我们实现的&lt;strong&gt;自定义Error&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;有三个&lt;strong&gt;子类型Error&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;分别实现了三个&lt;strong&gt;子类型Error&lt;/strong&gt; &lt;code&gt;From&lt;/code&gt;的trait,将其类型包装为&lt;strong&gt;自定义Error&lt;/strong&gt;的子类型&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;好了，有了自定义的&lt;code&gt;CustomError&lt;/code&gt;，那怎么使用呢? 我们看代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;use std::io::Error as IoError;\nuse std::str::Utf8Error;\nuse std::num::ParseIntError;\nuse std::fmt::{Display, Formatter};\n\n\nfn main() -&amp;gt; std::result::Result&amp;lt;(),CustomError&amp;gt;{\n    let path = &amp;quot;./dat&amp;quot;;\n    let v = read_file(path)?;\n    let x = to_utf8(v.as_bytes())?;\n    let u = to_u32(x)?;\n    println!(&amp;quot;num:{:?}&amp;quot;,u);\n    Ok(())\n}\n\n///读取文件内容\nfn read_file(path: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;String, std::io::Error&amp;gt; {\n    std::fs::read_to_string(path)\n}\n\n/// 转换为utf8内容\nfn to_utf8(v: &amp;amp;[u8]) -&amp;gt; std::result::Result&amp;lt;&amp;amp;str, std::str::Utf8Error&amp;gt; {\n    std::str::from_utf8(v)\n}\n\n/// 转化为u32数字\nfn to_u32(v: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;u32, std::num::ParseIntError&amp;gt; {\n    v.parse::&amp;lt;u32&amp;gt;()\n}\n\n\n#[derive(Debug)]\nenum CustomError {\n    ParseIntError(std::num::ParseIntError),\n    Utf8Error(std::str::Utf8Error),\n    IoError(std::io::Error),\n}\nimpl std::error::Error for CustomError{\n    fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn std::error::Error + &#39;static)&amp;gt; {\n        match &amp;amp;self {\n            CustomError::IoError(ref e) =&amp;gt; Some(e),\n            CustomError::Utf8Error(ref e) =&amp;gt; Some(e),\n            CustomError::ParseIntError(ref e) =&amp;gt; Some(e),\n        }\n    }\n}\n\nimpl Display for CustomError{\n    fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; std::fmt::Result {\n        match &amp;amp;self {\n            CustomError::IoError(ref e) =&amp;gt; e.fmt(f),\n            CustomError::Utf8Error(ref e) =&amp;gt; e.fmt(f),\n            CustomError::ParseIntError(ref e) =&amp;gt; e.fmt(f),\n        }\n    }\n}\n\nimpl From&amp;lt;ParseIntError&amp;gt; for CustomError {\n    fn from(s: std::num::ParseIntError) -&amp;gt; Self {\n        CustomError::ParseIntError(s)\n    }\n}\n\nimpl From&amp;lt;IoError&amp;gt; for CustomError {\n    fn from(s: std::io::Error) -&amp;gt; Self {\n        CustomError::IoError(s)\n    }\n}\n\nimpl From&amp;lt;Utf8Error&amp;gt; for CustomError {\n    fn from(s: std::str::Utf8Error) -&amp;gt; Self {\n        CustomError::Utf8Error(s)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust 错误处理中多种类型Error传播的处理方式&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;错误处理&#34;,&#34;slug&#34;:&#34;OScMf4N1R&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/OScMf4N1R/&#34;},{&#34;name&#34;:&#34;trait object&#34;,&#34;slug&#34;:&#34;hOKrnhyJkT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hOKrnhyJkT/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;}],&#34;date&#34;:&#34;2020-12-01 15:27:56&#34;,&#34;dateFormat&#34;:&#34;2020-12-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:216000,&#34;words&#34;:741,&#34;minutes&#34;:4},&#34;description&#34;:&#34;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用Box&amp;lt;dyn std::error::Error&amp;gt;来用trait object来代表所有类型的错误；另一种是使用自定义的enum来装所有的错误。\n\n主要参考：细...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#tl-dr\&#34;&gt;TL; DR&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#boxdyn-error-%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%81%9A%E5%90%88error\&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8-enum-%E6%9D%A5%E8%81%9A%E5%90%88error\&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;基于&lt;a href=\&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches\&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;原作者的一些分析\&#34;&gt;原作者的一些分析&lt;/h1&gt;\n&lt;p&gt;基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(&lt;strong&gt;指针&lt;/strong&gt;)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;优势：&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;易于在大多数语言中实现&lt;/li&gt;\n&lt;li&gt;没有上下文切换&lt;/li&gt;\n&lt;li&gt;相对较低的内存开销(在大多数情况下)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。&lt;/li&gt;\n&lt;li&gt;很难理解。许多人已经知道这是“回调地狱”。&lt;/li&gt;\n&lt;li&gt;这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。&lt;/li&gt;\n&lt;li&gt;由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;代码\&#34;&gt;代码&lt;/h1&gt;\n&lt;p&gt;通过代码，学习到了一些新东西，主要包括：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;thread_local!&lt;/code&gt; ：用来对每一个线程初始化同一个变量的一个新的副本。&lt;/li&gt;\n&lt;li&gt;trait 对象： &lt;code&gt;Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&lt;/code&gt;,  &lt;code&gt;dyn Trait&lt;/code&gt;表示一个类型，强调是动态分发，并且必须是一个&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;\n&lt;li&gt;传递闭包可以使用&lt;code&gt;impl Trait&lt;/code&gt;，这也是一个类型，并且该类型是&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;thread::spawn&lt;/code&gt;会直接新开一个子线程运行，不会造成主线程阻塞。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;std::sync::mpsc::Receiver.iter()&lt;/code&gt; 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的&lt;code&gt;.next()&lt;/code&gt; 才会变成&lt;code&gt;None&lt;/code&gt;，否则会一直等待。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;\nfn program_main() {\n    // 第一个输出\n    println!(&amp;quot;So we start the program here!&amp;quot;);\n    // 运行到这儿的时候， 0ms\n    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。\n    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞\n    set_timeout(200, || {\n        // 第五个输出\n        println!(&amp;quot;We create tasks with a callback that runs once the task finished!&amp;quot;);\n    });\n    // 运行到这儿的时候， 仍然是0ms\n    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。\n    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞\n    set_timeout(100, || {\n        // 第三个输出\n        println!(&amp;quot;We can even chain sub-tasks...&amp;quot;);\n        set_timeout(50, || {\n            // 第四个输出\n            println!(&amp;quot;...like this!&amp;quot;);\n        })\n    });\n    // 运行到这儿的时候， 仍然是0ms\n    // 第二个输出\n    println!(&amp;quot;While our tasks are executing we can do other stuff instead of waiting.&amp;quot;);\n}\n\nfn main() {\n    RT.with(|rt| rt.run(program_main));\n}\n\nuse std::sync::mpsc::{channel, Receiver, Sender};\nuse std::{cell::RefCell, collections::HashMap, thread};\n\n\n// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本\n// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&amp;lt;Runtime&amp;gt;\n// 这儿好像只用到了一个副本\nthread_local! {\n    static RT: Runtime = Runtime::new();\n}\n\nstruct Runtime {\n    // callbacks 中的Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt; 是一个 trait 对象。 \n    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&amp;gt; u32。 \n    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。\n    callbacks: RefCell&amp;lt;HashMap&amp;lt;usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&amp;gt;&amp;gt;,\n    // 储存下一个闭包的id\n    next_id: RefCell&amp;lt;usize&amp;gt;,\n    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id\n    evt_sender: Sender&amp;lt;usize&amp;gt;,\n    // 接受下一个该运行的闭包的id\n    evt_reciever: Receiver&amp;lt;usize&amp;gt;,\n}\n\n// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &amp;quot;a concrete type that implements this trait&amp;quot;. \n// Its primary use is working with closures, which have type definitions generated at compile time that can&#39;t be simply typed out.\n// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait\n// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html\nfn set_timeout(ms: u64, cb: impl FnOnce() + &#39;static) {\n    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。\n    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。\n    // 相当于用.with()就是在使用该变量的函数。\n    RT.with(|rt| {\n        let id = *rt.next_id.borrow();\n        // next_id递增\n        *rt.next_id.borrow_mut() += 1;\n        // callbacks存 (id: usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;)\n        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知\n        // cb 在输入参数中用的impl FnOnce() + &#39;static 来限定。\n        rt.callbacks.borrow_mut().insert(id, Box::new(cb));\n        // The sending-half of Rust&#39;s asynchronous channel type. \n        // This half can only be owned by one thread, but it can be cloned to send to other threads.\n        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个\n        let evt_sender = rt.evt_sender.clone();\n        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去\n        thread::spawn(move || {\n            thread::sleep(std::time::Duration::from_millis(ms));\n            // 在延时结束后，发送当前延时结束的任务id\n            evt_sender.send(id).unwrap();\n        });\n    });\n}\n\n\nimpl Runtime {\n    fn new() -&amp;gt; Self {\n        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver\n        let (evt_sender, evt_reciever) = channel();\n        Runtime {\n            callbacks: RefCell::new(HashMap::new()),\n            next_id: RefCell::new(1),\n            evt_sender,\n            evt_reciever,\n        }\n    }\n\n    // 这儿是在运行一个函数.\n    fn run(&amp;amp;self, program: fn()) {\n        // 直接运行， \n        program();\n        // 0ms 运行到这儿\n        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。\n        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.\n        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None\n        for evt_id in &amp;amp;self.evt_reciever {\n            // 这儿直接从HashMap里remove出对应编号的闭包。\n            let cb = self.callbacks.borrow_mut().remove(&amp;amp;evt_id).unwrap();\n            cb();\n            // 是不是也不需要这句话？\n            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了\n            if self.callbacks.borrow().is_empty() {\n                break;\n            }\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&amp;quot;学歌&amp;quot;。所以，在回调逻辑中 &lt;code&gt;sing_song()&lt;/code&gt;作为闭包， &lt;code&gt;learn_song()&lt;/code&gt; 作为子线程，主线程运行&lt;code&gt;dance()&lt;/code&gt; 。子线程结束后再运行这个闭包。运行顺序是 &lt;code&gt;learn_song()&lt;/code&gt; （子线程）和 &lt;code&gt;dance()&lt;/code&gt;  （主线程）同时运行，在两个任务均完成后， 再回调&lt;code&gt;sing_song()&lt;/code&gt;这个闭包。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;子线程&lt;/strong&gt;对应 &lt;strong&gt;“等待资源”&lt;/strong&gt; ； &lt;strong&gt;闭包&lt;/strong&gt;对应“&lt;strong&gt;接收到等待资源后的操作”&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;async fn learn_and_sing() {\n    // 在唱歌之前等待学歌完成\n    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n async fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成\n     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞\n     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，\n     // 这个‘async_main&#39;函数就会变成阻塞状态，并生成一个执行器\n    futures::join!(f1, f2)\n}\n fn main() {\n    block_on(async_main());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;基于&lt;a href=\&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches\&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust 基于回调的异步方法分析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;回调&#34;,&#34;slug&#34;:&#34;dccFuZ2yD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/dccFuZ2yD/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;},{&#34;name&#34;:&#34;异步编程&#34;,&#34;slug&#34;:&#34;hDYBWTXHUV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hDYBWTXHUV/&#34;}],&#34;date&#34;:&#34;2020-11-30 16:57:43&#34;,&#34;dateFormat&#34;:&#34;2020-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:474000,&#34;words&#34;:1926,&#34;minutes&#34;:8},&#34;description&#34;:&#34;基于Futures Explained in 200 Lines of Rust文中的回调代码。\n\n原作者的一些分析\n基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E4%BD%9C%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90\&#34;&gt;原作者的一些分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81\&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;const_unit_poc-利用const-generics实现的物理单位库\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;const_unit_poc&lt;/code&gt;  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![feature(const_generics, const_evaluatable_checked)]\nuse const_unit_poc::values::{m, kg, s, N};\n\nlet distance = 1.0 * m;\nlet mass = 18.0 * kg;\nlet force = distance * mass / (1.8 * s * 2.0 * s);\nassert_eq!(force, 5.0 * N);\n\nlet mut mutable_distance = 3.2 * m;\nmutable_distance -= 0.2 * m;\nmutable_distance += 2.0 * m;\n\nassert_eq!(mutable_distance, 5.0 * m);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。&lt;/p&gt;\n&lt;h2 id=\&#34;const_unit_poc-源码分析\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![feature(const_generics, const_evaluatable_checked, doc_cfg)]\n#![allow(incomplete_features)]\n#![cfg_attr(feature = &amp;quot;non_ascii&amp;quot;, feature(non_ascii_idents))]\n\nuse std::ops;\n\npub mod units;\npub mod values;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n#[allow(non_snake_case)]\npub struct SiUnit {\n    m: i8,\n    kg: i8,\n    s: i8,\n    A: i8,\n    K: i8,\n    mol: i8,\n    cd: i8,\n}\n\n// 后面还有内容\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里引入了&lt;code&gt;units&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;两个mod，并且声明了&lt;code&gt;SiUnit&lt;/code&gt; 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。&lt;/p&gt;\n&lt;p&gt;看到这儿，笔者推测应该是使用 &lt;code&gt;SiUnit&lt;/code&gt; 这个结构体来实例化各种常用的单位（如&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），其中成员的值表示该单位表示成基本单位后的指数的值（如&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;N=m*s^{-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.46528em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8141079999999999em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8141079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;， 则&lt;code&gt;N.m == 1; N.s == -2&lt;/code&gt;）。&lt;/p&gt;\n&lt;p&gt;再看一下引入的模块&lt;code&gt;units&lt;/code&gt;的内容&lt;/p&gt;\n&lt;h3 id=\&#34;units的实现\&#34;&gt;units的实现&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs\&#34;&gt;&lt;code&gt;./src/units.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![allow(non_upper_case_globals)]\nuse super::SiUnit;\nconst NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };\n/// meter\npub const m: SiUnit = SiUnit { m: 1, ..NONE };\n/// 中间内容省略\n/// lux\npub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };\n/// square meter\npub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };\n/// cubic meter\npub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;的确和猜想一致！注意结构体实例化时候这儿使用了&lt;code&gt;..NONE&lt;/code&gt;，这是用已经创建的实例None上&lt;strong&gt;更新部分参数&lt;/strong&gt;，创建新的实例，见&lt;a href=\&#34;https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B\&#34;&gt;使用结构体更新语法从其他实例创建实例&lt;/a&gt;。这儿使用了const使得各个单位全局可见且不可变。&lt;/p&gt;\n&lt;p&gt;现在已经有了单位，但是我们注意到代码中&lt;code&gt;assert_eq!(mutable_distance, 5.0 * m);&lt;/code&gt;不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。&lt;/p&gt;\n&lt;h3 id=\&#34;对单位系数的包装\&#34;&gt;对单位系数的包装&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs\&#34;&gt;&lt;code&gt;./src/values.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![allow(non_upper_case_globals)]\nuse crate::{units, Quantity};\n// base\n/// 1 meter\npub const m: Quantity&amp;lt;{ units::m }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 1 kilogram\npub const kg: Quantity&amp;lt;{ units::kg }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 1 second\npub const s: Quantity&amp;lt;{ units::s }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 后面还有\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;use crate::{units, Quantity}&lt;/code&gt;, 代表的是导入的当前&lt;code&gt;crate&lt;/code&gt;中的&lt;code&gt;units&lt;/code&gt;和&lt;code&gt;Quantity&lt;/code&gt;。&lt;br&gt;\n&lt;strong&gt;const 泛型&lt;/strong&gt;: 从这儿的可以大概可以看出，&lt;code&gt;Quantity&lt;/code&gt;的泛型参数是一个const常量，包装每一个&lt;code&gt;units.rs&lt;/code&gt;中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：&lt;code&gt;Quantity&amp;lt;{ units::m }&amp;gt; { raw_value: 1.0 }&lt;/code&gt;。 所以是用&lt;code&gt;raw_value&lt;/code&gt;来表示每一个单位的系数。&lt;/p&gt;\n&lt;p&gt;所以再来看看&lt;code&gt;Quantity&lt;/code&gt;的定义吧。&lt;/p&gt;\n&lt;p&gt;###结构体 &lt;code&gt;Quantity&lt;/code&gt;的定义&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n#[repr(transparent)]\npub struct Quantity&amp;lt;const U: SiUnit&amp;gt; {\n    pub raw_value: f64,\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;简单干脆的使用const 类型作为泛型参数。&lt;/p&gt;\n&lt;h3 id=\&#34;加减运算\&#34;&gt;加减运算&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Add for Quantity&amp;lt;U&amp;gt; {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -&amp;gt; Self {\n        Self { raw_value: self.raw_value + rhs.raw_value }\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::AddAssign for Quantity&amp;lt;U&amp;gt; {\n    fn add_assign(&amp;amp;mut self, rhs: Self) {\n        self.raw_value += rhs.raw_value;\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::Sub for Quantity&amp;lt;U&amp;gt; {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -&amp;gt; Self {\n        Self { raw_value: self.raw_value - rhs.raw_value }\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::SubAssign for Quantity&amp;lt;U&amp;gt; {\n    fn sub_assign(&amp;amp;mut self, rhs: Self) {\n        self.raw_value -= rhs.raw_value;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于加减运算并不会变单位，所以就是对系数的加减，非常直接。&lt;/p&gt;\n&lt;h3 id=\&#34;乘除运算\&#34;&gt;乘除运算&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;一个数字与一个Quantity相乘，单位不变：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Mul&amp;lt;f64&amp;gt; for Quantity&amp;lt;U&amp;gt; {\n    type Output = Quantity&amp;lt;U&amp;gt;;\n\n    fn mul(self, rhs: f64) -&amp;gt; Self::Output {\n        Quantity { raw_value: self.raw_value * rhs }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;两个带单位的量相乘，单位发生变化，也就是&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;的泛型参数发生了变化，此时需要重新实例化一个&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;结构体：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;// Quantity相乘转换为unit相乘，UL.unit_mul(UR)\nimpl&amp;lt;const UL: SiUnit, const UR: SiUnit&amp;gt; ops::Mul&amp;lt;Quantity&amp;lt;UR&amp;gt;&amp;gt; for Quantity&amp;lt;UL&amp;gt;\nwhere\n    Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;: ,\n{\n    type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;\n\n    fn mul(self, rhs: Quantity&amp;lt;UR&amp;gt;) -&amp;gt; Self::Output {\n        Quantity { raw_value: self.raw_value * rhs.raw_value }\n    }\n}\n// unit相乘\nimpl SiUnit {\n    const fn unit_mul(self, rhs: Self) -&amp;gt; Self {\n        Self {\n            m: self.m + rhs.m,\n            kg: self.kg + rhs.kg,\n            s: self.s + rhs.s,\n            A: self.A + rhs.A,\n            K: self.K + rhs.K,\n            mol: self.mol + rhs.mol,\n            cd: self.cd + rhs.cd,\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;这儿对泛型的约束很神奇，竟然是这样写&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;:&lt;/code&gt; ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;error: unconstrained generic constant\n   --&amp;gt; src\\lib.rs:156:5\n    |\n156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     \n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     \n    |\nhelp: consider adding a `where` bound for this expression  \n   --&amp;gt; src\\lib.rs:156:28\n    |\n156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     \n    |                            ^^^^^^^^^^^^^^^^^^^     \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;&lt;/code&gt; ，否则也会出错。这在最近的&lt;a href=\&#34;https://github.com/rust-lang/rust/pull/79135\&#34;&gt;Stabilization report&lt;/a&gt;里面也有提到。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Const arguments&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, &lt;strong&gt;most expressions must be contained within a block&lt;/strong&gt;, with two exceptions:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;literals and single-segment path expressions&lt;/li&gt;\n&lt;li&gt;array lengths&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.&lt;/p&gt;\n&lt;p&gt;In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;type N = u32;\nstruct Foo&amp;lt;const N: usize&amp;gt;;\nfn foo&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;N&amp;gt; { todo!() } // ERR\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;type N = u32;\nstruct Foo&amp;lt;const N: usize&amp;gt;;\nfn bar&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;{ N }&amp;gt; { todo!() } // ok\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;p&gt;这篇文章主要是了解了const 泛型在做啥，以及如何做的。&lt;/p&gt;\n&lt;p&gt;通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;const&#34;,&#34;slug&#34;:&#34;Op9tNmAIW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/Op9tNmAIW/&#34;},{&#34;name&#34;:&#34;泛型&#34;,&#34;slug&#34;:&#34;BCk2FVrJcy&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/BCk2FVrJcy/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;}],&#34;date&#34;:&#34;2020-11-23 20:15:59&#34;,&#34;dateFormat&#34;:&#34;2020-11-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:460000,&#34;words&#34;:1592,&#34;minutes&#34;:8},&#34;description&#34;:&#34;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)\n\nconst_unit_poc ：利用const generics实现的物理单位库\nconst_unit_poc  ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#const_unit_poc-%E5%88%A9%E7%94%A8const-generics%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%8D%95%E4%BD%8D%E5%BA%93\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#const_unit_poc-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#units%E7%9A%84%E5%AE%9E%E7%8E%B0\&#34;&gt;units的实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E5%8D%95%E4%BD%8D%E7%B3%BB%E6%95%B0%E7%9A%84%E5%8C%85%E8%A3%85\&#34;&gt;对单位系数的包装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97\&#34;&gt;加减运算&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97\&#34;&gt;乘除运算&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;1-为什么需要异步编程\&#34;&gt;1. 为什么需要异步编程？&lt;/h1&gt;\n&lt;p&gt;刚开始一直有一个疑问：&lt;strong&gt;既然已经有了多线程技术，多用户访问直接使用多线程，为什么还需要异步呢？&lt;/strong&gt; 后来终于明白，异步是用在多用户&lt;strong&gt;同时处理同一资源&lt;/strong&gt;时候发挥作用的。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;现在用100个用户同时修改一个文件来举例：\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;(一般也是&lt;strong&gt;阻塞&lt;/strong&gt;)： 程序需要实现&lt;strong&gt;读写锁(&lt;code&gt;std::sync::RwLock&lt;/code&gt;)&lt;strong&gt;或&lt;/strong&gt;互斥锁(&lt;code&gt;std::sync::Mutex&lt;/code&gt;)&lt;/strong&gt;，程序会同时产生100个线程，但是只能有一个线程拥有写锁，其他的99个线程均&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;处于&lt;strong&gt;等待状态&lt;/strong&gt;，线程不会sleep，会循环获取锁(自旋锁Spinlock)。\n&lt;ul&gt;\n&lt;li&gt;阻塞的线程还来参与操作系统的抢占式调度，很不科学！为什么不先排好队，用一个线程呢（这也是协程干的事）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;或者有起始的&lt;strong&gt;加锁开销&lt;/strong&gt;(通常是对互斥锁：①线程会从sleep（加锁）——&amp;gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；②互斥锁在sleep时会陷入到内核态，需要昂贵的系统调用；线程向操作系统请求被挂起是通过一个系统调用，在linux上的实现就是futex)。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;(一般也是&lt;strong&gt;非阻塞&lt;/strong&gt;)： 将100个线程根据一定的先后次序&lt;strong&gt;合并成一个线程&lt;/strong&gt;(也可能是多个线程？)， 就可以避免锁的产生，从而减少操作系统对线程调用的开销。但是，当线程之间对资源的依赖关系比较复杂的时候，程序的编写就会&lt;strong&gt;十分复杂&lt;/strong&gt;。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt;(coroutine)： 实现异步编程的一种方式，是在线程之下的一个单位。协程是语言层面控制数据流的一种“调度”（处理公共资源的时候，相当于&lt;strong&gt;用户态的锁&lt;/strong&gt;）， 线程是操作系统层面的“调度”（处理公共资源，使用&lt;strong&gt;操作系统或者硬件的锁(即Mutex或者Spinlock)&lt;/strong&gt;）。协程的调度是编译器通过组织运算顺序实现的（通过生成器（等同于一个状态机）实现），线程是通过操作系统来进行抢占式调度的。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B\&#34;&gt;协程wiki&lt;/a&gt;：协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/332113890/answer/1052024052\&#34;&gt;互斥锁（mutex）的底层原理是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/50185085/answer/1342613525\&#34;&gt;出于什么样的原因，诞生了「协程」这一概念？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;所以，异步编程是可以直接用复杂的代码结构直接写出来的。比如上面的例子就是在一个线程里面去依次读写100次。而Rust的&lt;code&gt;async/.await&lt;/code&gt;解决方案做的工作是 &lt;strong&gt;“将复杂的异步代码 ===&amp;gt; 利用语法糖 ===&amp;gt; 转化为类似于同步的代码(更容易coding)”&lt;/strong&gt;  即 &lt;strong&gt;“用同步的语义解决异步问题”&lt;/strong&gt; 。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-yi-bu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34; Rust 异步并发（一）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;},{&#34;name&#34;:&#34;异步编程&#34;,&#34;slug&#34;:&#34;hDYBWTXHUV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hDYBWTXHUV/&#34;}],&#34;date&#34;:&#34;2020-11-22 23:07:53&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-yi-bu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:187000,&#34;words&#34;:907,&#34;minutes&#34;:4},&#34;description&#34;:&#34;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用async/.await解决方案。\n\n1. 为什么需要异步编程？\n刚开始一直有一个疑问：既...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B\&#34;&gt;1. 为什么需要异步编程？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;一个自说自话的地方。&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;一只在毕业边缘挣扎的秃头怪。&lt;/p&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;p&gt;coding~&lt;br&gt;\n以及一切有趣的事情们~&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;p&gt;thubzy15@foxmail.com&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-22 17:21:05&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:14000,&#34;words&#34;:67,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n一个自说自话的地方。\n👨‍💻 博主是谁\n一只在毕业边缘挣扎的秃头怪。\n⛹ 兴趣爱好\ncoding~\n以及一切有趣的事情们~\n📬 联系我呀\nthubzy15@foxmail.c...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;从&lt;strong&gt;今天&lt;/strong&gt;开始记录学习和生活。&lt;/p&gt;\n&lt;p&gt;我也是一个懒惰的小博主啦~😋&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;2020112-yi-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;2020.11.22 伊始&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;随便写写&#34;,&#34;slug&#34;:&#34;xMGkC-iLRF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/xMGkC-iLRF/&#34;}],&#34;date&#34;:&#34;2020-11-22 16:45:04&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;https://Busy-Bob.github.io/post-images/2020112-yi-shi.jpg&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/2020112-yi-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:4000,&#34;words&#34;:24,&#34;minutes&#34;:1},&#34;description&#34;:&#34;从今天开始记录学习和生活。\n我也是一个懒惰的小博主啦~😋\n&#34;,&#34;toc&#34;:&#34;&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


<script src=" /media/js/cool.js"></script>


</html>