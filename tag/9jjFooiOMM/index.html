<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="勺海的个人博客">
<meta name="description" content="尽应尽之事，做让自己开心的事。">
<meta name="theme-color" content="#000">
<title>勺海的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1609590335862">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/pisces.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/zenburn.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>勺海的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">尽应尽之事，做让自己开心的事。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 文章
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  pisces">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">勺海</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">沉迷于知识本身</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://Busy-Bob.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/Busy-Bob">
              <i class="fa fa-github-alt" title="github"></i>
            </a>
          
        
        
      </div>
    </div>
  

  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          FPGA
          <small>标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      <a href="https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              01-02
              <small>FPGA用来加速运算的调研</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      <a href="https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              12-31
              <small>The Zynq Book 学习： 引言</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      <a href="https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              12-31
              <small>ZYNQ中的通信接口(包括PS与PL)</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/wu-zhou-nian-la/"" data-c="
          &lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;一月&#34;&gt;一月&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609590165354.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609590219882.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">👨👩💏五周年啦</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/"" data-c="
          &lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;a href=&#34;https://www.zhihu.com/question/280468724/answer/517329473&#34;&gt;&lt;strong&gt;FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;并行计算，比如每个步骤没有关连性的循环操作；&lt;/li&gt;
&lt;li&gt;算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；&lt;/li&gt;
&lt;li&gt;乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；&lt;/li&gt;
&lt;li&gt;一些特定的矩阵运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;-2&#34;&gt;&lt;a href=&#34;https://www.zhihu.com/question/24174597/answer/138717507&#34;&gt;&lt;strong&gt;如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FPGA 为什么快？「都是同行衬托得好」。&lt;strong&gt;CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存&lt;/strong&gt;，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，&lt;strong&gt;不需要指令&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算密集型任务&lt;/strong&gt;(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当&lt;/li&gt;
&lt;li&gt;浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。&lt;/li&gt;
&lt;li&gt;在数据中心，FPGA 相比 GPU 的核心优势在于&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;FPGA 同时拥有&lt;strong&gt;流水线并行和数据并行&lt;/strong&gt;，而 GPU 几乎只有数据并行（流水线深度受限）。&lt;/li&gt;
&lt;li&gt;数据中心的计算任务是&lt;strong&gt;灵活多变&lt;/strong&gt;的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通信密集型任务&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。&lt;/li&gt;
&lt;li&gt;网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要规模足够大，对 FPGA 价格过高的担心将是不必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。&lt;strong&gt;如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态&lt;/strong&gt;。这时就不如用冯·诺依曼结构的处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 和 CPU 协同工作，&lt;strong&gt;局部性和重复性强的归 FPGA，复杂的归 CPU&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-3&#34;&gt;&lt;a href=&#34;https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf&#34;&gt;&lt;strong&gt;将浮点转为定点大幅降低功耗和成本 - Xilinx&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。&lt;/li&gt;
&lt;li&gt;对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浮点转换为定点的优势&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）&lt;/li&gt;
&lt;li&gt;功耗更低&lt;/li&gt;
&lt;li&gt;材料成本降低&lt;/li&gt;
&lt;li&gt;降低时延&lt;/li&gt;
&lt;li&gt;相近的性能和精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">FPGA用来加速运算的调研</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/"" data-c="
          &lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 &lt;strong&gt;处理器&lt;/strong&gt;和一个传统的现场可编程门阵列（Field Programmable Gate Array，&lt;strong&gt;FPGA&lt;/strong&gt;）逻辑部件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了&lt;strong&gt;高带宽、低延迟&lt;/strong&gt;的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而&lt;strong&gt;不会有&lt;/strong&gt;在两个分立的芯片之间的那种&lt;strong&gt;接口开销&lt;/strong&gt;。同时又能获得系统被简化为单一芯片所带来的好处，包括&lt;strong&gt;物理尺寸&lt;/strong&gt;和整体&lt;strong&gt;成本的降低&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;什么是片上系统/SoC (System on Chip)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。&lt;/li&gt;
&lt;li&gt;常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）&lt;/li&gt;
&lt;li&gt;和板上系统(在pcb板中组合多个元件)对比。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;开发时间和成本&lt;/li&gt;
&lt;li&gt;难以重用，不够灵活（与FPGA不同，直接设计芯片设计）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：手机，PC，平板等的CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理系统（PS）：支持软件程序和/ 或操作系统&lt;/li&gt;
&lt;li&gt;可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统&lt;/li&gt;
&lt;li&gt;工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609400781987.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软硬件系统关系&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609401050095.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">The Zynq Book 学习： 引言</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/"" data-c="
          &lt;p&gt;总体架构图为：&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609385485651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PS (Processing System)中对外通信管脚:&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MIO&lt;/strong&gt; (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt; (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在&lt;strong&gt;约束文件中分配管脚&lt;/strong&gt;，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即&lt;strong&gt;PS可以利用EMIO和PL进行通信&lt;/strong&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**PL (Programmable Logic) 和 PS的通信接口 **&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609403066047.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通用AXI（General Purpose AXI）&lt;/strong&gt;： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的&lt;strong&gt;中低速通信&lt;/strong&gt;。接口是透传的不带缓冲。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加速器一致性端口（Accelerator Coherency Port）&lt;/strong&gt;： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能端口（High Performance Ports）&lt;/strong&gt;： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。&lt;strong&gt;(PL直接从DDR中获取数据)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt;： 原本是用来连接I2C等协议的外设，也可以给PS使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pynq中python类对应&#34;&gt;PYNQ中python类对应：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GPIO&lt;/strong&gt;： 对应MIO， EMIO。（类似于单片机中的GPIO）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MMIO&lt;/strong&gt;： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xlnk&lt;/strong&gt;： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMA&lt;/strong&gt;： 对应HP AXI，访问DMA，即高性能AXI端口&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;axi-协议&#34;&gt;AXI 协议&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。&lt;/li&gt;
&lt;li&gt;AXI4_LITE： 只支持每次连接传输一个数据（非批量）。&lt;/li&gt;
&lt;li&gt;AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。&lt;/li&gt;
&lt;/ul&gt;
">ZYNQ中的通信接口(包括PS与PL)</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/nand-flash-nor-flash/"" data-c="
          &lt;h2 id=&#34;flash-原理&#34;&gt;Flash 原理：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609254997519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609253806308.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
参考&lt;a href=&#34;https://www.youtube.com/watch?v=aO_kBa9DzPQ&#34;&gt;youtube&lt;/a&gt;。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。&lt;/p&gt;
&lt;h2 id=&#34;nand-flash-和-nor-flash-区别&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Busy-Bob.github.io/post-images/1609253097307.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NAND 不能够取指令（类似于硬盘）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NOR 可以取指令（类似于内存）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于CPU运行时候需要三步：&lt;strong&gt;取指、译码、执行&lt;/strong&gt; 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ssd和u盘区别&#34;&gt;SSD和U盘区别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的&lt;br&gt;
主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么&lt;br&gt;
存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发&lt;br&gt;
接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快&lt;/p&gt;
&lt;p&gt;作者：李诗华&lt;br&gt;
链接：https://www.zhihu.com/question/265335741/answer/292414149&lt;br&gt;
来源：知乎&lt;/p&gt;
&lt;/blockquote&gt;
">NAND Flash, NOR Flash 的区别和应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/"" data-c="
          &lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;主要参考：&lt;a href=&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074&#34;&gt;细说Rust错误处理&lt;/a&gt; 和 &lt;a href=&#34;https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html&#34;&gt;Result 与可恢复的错误&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;tl-dr&#34;&gt;TL; DR&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt; 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）&lt;/li&gt;
&lt;li&gt;自定义一个&lt;code&gt;enum&lt;/code&gt;通常用在需要对错误进行恢复的时候。（容易检测类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;boxdyn-error-方式来聚合error&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn do_something() -&amp;gt; std::result::Result&amp;lt;(),Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt;{
    let path = &amp;quot;./dat&amp;quot;;
    let v = std::fs::read_to_string(path)?;
    let x = std::str::from_utf8(v.as_bytes())?;
    let u = x.parse::&amp;lt;u32&amp;gt;()?;
    println!(&amp;quot;num:{:?}&amp;quot;,u);
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三者分别返回不同的错误类型，但是都可以用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来装。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;： 方便书写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“&lt;strong&gt;反射&lt;/strong&gt;”( &lt;code&gt;Any&lt;/code&gt; trait)才能够确定。而不能直接match。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;利用-enum-来聚合error&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;内容来自&lt;a href=&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074&#34;&gt;细说Rust错误处理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自定义一个&lt;code&gt;error&lt;/code&gt;需要实现如下几步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Display&lt;/code&gt;的trait,并&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;fmt(...)&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Debug&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;，一般直接添加注解即可：&lt;code&gt;#[derive(Debug)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动实现impl &lt;code&gt;std::error::Error&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;,并根据自身&lt;code&gt;error&lt;/code&gt;级别是否&lt;strong&gt;覆盖&lt;/strong&gt;&lt;code&gt;std::error::Error&lt;/code&gt;中的&lt;code&gt;source()&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的内容中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;为我们实现的&lt;strong&gt;自定义Error&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;有三个&lt;strong&gt;子类型Error&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;分别实现了三个&lt;strong&gt;子类型Error&lt;/strong&gt; &lt;code&gt;From&lt;/code&gt;的trait,将其类型包装为&lt;strong&gt;自定义Error&lt;/strong&gt;的子类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，有了自定义的&lt;code&gt;CustomError&lt;/code&gt;，那怎么使用呢? 我们看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&amp;gt; std::result::Result&amp;lt;(),CustomError&amp;gt;{
    let path = &amp;quot;./dat&amp;quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&amp;quot;num:{:?}&amp;quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;String, std::io::Error&amp;gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;amp;[u8]) -&amp;gt; std::result::Result&amp;lt;&amp;amp;str, std::str::Utf8Error&amp;gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;u32, std::num::ParseIntError&amp;gt; {
    v.parse::&amp;lt;u32&amp;gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn std::error::Error + &#39;static)&amp;gt; {
        match &amp;amp;self {
            CustomError::IoError(ref e) =&amp;gt; Some(e),
            CustomError::Utf8Error(ref e) =&amp;gt; Some(e),
            CustomError::ParseIntError(ref e) =&amp;gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; std::fmt::Result {
        match &amp;amp;self {
            CustomError::IoError(ref e) =&amp;gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&amp;gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&amp;gt; e.fmt(f),
        }
    }
}

impl From&amp;lt;ParseIntError&amp;gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&amp;gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&amp;lt;IoError&amp;gt; for CustomError {
    fn from(s: std::io::Error) -&amp;gt; Self {
        CustomError::IoError(s)
    }
}

impl From&amp;lt;Utf8Error&amp;gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&amp;gt; Self {
        CustomError::Utf8Error(s)
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Rust 错误处理中多种类型Error传播的处理方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/"" data-c="
          &lt;p&gt;基于&lt;a href=&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;原作者的一些分析&#34;&gt;原作者的一些分析&lt;/h1&gt;
&lt;p&gt;基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(&lt;strong&gt;指针&lt;/strong&gt;)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优势：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;易于在大多数语言中实现&lt;/li&gt;
&lt;li&gt;没有上下文切换&lt;/li&gt;
&lt;li&gt;相对较低的内存开销(在大多数情况下)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。&lt;/li&gt;
&lt;li&gt;很难理解。许多人已经知道这是“回调地狱”。&lt;/li&gt;
&lt;li&gt;这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。&lt;/li&gt;
&lt;li&gt;由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;代码&#34;&gt;代码&lt;/h1&gt;
&lt;p&gt;通过代码，学习到了一些新东西，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_local!&lt;/code&gt; ：用来对每一个线程初始化同一个变量的一个新的副本。&lt;/li&gt;
&lt;li&gt;trait 对象： &lt;code&gt;Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&lt;/code&gt;,  &lt;code&gt;dyn Trait&lt;/code&gt;表示一个类型，强调是动态分发，并且必须是一个&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;
&lt;li&gt;传递闭包可以使用&lt;code&gt;impl Trait&lt;/code&gt;，这也是一个类型，并且该类型是&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread::spawn&lt;/code&gt;会直接新开一个子线程运行，不会造成主线程阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::sync::mpsc::Receiver.iter()&lt;/code&gt; 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的&lt;code&gt;.next()&lt;/code&gt; 才会变成&lt;code&gt;None&lt;/code&gt;，否则会一直等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;
fn program_main() {
    // 第一个输出
    println!(&amp;quot;So we start the program here!&amp;quot;);
    // 运行到这儿的时候， 0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(200, || {
        // 第五个输出
        println!(&amp;quot;We create tasks with a callback that runs once the task finished!&amp;quot;);
    });
    // 运行到这儿的时候， 仍然是0ms
    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。
    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞
    set_timeout(100, || {
        // 第三个输出
        println!(&amp;quot;We can even chain sub-tasks...&amp;quot;);
        set_timeout(50, || {
            // 第四个输出
            println!(&amp;quot;...like this!&amp;quot;);
        })
    });
    // 运行到这儿的时候， 仍然是0ms
    // 第二个输出
    println!(&amp;quot;While our tasks are executing we can do other stuff instead of waiting.&amp;quot;);
}

fn main() {
    RT.with(|rt| rt.run(program_main));
}

use std::sync::mpsc::{channel, Receiver, Sender};
use std::{cell::RefCell, collections::HashMap, thread};


// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本
// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&amp;lt;Runtime&amp;gt;
// 这儿好像只用到了一个副本
thread_local! {
    static RT: Runtime = Runtime::new();
}

struct Runtime {
    // callbacks 中的Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt; 是一个 trait 对象。 
    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&amp;gt; u32。 
    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。
    callbacks: RefCell&amp;lt;HashMap&amp;lt;usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&amp;gt;&amp;gt;,
    // 储存下一个闭包的id
    next_id: RefCell&amp;lt;usize&amp;gt;,
    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id
    evt_sender: Sender&amp;lt;usize&amp;gt;,
    // 接受下一个该运行的闭包的id
    evt_reciever: Receiver&amp;lt;usize&amp;gt;,
}

// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &amp;quot;a concrete type that implements this trait&amp;quot;. 
// Its primary use is working with closures, which have type definitions generated at compile time that can&#39;t be simply typed out.
// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait
// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html
fn set_timeout(ms: u64, cb: impl FnOnce() + &#39;static) {
    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。
    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。
    // 相当于用.with()就是在使用该变量的函数。
    RT.with(|rt| {
        let id = *rt.next_id.borrow();
        // next_id递增
        *rt.next_id.borrow_mut() += 1;
        // callbacks存 (id: usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;)
        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知
        // cb 在输入参数中用的impl FnOnce() + &#39;static 来限定。
        rt.callbacks.borrow_mut().insert(id, Box::new(cb));
        // The sending-half of Rust&#39;s asynchronous channel type. 
        // This half can only be owned by one thread, but it can be cloned to send to other threads.
        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个
        let evt_sender = rt.evt_sender.clone();
        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去
        thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(ms));
            // 在延时结束后，发送当前延时结束的任务id
            evt_sender.send(id).unwrap();
        });
    });
}


impl Runtime {
    fn new() -&amp;gt; Self {
        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver
        let (evt_sender, evt_reciever) = channel();
        Runtime {
            callbacks: RefCell::new(HashMap::new()),
            next_id: RefCell::new(1),
            evt_sender,
            evt_reciever,
        }
    }

    // 这儿是在运行一个函数.
    fn run(&amp;amp;self, program: fn()) {
        // 直接运行， 
        program();
        // 0ms 运行到这儿
        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。
        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.
        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None
        for evt_id in &amp;amp;self.evt_reciever {
            // 这儿直接从HashMap里remove出对应编号的闭包。
            let cb = self.callbacks.borrow_mut().remove(&amp;amp;evt_id).unwrap();
            cb();
            // 是不是也不需要这句话？
            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了
            if self.callbacks.borrow().is_empty() {
                break;
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&amp;quot;学歌&amp;quot;。所以，在回调逻辑中 &lt;code&gt;sing_song()&lt;/code&gt;作为闭包， &lt;code&gt;learn_song()&lt;/code&gt; 作为子线程，主线程运行&lt;code&gt;dance()&lt;/code&gt; 。子线程结束后再运行这个闭包。运行顺序是 &lt;code&gt;learn_song()&lt;/code&gt; （子线程）和 &lt;code&gt;dance()&lt;/code&gt;  （主线程）同时运行，在两个任务均完成后， 再回调&lt;code&gt;sing_song()&lt;/code&gt;这个闭包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子线程&lt;/strong&gt;对应 &lt;strong&gt;“等待资源”&lt;/strong&gt; ； &lt;strong&gt;闭包&lt;/strong&gt;对应“&lt;strong&gt;接收到等待资源后的操作”&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;async fn learn_and_sing() {
    // 在唱歌之前等待学歌完成
    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。
    let song = learn_song().await;
    sing_song(song).await;
}
 async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();
     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成
     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞
     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，
     // 这个‘async_main&#39;函数就会变成阻塞状态，并生成一个执行器
    futures::join!(f1, f2)
}
 fn main() {
    block_on(async_main());
}
&lt;/code&gt;&lt;/pre&gt;
">Rust 基于回调的异步方法分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/"" data-c="
          &lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;const_unit_poc-利用const-generics实现的物理单位库&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;const_unit_poc&lt;/code&gt;  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(const_generics, const_evaluatable_checked)]
use const_unit_poc::values::{m, kg, s, N};

let distance = 1.0 * m;
let mass = 18.0 * kg;
let force = distance * mass / (1.8 * s * 2.0 * s);
assert_eq!(force, 5.0 * N);

let mut mutable_distance = 3.2 * m;
mutable_distance -= 0.2 * m;
mutable_distance += 2.0 * m;

assert_eq!(mutable_distance, 5.0 * m);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。&lt;/p&gt;
&lt;h2 id=&#34;const_unit_poc-源码分析&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![feature(const_generics, const_evaluatable_checked, doc_cfg)]
#![allow(incomplete_features)]
#![cfg_attr(feature = &amp;quot;non_ascii&amp;quot;, feature(non_ascii_idents))]

use std::ops;

pub mod units;
pub mod values;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(non_snake_case)]
pub struct SiUnit {
    m: i8,
    kg: i8,
    s: i8,
    A: i8,
    K: i8,
    mol: i8,
    cd: i8,
}

// 后面还有内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里引入了&lt;code&gt;units&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;两个mod，并且声明了&lt;code&gt;SiUnit&lt;/code&gt; 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。&lt;/p&gt;
&lt;p&gt;看到这儿，笔者推测应该是使用 &lt;code&gt;SiUnit&lt;/code&gt; 这个结构体来实例化各种常用的单位（如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），其中成员的值表示该单位表示成基本单位后的指数的值（如&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N=m*s^{-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8141079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;， 则&lt;code&gt;N.m == 1; N.s == -2&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;再看一下引入的模块&lt;code&gt;units&lt;/code&gt;的内容&lt;/p&gt;
&lt;h3 id=&#34;units的实现&#34;&gt;units的实现&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs&#34;&gt;&lt;code&gt;./src/units.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![allow(non_upper_case_globals)]
use super::SiUnit;
const NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };
/// meter
pub const m: SiUnit = SiUnit { m: 1, ..NONE };
/// 中间内容省略
/// lux
pub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };
/// square meter
pub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };
/// cubic meter
pub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的确和猜想一致！注意结构体实例化时候这儿使用了&lt;code&gt;..NONE&lt;/code&gt;，这是用已经创建的实例None上&lt;strong&gt;更新部分参数&lt;/strong&gt;，创建新的实例，见&lt;a href=&#34;https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B&#34;&gt;使用结构体更新语法从其他实例创建实例&lt;/a&gt;。这儿使用了const使得各个单位全局可见且不可变。&lt;/p&gt;
&lt;p&gt;现在已经有了单位，但是我们注意到代码中&lt;code&gt;assert_eq!(mutable_distance, 5.0 * m);&lt;/code&gt;不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。&lt;/p&gt;
&lt;h3 id=&#34;对单位系数的包装&#34;&gt;对单位系数的包装&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs&#34;&gt;&lt;code&gt;./src/values.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![allow(non_upper_case_globals)]
use crate::{units, Quantity};
// base
/// 1 meter
pub const m: Quantity&amp;lt;{ units::m }&amp;gt; = Quantity { raw_value: 1.0 };
/// 1 kilogram
pub const kg: Quantity&amp;lt;{ units::kg }&amp;gt; = Quantity { raw_value: 1.0 };
/// 1 second
pub const s: Quantity&amp;lt;{ units::s }&amp;gt; = Quantity { raw_value: 1.0 };
/// 后面还有
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;use crate::{units, Quantity}&lt;/code&gt;, 代表的是导入的当前&lt;code&gt;crate&lt;/code&gt;中的&lt;code&gt;units&lt;/code&gt;和&lt;code&gt;Quantity&lt;/code&gt;。&lt;br&gt;
&lt;strong&gt;const 泛型&lt;/strong&gt;: 从这儿的可以大概可以看出，&lt;code&gt;Quantity&lt;/code&gt;的泛型参数是一个const常量，包装每一个&lt;code&gt;units.rs&lt;/code&gt;中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：&lt;code&gt;Quantity&amp;lt;{ units::m }&amp;gt; { raw_value: 1.0 }&lt;/code&gt;。 所以是用&lt;code&gt;raw_value&lt;/code&gt;来表示每一个单位的系数。&lt;/p&gt;
&lt;p&gt;所以再来看看&lt;code&gt;Quantity&lt;/code&gt;的定义吧。&lt;/p&gt;
&lt;p&gt;###结构体 &lt;code&gt;Quantity&lt;/code&gt;的定义&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
#[repr(transparent)]
pub struct Quantity&amp;lt;const U: SiUnit&amp;gt; {
    pub raw_value: f64,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单干脆的使用const 类型作为泛型参数。&lt;/p&gt;
&lt;h3 id=&#34;加减运算&#34;&gt;加减运算&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Add for Quantity&amp;lt;U&amp;gt; {
    type Output = Self;

    fn add(self, rhs: Self) -&amp;gt; Self {
        Self { raw_value: self.raw_value + rhs.raw_value }
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::AddAssign for Quantity&amp;lt;U&amp;gt; {
    fn add_assign(&amp;amp;mut self, rhs: Self) {
        self.raw_value += rhs.raw_value;
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::Sub for Quantity&amp;lt;U&amp;gt; {
    type Output = Self;

    fn sub(self, rhs: Self) -&amp;gt; Self {
        Self { raw_value: self.raw_value - rhs.raw_value }
    }
}

impl&amp;lt;const U: SiUnit&amp;gt; ops::SubAssign for Quantity&amp;lt;U&amp;gt; {
    fn sub_assign(&amp;amp;mut self, rhs: Self) {
        self.raw_value -= rhs.raw_value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于加减运算并不会变单位，所以就是对系数的加减，非常直接。&lt;/p&gt;
&lt;h3 id=&#34;乘除运算&#34;&gt;乘除运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个数字与一个Quantity相乘，单位不变：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Mul&amp;lt;f64&amp;gt; for Quantity&amp;lt;U&amp;gt; {
    type Output = Quantity&amp;lt;U&amp;gt;;

    fn mul(self, rhs: f64) -&amp;gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;两个带单位的量相乘，单位发生变化，也就是&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;的泛型参数发生了变化，此时需要重新实例化一个&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;结构体：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Quantity相乘转换为unit相乘，UL.unit_mul(UR)
impl&amp;lt;const UL: SiUnit, const UR: SiUnit&amp;gt; ops::Mul&amp;lt;Quantity&amp;lt;UR&amp;gt;&amp;gt; for Quantity&amp;lt;UL&amp;gt;
where
    Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;: ,
{
    type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;

    fn mul(self, rhs: Quantity&amp;lt;UR&amp;gt;) -&amp;gt; Self::Output {
        Quantity { raw_value: self.raw_value * rhs.raw_value }
    }
}
// unit相乘
impl SiUnit {
    const fn unit_mul(self, rhs: Self) -&amp;gt; Self {
        Self {
            m: self.m + rhs.m,
            kg: self.kg + rhs.kg,
            s: self.s + rhs.s,
            A: self.A + rhs.A,
            K: self.K + rhs.K,
            mol: self.mol + rhs.mol,
            cd: self.cd + rhs.cd,
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这儿对泛型的约束很神奇，竟然是这样写&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;:&lt;/code&gt; ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;error: unconstrained generic constant
   --&amp;gt; src\lib.rs:156:5
    |
156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
    |
help: consider adding a `where` bound for this expression  
   --&amp;gt; src\lib.rs:156:28
    |
156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     
    |                            ^^^^^^^^^^^^^^^^^^^     
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;&lt;/code&gt; ，否则也会出错。这在最近的&lt;a href=&#34;https://github.com/rust-lang/rust/pull/79135&#34;&gt;Stabilization report&lt;/a&gt;里面也有提到。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Const arguments&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, &lt;strong&gt;most expressions must be contained within a block&lt;/strong&gt;, with two exceptions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;literals and single-segment path expressions&lt;/li&gt;
&lt;li&gt;array lengths&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.&lt;/p&gt;
&lt;p&gt;In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;type N = u32;
struct Foo&amp;lt;const N: usize&amp;gt;;
fn foo&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;N&amp;gt; { todo!() } // ERR
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;type N = u32;
struct Foo&amp;lt;const N: usize&amp;gt;;
fn bar&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;{ N }&amp;gt; { todo!() } // ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是了解了const 泛型在做啥，以及如何做的。&lt;/p&gt;
&lt;p&gt;通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。&lt;/p&gt;
">Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/rust-yi-bu/"" data-c="
          &lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;
Rust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-为什么需要异步编程&#34;&gt;1. 为什么需要异步编程？&lt;/h1&gt;
&lt;p&gt;刚开始一直有一个疑问：&lt;strong&gt;既然已经有了多线程技术，多用户访问直接使用多线程，为什么还需要异步呢？&lt;/strong&gt; 后来终于明白，异步是用在多用户&lt;strong&gt;同时处理同一资源&lt;/strong&gt;时候发挥作用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;现在用100个用户同时修改一个文件来举例：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;(一般也是&lt;strong&gt;阻塞&lt;/strong&gt;)： 程序需要实现&lt;strong&gt;读写锁(&lt;code&gt;std::sync::RwLock&lt;/code&gt;)&lt;strong&gt;或&lt;/strong&gt;互斥锁(&lt;code&gt;std::sync::Mutex&lt;/code&gt;)&lt;/strong&gt;，程序会同时产生100个线程，但是只能有一个线程拥有写锁，其他的99个线程均&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处于&lt;strong&gt;等待状态&lt;/strong&gt;，线程不会sleep，会循环获取锁(自旋锁Spinlock)。
&lt;ul&gt;
&lt;li&gt;阻塞的线程还来参与操作系统的抢占式调度，很不科学！为什么不先排好队，用一个线程呢（这也是协程干的事）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;或者有起始的&lt;strong&gt;加锁开销&lt;/strong&gt;(通常是对互斥锁：①线程会从sleep（加锁）——&amp;gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；②互斥锁在sleep时会陷入到内核态，需要昂贵的系统调用；线程向操作系统请求被挂起是通过一个系统调用，在linux上的实现就是futex)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;(一般也是&lt;strong&gt;非阻塞&lt;/strong&gt;)： 将100个线程根据一定的先后次序&lt;strong&gt;合并成一个线程&lt;/strong&gt;(也可能是多个线程？)， 就可以避免锁的产生，从而减少操作系统对线程调用的开销。但是，当线程之间对资源的依赖关系比较复杂的时候，程序的编写就会&lt;strong&gt;十分复杂&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt;(coroutine)： 实现异步编程的一种方式，是在线程之下的一个单位。协程是语言层面控制数据流的一种“调度”（处理公共资源的时候，相当于&lt;strong&gt;用户态的锁&lt;/strong&gt;）， 线程是操作系统层面的“调度”（处理公共资源，使用&lt;strong&gt;操作系统或者硬件的锁(即Mutex或者Spinlock)&lt;/strong&gt;）。协程的调度是编译器通过组织运算顺序实现的（通过生成器（等同于一个状态机）实现），线程是通过操作系统来进行抢占式调度的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B&#34;&gt;协程wiki&lt;/a&gt;：协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/332113890/answer/1052024052&#34;&gt;互斥锁（mutex）的底层原理是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/50185085/answer/1342613525&#34;&gt;出于什么样的原因，诞生了「协程」这一概念？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，异步编程是可以直接用复杂的代码结构直接写出来的。比如上面的例子就是在一个线程里面去依次读写100次。而Rust的&lt;code&gt;async/.await&lt;/code&gt;解决方案做的工作是 &lt;strong&gt;“将复杂的异步代码 ===&amp;gt; 利用语法糖 ===&amp;gt; 转化为类似于同步的代码(更容易coding)”&lt;/strong&gt;  即 &lt;strong&gt;“用同步的语义解决异步问题”&lt;/strong&gt; 。&lt;/p&gt;
"> Rust 异步并发（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;一个自说自话的地方。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;一只在毕业边缘挣扎的秃头怪。&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;coding~&lt;br&gt;
以及一切有趣的事情们~&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;thubzy15@foxmail.com&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://Busy-Bob.github.io/post/2020112-yi-shi/"" data-c="
          &lt;p&gt;从&lt;strong&gt;今天&lt;/strong&gt;开始记录学习和生活。&lt;/p&gt;
&lt;p&gt;我也是一个懒惰的小博主啦~😋&lt;/p&gt;
">2020.11.22 伊始</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;一月\&#34;&gt;一月&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609590165354.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609590219882.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;wu-zhou-nian-la&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;strong&gt;2021-1-3： 水吉和臭臭五周年啦！&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;👨👩💏五周年啦&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;随便写写&#34;,&#34;slug&#34;:&#34;xMGkC-iLRF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/xMGkC-iLRF/&#34;}],&#34;date&#34;:&#34;2021-01-02 19:52:30&#34;,&#34;dateFormat&#34;:&#34;2021-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/wu-zhou-nian-la/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:3000,&#34;words&#34;:14,&#34;minutes&#34;:1},&#34;description&#34;:&#34;2021-1-3： 水吉和臭臭五周年啦！\n\n一月\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E6%9C%88\&#34;&gt;一月&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;\&#34;&gt;&lt;a href=\&#34;https://www.zhihu.com/question/280468724/answer/517329473\&#34;&gt;&lt;strong&gt;FPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;并行计算，比如每个步骤没有关连性的循环操作；&lt;/li&gt;\n&lt;li&gt;算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是流水结构的吞吐量非常大；&lt;/li&gt;\n&lt;li&gt;乘法运算，FPGA的乘法运算通常用乘法器只需要一个周期；&lt;/li&gt;\n&lt;li&gt;一些特定的矩阵运算。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;-2\&#34;&gt;&lt;a href=\&#34;https://www.zhihu.com/question/24174597/answer/138717507\&#34;&gt;&lt;strong&gt;如何评价微软在数据中心使用 FPGA 代替传统 CPU 的做法？ - 李博杰的回答 - 知乎&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 为什么快？「都是同行衬托得好」。&lt;strong&gt;CPU、GPU 都属于冯·诺依曼结构，指令译码执行、共享内存&lt;/strong&gt;，FPGA 之所以比 CPU 甚至 GPU 能效高，本质上是无指令、无需共享内存的体系结构带来的福利。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 每个逻辑单元的功能在重编程（烧写）时就已经确定，&lt;strong&gt;不需要指令&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;计算密集型任务&lt;/strong&gt;(包括矩阵运算、图像处理、机器学习、压缩、非对称加密、Bing 搜索的排序等)&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Stratix V FPGA 的整数乘法运算性能与 20 核的 CPU 基本相当&lt;/li&gt;\n&lt;li&gt;浮点乘法运算性能与 8 核的 CPU 基本相当，而比 GPU 低一个数量级。&lt;/li&gt;\n&lt;li&gt;在数据中心，FPGA 相比 GPU 的核心优势在于&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;FPGA 同时拥有&lt;strong&gt;流水线并行和数据并行&lt;/strong&gt;，而 GPU 几乎只有数据并行（流水线深度受限）。&lt;/li&gt;\n&lt;li&gt;数据中心的计算任务是&lt;strong&gt;灵活多变&lt;/strong&gt;的，而 ASIC 研发成本高、周期长。好不容易大规模部署了一批某种神经网络的加速卡，结果另一种神经网络更火了，钱就白费了。FPGA 只需要几百毫秒就可以更新逻辑功能。FPGA 的灵活性可以保护投资&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;通信密集型任务&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;从吞吐量上讲，FPGA 上的收发器可以直接接上 40 Gbps 甚至 100 Gbps 的网线，以线速处理任意大小的数据包。&lt;/li&gt;\n&lt;li&gt;网卡把数据包收到 CPU，CPU 再发给网卡，即使使用 DPDK 这样高性能的数据包处理框架，延迟也有 4~5 微秒。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;只要规模足够大，对 FPGA 价格过高的担心将是不必要的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;对很多类型的应用，随着分布式 FPGA 加速器的规模扩大，其性能提升是超线性的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;把任务拆分到分布式 FPGA 集群的关键在于平衡计算和通信。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;每做一点不同的事情，就要占用一定的 FPGA 逻辑资源。&lt;strong&gt;如果要做的事情复杂、重复性不强，就会占用大量的逻辑资源，其中的大部分处于闲置状态&lt;/strong&gt;。这时就不如用冯·诺依曼结构的处理器。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;FPGA 和 CPU 协同工作，&lt;strong&gt;局部性和重复性强的归 FPGA，复杂的归 CPU&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;-3\&#34;&gt;&lt;a href=\&#34;https://china.xilinx.com/support/documentation/white_papers/c_wp491-floating-to-fixed-point.pdf\&#34;&gt;&lt;strong&gt;将浮点转为定点大幅降低功耗和成本 - Xilinx&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;用定点实现的设计总是比用浮点实现的同一设计更加高效，因为定点实现方案所占用的资源和消耗的功耗更少。若将设计迁移到定点，功耗和占用面积缩减一半并不稀奇。&lt;/li&gt;\n&lt;li&gt;对于采用 C/C++ 语言设计的客户，赛灵思提供 Vivado HLS 并支持任意精度定点数据类型，使客户能够方便地采用定点进行设计或者将现有的 C/C++ 设计转换成定点。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;浮点转换为定点的优势&lt;/strong&gt;:\n&lt;ul&gt;\n&lt;li&gt;减少 FPGA 资源占用（所需的 DSP48E2、查找表 (LUT) 和触发器更少，存储定点数字所需的存储容量更小）&lt;/li&gt;\n&lt;li&gt;功耗更低&lt;/li&gt;\n&lt;li&gt;材料成本降低&lt;/li&gt;\n&lt;li&gt;降低时延&lt;/li&gt;\n&lt;li&gt;相近的性能和精度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;fpga-yong-lai-jia-su-yun-suan-de-diao-yan&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;FPGA用来加速运算的调研.😁&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;FPGA用来加速运算的调研&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2021-01-02 13:53:42&#34;,&#34;dateFormat&#34;:&#34;2021-01-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/fpga-yong-lai-jia-su-yun-suan-de-diao-yan/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:202000,&#34;words&#34;:963,&#34;minutes&#34;:4},&#34;description&#34;:&#34;FPGA用来加速运算的调研.😁\n\nFPGA算法加速有什么一般的套路？ - Dorus TAN的回答 - 知乎\n\n并行计算，比如每个步骤没有关连性的循环操作；\n算法步骤的固定程度，通常越固定的算法越适合用流水线实现，虽然结果延迟差不多，但是...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Zynq 的本质特征，是它组合了一个双核ARM Cortex-A9 &lt;strong&gt;处理器&lt;/strong&gt;和一个传统的现场可编程门阵列（Field Programmable Gate Array，&lt;strong&gt;FPGA&lt;/strong&gt;）逻辑部件。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;这个架构实现了工业标准的AXI 接口，在芯片的两个部分之间实现了&lt;strong&gt;高带宽、低延迟&lt;/strong&gt;的连接。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;这意味着处理器和逻辑部分各自都可以发挥最佳的用途，而&lt;strong&gt;不会有&lt;/strong&gt;在两个分立的芯片之间的那种&lt;strong&gt;接口开销&lt;/strong&gt;。同时又能获得系统被简化为单一芯片所带来的好处，包括&lt;strong&gt;物理尺寸&lt;/strong&gt;和整体&lt;strong&gt;成本的降低&lt;/strong&gt;。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;什么是片上系统/SoC (System on Chip)&lt;/strong&gt;:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单个硅芯片就可以用来实现整个系统的功能，而不是需要用几个不同的物理芯片来实现。&lt;/li&gt;\n&lt;li&gt;常用于指专用集成电路（Application Specific Integrated Circuit，ASIC）&lt;/li&gt;\n&lt;li&gt;和板上系统(在pcb板中组合多个元件)对比。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：\n&lt;ul&gt;\n&lt;li&gt;开发时间和成本&lt;/li&gt;\n&lt;li&gt;难以重用，不够灵活（与FPGA不同，直接设计芯片设计）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;例子&lt;/strong&gt;：手机，PC，平板等的CPU&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Zynq：灵活的SoC 的平台，全可编程SoC （All-Programmable SoC，APSoC）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;处理系统（PS）：支持软件程序和/ 或操作系统&lt;/li&gt;\n&lt;li&gt;可编程逻辑（PL）：实现高速逻辑、算术和数据流子系统&lt;/li&gt;\n&lt;li&gt;工业标准的高级可扩展接口（Advanced eXtensible Interface，AXI）连接。&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609400781987.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;软硬件系统关系&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609401050095.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;the-zynq-book-xue-xi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;学习The Zynq Book第一章时的一些笔记&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;The Zynq Book 学习： 引言&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;zynq&#34;,&#34;slug&#34;:&#34;VR993R9Vz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/VR993R9Vz/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2020-12-31 15:25:06&#34;,&#34;dateFormat&#34;:&#34;2020-12-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/the-zynq-book-xue-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:81000,&#34;words&#34;:375,&#34;minutes&#34;:2},&#34;description&#34;:&#34;学习The Zynq Book第一章时的一些笔记\n\n\n\nZynq 的本质特征，是它组合了一个双核ARM Cortex-A9 处理器和一个传统的现场可编程门阵列（Field Programmable Gate Array，FPGA）逻辑部件。...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;总体架构图为：&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609385485651.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;PS (Processing System)中对外通信管脚:&lt;/strong&gt;：\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;MIO&lt;/strong&gt; (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上的管脚是固定的，占用IO号为0-53。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt; (Extended MIO，EMIO)： 是通过PL部分扩展的，所以使用EMIO时候需要在&lt;strong&gt;约束文件中分配管脚&lt;/strong&gt;，占用IO号为54-117。EMIO 并不是 PS 和外部连接之间的直接通路，而是通过共用了 PL 的 I/O 资源来实现的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;em&gt;当需要扩展超过 54 个引脚的时候可以用 EMIO，而当 PL 中实现了一个 IP 包的时候，这也是 PS 和 PL 中的IP 包接口的一种方法(即&lt;strong&gt;PS可以利用EMIO和PL进行通信&lt;/strong&gt;)&lt;/em&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;**PL (Programmable Logic) 和 PS的通信接口 **&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609403066047.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;通用AXI（General Purpose AXI）&lt;/strong&gt;： 一共有四个，对应图中主机互联和从机互联。32 位数据总线，适合PL 和PS 之间的&lt;strong&gt;中低速通信&lt;/strong&gt;。接口是透传的不带缓冲。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;加速器一致性端口（Accelerator Coherency Port）&lt;/strong&gt;： 在PL 和APU 内的SCU之间的单个异步连接，总线宽度为64 位。这个端口用来实现APU cache 和PL的单元之间的一致性（直接和PS中的APU相连）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;高性能端口（High Performance Ports）&lt;/strong&gt;： 带有FIFO缓冲来提供“ 批量” 读写操作，并支持PL 和PS 中的存储器单元的高速率通信。数据宽度是32 或64 位，在所有四个接口中PL 都是做主机的。&lt;strong&gt;(PL直接从DDR中获取数据)&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;EMIO&lt;/strong&gt;： 原本是用来连接I2C等协议的外设，也可以给PS使用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;pynq中python类对应\&#34;&gt;PYNQ中python类对应：&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;GPIO&lt;/strong&gt;： 对应MIO， EMIO。（类似于单片机中的GPIO）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;MMIO&lt;/strong&gt;： 对应GP AXI，即通用AXI端口。（调用IP核，PS给PL数据时候用）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Xlnk&lt;/strong&gt;： 对应HP AXI，访问DDR内存，即高性能AXI端口。（访问PS 的 DRAM， 用以PL需要内存时候，PS分配内存给PL）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;DMA&lt;/strong&gt;： 对应HP AXI，访问DMA，即高性能AXI端口&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;axi-协议\&#34;&gt;AXI 协议&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;AXI4：  通过一簇高达256 个数据字（或“ 数据拍（data beats）”）的数据传输来给定一个地址。&lt;/li&gt;\n&lt;li&gt;AXI4_LITE： 只支持每次连接传输一个数据（非批量）。&lt;/li&gt;\n&lt;li&gt;AXI4-Stream： 用于高速流数据，支持批量传输无限大小的数据。没有地址机制，这种总线类型最适合源和目的地之间的直接数据流。&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;zynq-zhong-de-si-chong-tong-xin-jie-kou__&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;ZYNQ中的通信接口(包括PS与PL)&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;zynq&#34;,&#34;slug&#34;:&#34;VR993R9Vz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/VR993R9Vz/&#34;},{&#34;name&#34;:&#34;FPGA&#34;,&#34;slug&#34;:&#34;9jjFooiOMM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9jjFooiOMM/&#34;}],&#34;date&#34;:&#34;2020-12-31 10:45:05&#34;,&#34;dateFormat&#34;:&#34;2020-12-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/zynq-zhong-de-si-chong-tong-xin-jie-kou__/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:139000,&#34;words&#34;:608,&#34;minutes&#34;:3},&#34;description&#34;:&#34;总体架构图为：\n\n\nPS (Processing System)中对外通信管脚:：\n\nMIO (Multiplexed Input/Output，MIO)： 利用复用的输入 / 输出，和外部接口之间通信，一共54 个引脚。MIO在zynq上...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#pynq%E4%B8%ADpython%E7%B1%BB%E5%AF%B9%E5%BA%94\&#34;&gt;PYNQ中python类对应：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#axi-%E5%8D%8F%E8%AE%AE\&#34;&gt;AXI 协议&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;flash-原理\&#34;&gt;Flash 原理：&lt;/h2&gt;\n&lt;p&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609254997519.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609253806308.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n参考&lt;a href=\&#34;https://www.youtube.com/watch?v=aO_kBa9DzPQ\&#34;&gt;youtube&lt;/a&gt;。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了对该page的纵向线加高电压，也需要对其他单元的横向线加高电压，使得其他地方电子不往控制栅极走。&lt;/p&gt;\n&lt;h2 id=\&#34;nand-flash-和-nor-flash-区别\&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://Busy-Bob.github.io/post-images/1609253097307.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;NAND 不能够取指令（类似于硬盘）&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;NOR 可以取指令（类似于内存）&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;由于CPU运行时候需要三步：&lt;strong&gt;取指、译码、执行&lt;/strong&gt; 三个步骤。由于 NOR的地址线和数据线分开，它可以按“字节”读写数据，符合 CPU 的指令译码执行要求，所以假如 NOR上存储了代码指令， CPU 给 NOR一个地址， NOR 就能向CPU 返回一条指令让 CPU 执行，中间不需要额外的处理操作。所以NOR Flash是可以用于执行的，即支持XIP(eXecute In Place) 。&lt;/p&gt;\n&lt;h2 id=\&#34;应用场景\&#34;&gt;应用场景&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;NOR Flash 小容量，具备随机访问能力，可执行。（用于执行片上程序，BIOS）&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;NAND Flash 大容量，不具备随机访问能力。（SSD，U盘等）&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;ssd和u盘区别\&#34;&gt;SSD和U盘区别&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;储存介质不一样：固态硬盘用的储存芯片价格远远高于U盘用的&lt;br&gt;\n主控芯片不一样：把芯片的读写模式安排好是主控芯片的事，U盘基本上在这个上面没做什么&lt;br&gt;\n存储模式不一样：固态硬盘是多芯片组成，在读书时，在主控的安排下，通常都能多路并发&lt;br&gt;\n接口模式不一样：固态硬盘的接口丰富，不管哪个接口，都比USB快&lt;/p&gt;\n&lt;p&gt;作者：李诗华&lt;br&gt;\n链接：https://www.zhihu.com/question/265335741/answer/292414149&lt;br&gt;\n来源：知乎&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;nand-flash-nor-flash&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;NAND Flash, NOR Flash 的区别和应用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Flash&#34;,&#34;slug&#34;:&#34;gtSmWzfNV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/gtSmWzfNV/&#34;},{&#34;name&#34;:&#34;NAND&#34;,&#34;slug&#34;:&#34;9Zg0ckvoQ0&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/9Zg0ckvoQ0/&#34;},{&#34;name&#34;:&#34;NOR&#34;,&#34;slug&#34;:&#34;7JP4e5yowm&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/7JP4e5yowm/&#34;}],&#34;date&#34;:&#34;2020-12-29 22:06:01&#34;,&#34;dateFormat&#34;:&#34;2020-12-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/nand-flash-nor-flash/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:104000,&#34;words&#34;:480,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Flash 原理：\n\n\n参考youtube。在控制栅极高电压时候，源极漏极之间导通，电子会穿过绝缘层往控制栅极走（电子从负极走向正极），控制栅极恢复后电子困在里面，表现出0。如果只需要一个page中的某一个小单元从1-&amp;gt;0, 那么除了...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#flash-%E5%8E%9F%E7%90%86\&#34;&gt;Flash 原理：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nand-flash-%E5%92%8C-nor-flash-%E5%8C%BA%E5%88%AB\&#34;&gt;NAND Flash 和 NOR Flash 区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;应用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ssd%E5%92%8Cu%E7%9B%98%E5%8C%BA%E5%88%AB\&#34;&gt;SSD和U盘区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;主要参考：&lt;a href=\&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074\&#34;&gt;细说Rust错误处理&lt;/a&gt; 和 &lt;a href=\&#34;https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html\&#34;&gt;Result 与可恢复的错误&lt;/a&gt;.&lt;/p&gt;\n&lt;h1 id=\&#34;tl-dr\&#34;&gt;TL; DR&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt; 通常用在不对错误进行恢复的时候。（不容易检测到错误类型）&lt;/li&gt;\n&lt;li&gt;自定义一个&lt;code&gt;enum&lt;/code&gt;通常用在需要对错误进行恢复的时候。（容易检测类型）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;boxdyn-error-方式来聚合error\&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/h1&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;fn do_something() -&amp;gt; std::result::Result&amp;lt;(),Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt;{\n    let path = &amp;quot;./dat&amp;quot;;\n    let v = std::fs::read_to_string(path)?;\n    let x = std::str::from_utf8(v.as_bytes())?;\n    let u = x.parse::&amp;lt;u32&amp;gt;()?;\n    println!(&amp;quot;num:{:?}&amp;quot;,u);\n    Ok(())\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;三者分别返回不同的错误类型，但是都可以用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来装。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;： 方便书写。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;： 在传递后该Result后，该trait object 对应的实际的错误类型难以确定，应该需要用“&lt;strong&gt;反射&lt;/strong&gt;”( &lt;code&gt;Any&lt;/code&gt; trait)才能够确定。而不能直接match。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;利用-enum-来聚合error\&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/h1&gt;\n&lt;blockquote&gt;\n&lt;p&gt;内容来自&lt;a href=\&#34;https://rustcc.cn/article?id=75dbd87c-df1c-4000-a243-46afc8513074\&#34;&gt;细说Rust错误处理&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;自定义一个&lt;code&gt;error&lt;/code&gt;需要实现如下几步：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Display&lt;/code&gt;的trait,并&lt;strong&gt;实现&lt;/strong&gt; &lt;code&gt;fmt(...)&lt;/code&gt;方法。&lt;/li&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::fmt::Debug&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;，一般直接添加注解即可：&lt;code&gt;#[derive(Debug)]&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;手动实现impl &lt;code&gt;std::error::Error&lt;/code&gt;的&lt;code&gt;trait&lt;/code&gt;,并根据自身&lt;code&gt;error&lt;/code&gt;级别是否&lt;strong&gt;覆盖&lt;/strong&gt;&lt;code&gt;std::error::Error&lt;/code&gt;中的&lt;code&gt;source()&lt;/code&gt;方法。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面的内容中：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;为我们实现的&lt;strong&gt;自定义Error&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;有三个&lt;strong&gt;子类型Error&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CustomError&lt;/code&gt;分别实现了三个&lt;strong&gt;子类型Error&lt;/strong&gt; &lt;code&gt;From&lt;/code&gt;的trait,将其类型包装为&lt;strong&gt;自定义Error&lt;/strong&gt;的子类型&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;好了，有了自定义的&lt;code&gt;CustomError&lt;/code&gt;，那怎么使用呢? 我们看代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;use std::io::Error as IoError;\nuse std::str::Utf8Error;\nuse std::num::ParseIntError;\nuse std::fmt::{Display, Formatter};\n\n\nfn main() -&amp;gt; std::result::Result&amp;lt;(),CustomError&amp;gt;{\n    let path = &amp;quot;./dat&amp;quot;;\n    let v = read_file(path)?;\n    let x = to_utf8(v.as_bytes())?;\n    let u = to_u32(x)?;\n    println!(&amp;quot;num:{:?}&amp;quot;,u);\n    Ok(())\n}\n\n///读取文件内容\nfn read_file(path: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;String, std::io::Error&amp;gt; {\n    std::fs::read_to_string(path)\n}\n\n/// 转换为utf8内容\nfn to_utf8(v: &amp;amp;[u8]) -&amp;gt; std::result::Result&amp;lt;&amp;amp;str, std::str::Utf8Error&amp;gt; {\n    std::str::from_utf8(v)\n}\n\n/// 转化为u32数字\nfn to_u32(v: &amp;amp;str) -&amp;gt; std::result::Result&amp;lt;u32, std::num::ParseIntError&amp;gt; {\n    v.parse::&amp;lt;u32&amp;gt;()\n}\n\n\n#[derive(Debug)]\nenum CustomError {\n    ParseIntError(std::num::ParseIntError),\n    Utf8Error(std::str::Utf8Error),\n    IoError(std::io::Error),\n}\nimpl std::error::Error for CustomError{\n    fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn std::error::Error + &#39;static)&amp;gt; {\n        match &amp;amp;self {\n            CustomError::IoError(ref e) =&amp;gt; Some(e),\n            CustomError::Utf8Error(ref e) =&amp;gt; Some(e),\n            CustomError::ParseIntError(ref e) =&amp;gt; Some(e),\n        }\n    }\n}\n\nimpl Display for CustomError{\n    fn fmt(&amp;amp;self, f: &amp;amp;mut Formatter&amp;lt;&#39;_&amp;gt;) -&amp;gt; std::fmt::Result {\n        match &amp;amp;self {\n            CustomError::IoError(ref e) =&amp;gt; e.fmt(f),\n            CustomError::Utf8Error(ref e) =&amp;gt; e.fmt(f),\n            CustomError::ParseIntError(ref e) =&amp;gt; e.fmt(f),\n        }\n    }\n}\n\nimpl From&amp;lt;ParseIntError&amp;gt; for CustomError {\n    fn from(s: std::num::ParseIntError) -&amp;gt; Self {\n        CustomError::ParseIntError(s)\n    }\n}\n\nimpl From&amp;lt;IoError&amp;gt; for CustomError {\n    fn from(s: std::io::Error) -&amp;gt; Self {\n        CustomError::IoError(s)\n    }\n}\n\nimpl From&amp;lt;Utf8Error&amp;gt; for CustomError {\n    fn from(s: std::str::Utf8Error) -&amp;gt; Self {\n        CustomError::Utf8Error(s)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用&lt;code&gt;Box&amp;lt;dyn std::error::Error&amp;gt;&lt;/code&gt;来用trait object来代表所有类型的错误；另一种是使用自定义的&lt;code&gt;enum&lt;/code&gt;来装所有的错误。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust 错误处理中多种类型Error传播的处理方式&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;错误处理&#34;,&#34;slug&#34;:&#34;OScMf4N1R&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/OScMf4N1R/&#34;},{&#34;name&#34;:&#34;trait object&#34;,&#34;slug&#34;:&#34;hOKrnhyJkT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hOKrnhyJkT/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;}],&#34;date&#34;:&#34;2020-12-01 15:27:56&#34;,&#34;dateFormat&#34;:&#34;2020-12-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-cuo-wu-chu-li-zhong-duo-lei-xing-error-chu-li-fang-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:216000,&#34;words&#34;:741,&#34;minutes&#34;:4},&#34;description&#34;:&#34;有两种方式来聚合多种类型的Error来进行函数间的传播：一种是使用Box&amp;lt;dyn std::error::Error&amp;gt;来用trait object来代表所有类型的错误；另一种是使用自定义的enum来装所有的错误。\n\n主要参考：细...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#tl-dr\&#34;&gt;TL; DR&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#boxdyn-error-%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%81%9A%E5%90%88error\&#34;&gt;&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; 方式来聚合Error&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8-enum-%E6%9D%A5%E8%81%9A%E5%90%88error\&#34;&gt;利用 &lt;code&gt;enum&lt;/code&gt; 来聚合Error&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;基于&lt;a href=\&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches\&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;原作者的一些分析\&#34;&gt;原作者的一些分析&lt;/h1&gt;\n&lt;p&gt;基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(&lt;strong&gt;指针&lt;/strong&gt;)将是一个闭包。在下面的示例中，我们将此信息保存在一个HashMap中，但这不是唯一的选项。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;优势：&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;易于在大多数语言中实现&lt;/li&gt;\n&lt;li&gt;没有上下文切换&lt;/li&gt;\n&lt;li&gt;相对较低的内存开销(在大多数情况下)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;由于每个任务都必须保存以后需要的状态，因此内存使用将随着计算链中的回调次数线性增长。&lt;/li&gt;\n&lt;li&gt;很难理解。许多人已经知道这是“回调地狱”。&lt;/li&gt;\n&lt;li&gt;这是一种非常不同的编写程序的方式，并且需要大量重写才能从“正常”的程序流转换为使用“基于回调”的程序流。&lt;/li&gt;\n&lt;li&gt;由于Rust的所有权模型，任务之间的状态共享在使用该方法时是一个困难的问题。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;代码\&#34;&gt;代码&lt;/h1&gt;\n&lt;p&gt;通过代码，学习到了一些新东西，主要包括：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;thread_local!&lt;/code&gt; ：用来对每一个线程初始化同一个变量的一个新的副本。&lt;/li&gt;\n&lt;li&gt;trait 对象： &lt;code&gt;Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&lt;/code&gt;,  &lt;code&gt;dyn Trait&lt;/code&gt;表示一个类型，强调是动态分发，并且必须是一个&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;\n&lt;li&gt;传递闭包可以使用&lt;code&gt;impl Trait&lt;/code&gt;，这也是一个类型，并且该类型是&lt;code&gt;impl&lt;/code&gt;了&lt;code&gt;Trait&lt;/code&gt;的类型。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;thread::spawn&lt;/code&gt;会直接新开一个子线程运行，不会造成主线程阻塞。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;std::sync::mpsc::Receiver.iter()&lt;/code&gt; 这是一个阻塞的迭代器，只有当sender都被drop的时候，该迭代器的&lt;code&gt;.next()&lt;/code&gt; 才会变成&lt;code&gt;None&lt;/code&gt;，否则会一直等待。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;回调是在同一个线程上运行的。 这个例子中,我们创建的子线程基本上只是用作计时器，但可以表示任何类型的我们将不得不等待的资源。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;\nfn program_main() {\n    // 第一个输出\n    println!(&amp;quot;So we start the program here!&amp;quot;);\n    // 运行到这儿的时候， 0ms\n    // 1、把闭包里的任务放在callbacks中，next_id(此时为1)作为key，闭包作为val， next_id 递增。\n    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞\n    set_timeout(200, || {\n        // 第五个输出\n        println!(&amp;quot;We create tasks with a callback that runs once the task finished!&amp;quot;);\n    });\n    // 运行到这儿的时候， 仍然是0ms\n    // 1、把闭包里的任务放在callbacks中，next_id(此时为2)作为key，闭包作为val， next_id 递增。\n    // 2、会有一个子线程在set_timeout里面被创建，只负责延时。运行时候不会被该负责延时子线程阻塞\n    set_timeout(100, || {\n        // 第三个输出\n        println!(&amp;quot;We can even chain sub-tasks...&amp;quot;);\n        set_timeout(50, || {\n            // 第四个输出\n            println!(&amp;quot;...like this!&amp;quot;);\n        })\n    });\n    // 运行到这儿的时候， 仍然是0ms\n    // 第二个输出\n    println!(&amp;quot;While our tasks are executing we can do other stuff instead of waiting.&amp;quot;);\n}\n\nfn main() {\n    RT.with(|rt| rt.run(program_main));\n}\n\nuse std::sync::mpsc::{channel, Receiver, Sender};\nuse std::{cell::RefCell, collections::HashMap, thread};\n\n\n// threadlocal: 变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本\n// 每个线程都实例化了一个Runtime， 实际上RT是一个RT: std::thread::LocalKey&amp;lt;Runtime&amp;gt;\n// 这儿好像只用到了一个副本\nthread_local! {\n    static RT: Runtime = Runtime::new();\n}\n\nstruct Runtime {\n    // callbacks 中的Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt; 是一个 trait 对象。 \n    // 每一个闭包实例有其自己独有的匿名类型, 闭包有trait bound，比如 Fn(u32) -&amp;gt; u32。 \n    // callbacks 用来存下一个运行的程序块（这里用闭包来表示）。\n    callbacks: RefCell&amp;lt;HashMap&amp;lt;usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;&amp;gt;&amp;gt;,\n    // 储存下一个闭包的id\n    next_id: RefCell&amp;lt;usize&amp;gt;,\n    // 每一个等待子线程拥有一个，在延时结束后，发送需要运行的id\n    evt_sender: Sender&amp;lt;usize&amp;gt;,\n    // 接受下一个该运行的闭包的id\n    evt_reciever: Receiver&amp;lt;usize&amp;gt;,\n}\n\n// cb 是传递的是一个闭包,The other use of the impl keyword is in impl Trait syntax, which can be seen as a shorthand for &amp;quot;a concrete type that implements this trait&amp;quot;. \n// Its primary use is working with closures, which have type definitions generated at compile time that can&#39;t be simply typed out.\n// 传递闭包时候用impl Trait。表示一个【类型】，这个类型implements 了这个trait\n// https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html\nfn set_timeout(ms: u64, cb: impl FnOnce() + &#39;static) {\n    // with 方法是 在 std::thread::local::LocalKey 中有的，也就是 RT 有的 。\n    // 获取对这个TLS键中的值的引用。如果这个线程还没有引用这个键，这将延迟初始化这个值。\n    // 相当于用.with()就是在使用该变量的函数。\n    RT.with(|rt| {\n        let id = *rt.next_id.borrow();\n        // next_id递增\n        *rt.next_id.borrow_mut() += 1;\n        // callbacks存 (id: usize, Box&amp;lt;dyn FnOnce() -&amp;gt; ()&amp;gt;)\n        // 为什么需要 Box::new(cb) 这样子的呀, 因为输入的类型未知\n        // cb 在输入参数中用的impl FnOnce() + &#39;static 来限定。\n        rt.callbacks.borrow_mut().insert(id, Box::new(cb));\n        // The sending-half of Rust&#39;s asynchronous channel type. \n        // This half can only be owned by one thread, but it can be cloned to send to other threads.\n        // 一个sender只能够用在一个线程里面，但是可以克隆到其他线程中，此时receiver还是只有一个\n        let evt_sender = rt.evt_sender.clone();\n        // thread::spawn会直接新开一个子线程运行，不会造成主线程阻塞。功能是休眠后再把id输出出去\n        thread::spawn(move || {\n            thread::sleep(std::time::Duration::from_millis(ms));\n            // 在延时结束后，发送当前延时结束的任务id\n            evt_sender.send(id).unwrap();\n        });\n    });\n}\n\n\nimpl Runtime {\n    fn new() -&amp;gt; Self {\n        // 这是一个asynchronous channel， 每个线程里面都有一个sender和receiver\n        let (evt_sender, evt_reciever) = channel();\n        Runtime {\n            callbacks: RefCell::new(HashMap::new()),\n            next_id: RefCell::new(1),\n            evt_sender,\n            evt_reciever,\n        }\n    }\n\n    // 这儿是在运行一个函数.\n    fn run(&amp;amp;self, program: fn()) {\n        // 直接运行， \n        program();\n        // 0ms 运行到这儿\n        // 运行结束后，开始逐个访问Runtime 里面的休眠子线程返回的 对应id的值。\n        // This iterator will block whenever next is called, waiting for a new message, and None will be returned when the corresponding channel has hung up.\n        // 这是一个阻塞的方法，只有当sender都被drop的时候，该迭代器的.next() 才会变成None\n        for evt_id in &amp;amp;self.evt_reciever {\n            // 这儿直接从HashMap里remove出对应编号的闭包。\n            let cb = self.callbacks.borrow_mut().remove(&amp;amp;evt_id).unwrap();\n            cb();\n            // 是不是也不需要这句话？\n            // 【不行！】: 因为在Runtime里面一个sender，不会被drop掉，就会陷入无限等待了\n            if self.callbacks.borrow().is_empty() {\n                break;\n            }\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;如果用基于回调的方法来说Rust异步编程中的唱歌跳舞例子， 也就是，“计时器”代表的“等待资源”，等价于 “唱歌”前等待&amp;quot;学歌&amp;quot;。所以，在回调逻辑中 &lt;code&gt;sing_song()&lt;/code&gt;作为闭包， &lt;code&gt;learn_song()&lt;/code&gt; 作为子线程，主线程运行&lt;code&gt;dance()&lt;/code&gt; 。子线程结束后再运行这个闭包。运行顺序是 &lt;code&gt;learn_song()&lt;/code&gt; （子线程）和 &lt;code&gt;dance()&lt;/code&gt;  （主线程）同时运行，在两个任务均完成后， 再回调&lt;code&gt;sing_song()&lt;/code&gt;这个闭包。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;子线程&lt;/strong&gt;对应 &lt;strong&gt;“等待资源”&lt;/strong&gt; ； &lt;strong&gt;闭包&lt;/strong&gt;对应“&lt;strong&gt;接收到等待资源后的操作”&lt;/strong&gt;。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;async fn learn_and_sing() {\n    // 在唱歌之前等待学歌完成\n    // 这里我们使用 `.await` 而不是 `block_on` 来防止阻塞线程，这样就可以同时执行 `dance` 了。\n    let song = learn_song().await;\n    sing_song(song).await;\n}\n async fn async_main() {\n    let f1 = learn_and_sing();\n    let f2 = dance();\n     // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成\n     // 如果学歌的时候有了短暂的阻塞，跳舞将会接管当前的线程，如果跳舞变成了阻塞\n     // 学歌将会返回来接管线程。如果两个futures都是阻塞的，\n     // 这个‘async_main&#39;函数就会变成阻塞状态，并生成一个执行器\n    futures::join!(f1, f2)\n}\n fn main() {\n    block_on(async_main());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;基于&lt;a href=\&#34;https://cfsamson.github.io/books-futures-explained/0_background_information.html#callback-based-approaches\&#34;&gt;Futures Explained in 200 Lines of Rust&lt;/a&gt;文中的回调代码。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust 基于回调的异步方法分析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;回调&#34;,&#34;slug&#34;:&#34;dccFuZ2yD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/dccFuZ2yD/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;},{&#34;name&#34;:&#34;异步编程&#34;,&#34;slug&#34;:&#34;hDYBWTXHUV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hDYBWTXHUV/&#34;}],&#34;date&#34;:&#34;2020-11-30 16:57:43&#34;,&#34;dateFormat&#34;:&#34;2020-11-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-ji-yu-hui-diao-de-yi-bu-fang-fa-fen-xi_/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:474000,&#34;words&#34;:1926,&#34;minutes&#34;:8},&#34;description&#34;:&#34;基于Futures Explained in 200 Lines of Rust文中的回调代码。\n\n原作者的一些分析\n基于回调方法背后的整个思想是保存一个指针，该指针指向一组我们希望稍后运行的一系列指令，以及需要的各种状态。在Rust，这(...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E4%BD%9C%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E6%9E%90\&#34;&gt;原作者的一些分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81\&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;const_unit_poc-利用const-generics实现的物理单位库\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;const_unit_poc&lt;/code&gt;  是几天前推出的，率先使用const 泛型的库。该库的使用方法如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![feature(const_generics, const_evaluatable_checked)]\nuse const_unit_poc::values::{m, kg, s, N};\n\nlet distance = 1.0 * m;\nlet mass = 18.0 * kg;\nlet force = distance * mass / (1.8 * s * 2.0 * s);\nassert_eq!(force, 5.0 * N);\n\nlet mut mutable_distance = 3.2 * m;\nmutable_distance -= 0.2 * m;\nmutable_distance += 2.0 * m;\n\nassert_eq!(mutable_distance, 5.0 * m);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码及其简便！易懂！非常神奇！所以就根据该库的源代码看看const 泛型该如何使用。&lt;/p&gt;\n&lt;h2 id=\&#34;const_unit_poc-源码分析\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/h2&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![feature(const_generics, const_evaluatable_checked, doc_cfg)]\n#![allow(incomplete_features)]\n#![cfg_attr(feature = &amp;quot;non_ascii&amp;quot;, feature(non_ascii_idents))]\n\nuse std::ops;\n\npub mod units;\npub mod values;\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n#[allow(non_snake_case)]\npub struct SiUnit {\n    m: i8,\n    kg: i8,\n    s: i8,\n    A: i8,\n    K: i8,\n    mol: i8,\n    cd: i8,\n}\n\n// 后面还有内容\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里引入了&lt;code&gt;units&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;两个mod，并且声明了&lt;code&gt;SiUnit&lt;/code&gt; 这个结构体，里面的成员是SI的7个标准单位， 类型为i8。&lt;/p&gt;\n&lt;p&gt;看到这儿，笔者推测应该是使用 &lt;code&gt;SiUnit&lt;/code&gt; 这个结构体来实例化各种常用的单位（如&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;），其中成员的值表示该单位表示成基本单位后的指数的值（如&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;N=m*s^{-2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;N&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.46528em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.8141079999999999em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;s&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8141079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;， 则&lt;code&gt;N.m == 1; N.s == -2&lt;/code&gt;）。&lt;/p&gt;\n&lt;p&gt;再看一下引入的模块&lt;code&gt;units&lt;/code&gt;的内容&lt;/p&gt;\n&lt;h3 id=\&#34;units的实现\&#34;&gt;units的实现&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/units.rs\&#34;&gt;&lt;code&gt;./src/units.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![allow(non_upper_case_globals)]\nuse super::SiUnit;\nconst NONE: SiUnit = SiUnit { m: 0, kg: 0, s: 0, A: 0, K: 0, mol: 0, cd: 0 };\n/// meter\npub const m: SiUnit = SiUnit { m: 1, ..NONE };\n/// 中间内容省略\n/// lux\npub const lx: SiUnit = SiUnit { m: -2, cd: 1, ..NONE };\n/// square meter\npub const sq_m: SiUnit = SiUnit { m: 2, ..NONE };\n/// cubic meter\npub const cu_m: SiUnit = SiUnit { m: 3, ..NONE };\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;的确和猜想一致！注意结构体实例化时候这儿使用了&lt;code&gt;..NONE&lt;/code&gt;，这是用已经创建的实例None上&lt;strong&gt;更新部分参数&lt;/strong&gt;，创建新的实例，见&lt;a href=\&#34;https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%9B%B4%E6%96%B0%E8%AF%AD%E6%B3%95%E4%BB%8E%E5%85%B6%E4%BB%96%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B\&#34;&gt;使用结构体更新语法从其他实例创建实例&lt;/a&gt;。这儿使用了const使得各个单位全局可见且不可变。&lt;/p&gt;\n&lt;p&gt;现在已经有了单位，但是我们注意到代码中&lt;code&gt;assert_eq!(mutable_distance, 5.0 * m);&lt;/code&gt;不仅仅要检测单位的值，还要检测系数的值，结构体与数字相乘后又该如何表示呢？这个问题应该能够从另一个模块得到答案吧。&lt;/p&gt;\n&lt;h3 id=\&#34;对单位系数的包装\&#34;&gt;对单位系数的包装&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/values.rs\&#34;&gt;&lt;code&gt;./src/values.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#![allow(non_upper_case_globals)]\nuse crate::{units, Quantity};\n// base\n/// 1 meter\npub const m: Quantity&amp;lt;{ units::m }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 1 kilogram\npub const kg: Quantity&amp;lt;{ units::kg }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 1 second\npub const s: Quantity&amp;lt;{ units::s }&amp;gt; = Quantity { raw_value: 1.0 };\n/// 后面还有\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;use crate::{units, Quantity}&lt;/code&gt;, 代表的是导入的当前&lt;code&gt;crate&lt;/code&gt;中的&lt;code&gt;units&lt;/code&gt;和&lt;code&gt;Quantity&lt;/code&gt;。&lt;br&gt;\n&lt;strong&gt;const 泛型&lt;/strong&gt;: 从这儿的可以大概可以看出，&lt;code&gt;Quantity&lt;/code&gt;的泛型参数是一个const常量，包装每一个&lt;code&gt;units.rs&lt;/code&gt;中的const常量值。这就是const generics吧! 后面的实例化根据类型推导应该又可以写做：&lt;code&gt;Quantity&amp;lt;{ units::m }&amp;gt; { raw_value: 1.0 }&lt;/code&gt;。 所以是用&lt;code&gt;raw_value&lt;/code&gt;来表示每一个单位的系数。&lt;/p&gt;\n&lt;p&gt;所以再来看看&lt;code&gt;Quantity&lt;/code&gt;的定义吧。&lt;/p&gt;\n&lt;p&gt;###结构体 &lt;code&gt;Quantity&lt;/code&gt;的定义&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n#[repr(transparent)]\npub struct Quantity&amp;lt;const U: SiUnit&amp;gt; {\n    pub raw_value: f64,\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;简单干脆的使用const 类型作为泛型参数。&lt;/p&gt;\n&lt;h3 id=\&#34;加减运算\&#34;&gt;加减运算&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Add for Quantity&amp;lt;U&amp;gt; {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -&amp;gt; Self {\n        Self { raw_value: self.raw_value + rhs.raw_value }\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::AddAssign for Quantity&amp;lt;U&amp;gt; {\n    fn add_assign(&amp;amp;mut self, rhs: Self) {\n        self.raw_value += rhs.raw_value;\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::Sub for Quantity&amp;lt;U&amp;gt; {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -&amp;gt; Self {\n        Self { raw_value: self.raw_value - rhs.raw_value }\n    }\n}\n\nimpl&amp;lt;const U: SiUnit&amp;gt; ops::SubAssign for Quantity&amp;lt;U&amp;gt; {\n    fn sub_assign(&amp;amp;mut self, rhs: Self) {\n        self.raw_value -= rhs.raw_value;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由于加减运算并不会变单位，所以就是对系数的加减，非常直接。&lt;/p&gt;\n&lt;h3 id=\&#34;乘除运算\&#34;&gt;乘除运算&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;一个数字与一个Quantity相乘，单位不变：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;impl&amp;lt;const U: SiUnit&amp;gt; ops::Mul&amp;lt;f64&amp;gt; for Quantity&amp;lt;U&amp;gt; {\n    type Output = Quantity&amp;lt;U&amp;gt;;\n\n    fn mul(self, rhs: f64) -&amp;gt; Self::Output {\n        Quantity { raw_value: self.raw_value * rhs }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;两个带单位的量相乘，单位发生变化，也就是&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;的泛型参数发生了变化，此时需要重新实例化一个&lt;code&gt;Quantity&amp;lt;U&amp;gt;&lt;/code&gt;结构体：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=\&#34;https://docs.rs/crate/const_unit_poc/1.0.0/source/src/lib.rs\&#34;&gt;&lt;code&gt;./src/lib.rs&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;// Quantity相乘转换为unit相乘，UL.unit_mul(UR)\nimpl&amp;lt;const UL: SiUnit, const UR: SiUnit&amp;gt; ops::Mul&amp;lt;Quantity&amp;lt;UR&amp;gt;&amp;gt; for Quantity&amp;lt;UL&amp;gt;\nwhere\n    Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;: ,\n{\n    type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;\n\n    fn mul(self, rhs: Quantity&amp;lt;UR&amp;gt;) -&amp;gt; Self::Output {\n        Quantity { raw_value: self.raw_value * rhs.raw_value }\n    }\n}\n// unit相乘\nimpl SiUnit {\n    const fn unit_mul(self, rhs: Self) -&amp;gt; Self {\n        Self {\n            m: self.m + rhs.m,\n            kg: self.kg + rhs.kg,\n            s: self.s + rhs.s,\n            A: self.A + rhs.A,\n            K: self.K + rhs.K,\n            mol: self.mol + rhs.mol,\n            cd: self.cd + rhs.cd,\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;这儿对泛型的约束很神奇，竟然是这样写&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;:&lt;/code&gt; ，如果去掉这个where，则会报错unconstrained generic constant。虽然现在还不懂是什么意思....&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;error: unconstrained generic constant\n   --&amp;gt; src\\lib.rs:156:5\n    |\n156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     \n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     \n    |\nhelp: consider adding a `where` bound for this expression  \n   --&amp;gt; src\\lib.rs:156:28\n    |\n156 |     type Output = Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;;     \n    |                            ^^^^^^^^^^^^^^^^^^^     \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;另外一点，泛型中的const是调用一个const fn得到的时候，这个时候需要打大括号，如：&lt;code&gt;Quantity&amp;lt;{ UL.unit_mul(UR) }&amp;gt;&lt;/code&gt; ，否则也会出错。这在最近的&lt;a href=\&#34;https://github.com/rust-lang/rust/pull/79135\&#34;&gt;Stabilization report&lt;/a&gt;里面也有提到。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Const arguments&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;Const parameters are instantiated using const arguments. Any concrete const expression or const parameter as a standalone argument can be used. When applying an expression as const parameter, &lt;strong&gt;most expressions must be contained within a block&lt;/strong&gt;, with two exceptions:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;literals and single-segment path expressions&lt;/li&gt;\n&lt;li&gt;array lengths&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;This syntactic restriction is necessary to avoid ambiguity, or requiring infinite lookahead when parsing an expression as a generic argument.&lt;/p&gt;\n&lt;p&gt;In the cases where a generic argument could be resolved as either a type or const argument, we always interpret it as a type. This causes the following test to fail:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;type N = u32;\nstruct Foo&amp;lt;const N: usize&amp;gt;;\nfn foo&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;N&amp;gt; { todo!() } // ERR\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;To circumvent this, the user may wrap the const parameter with braces, at which point it is unambiguously accepted.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-rust\&#34;&gt;type N = u32;\nstruct Foo&amp;lt;const N: usize&amp;gt;;\nfn bar&amp;lt;const N: usize&amp;gt;() -&amp;gt; Foo&amp;lt;{ N }&amp;gt; { todo!() } // ok\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;简单来说，const 泛型一般都需要打大括号(两种情况除外)，打大括号是为了防止歧义。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;p&gt;这篇文章主要是了解了const 泛型在做啥，以及如何做的。&lt;/p&gt;\n&lt;p&gt;通过这个简单的例子，我感觉const 泛型是用在当泛型需要有取值的时候（比如这里的unit就需要取值，而不能每一个单位一个类型...）。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Rust const 泛型 (Const Generics)的使用方法：解析const_unit_poc&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;const&#34;,&#34;slug&#34;:&#34;Op9tNmAIW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/Op9tNmAIW/&#34;},{&#34;name&#34;:&#34;泛型&#34;,&#34;slug&#34;:&#34;BCk2FVrJcy&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/BCk2FVrJcy/&#34;},{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;}],&#34;date&#34;:&#34;2020-11-23 20:15:59&#34;,&#34;dateFormat&#34;:&#34;2020-11-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-const-fan-xing-const-genericsde-shi-yong-fang-fa-jie-xi-const_unit_poc_/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:460000,&#34;words&#34;:1592,&#34;minutes&#34;:8},&#34;description&#34;:&#34;对于const 泛型，笔者也了解甚少。借写该文章的机会，学习一下Rust的const 泛型(Const Generics)\n\nconst_unit_poc ：利用const generics实现的物理单位库\nconst_unit_poc  ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#const_unit_poc-%E5%88%A9%E7%94%A8const-generics%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%A9%E7%90%86%E5%8D%95%E4%BD%8D%E5%BA%93\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; ：利用const generics实现的物理单位库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#const_unit_poc-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\&#34;&gt;&lt;code&gt;const_unit_poc&lt;/code&gt; 源码分析&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#units%E7%9A%84%E5%AE%9E%E7%8E%B0\&#34;&gt;units的实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E5%8D%95%E4%BD%8D%E7%B3%BB%E6%95%B0%E7%9A%84%E5%8C%85%E8%A3%85\&#34;&gt;对单位系数的包装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97\&#34;&gt;加减运算&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97\&#34;&gt;乘除运算&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;1-为什么需要异步编程\&#34;&gt;1. 为什么需要异步编程？&lt;/h1&gt;\n&lt;p&gt;刚开始一直有一个疑问：&lt;strong&gt;既然已经有了多线程技术，多用户访问直接使用多线程，为什么还需要异步呢？&lt;/strong&gt; 后来终于明白，异步是用在多用户&lt;strong&gt;同时处理同一资源&lt;/strong&gt;时候发挥作用的。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;现在用100个用户同时修改一个文件来举例：\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;(一般也是&lt;strong&gt;阻塞&lt;/strong&gt;)： 程序需要实现&lt;strong&gt;读写锁(&lt;code&gt;std::sync::RwLock&lt;/code&gt;)&lt;strong&gt;或&lt;/strong&gt;互斥锁(&lt;code&gt;std::sync::Mutex&lt;/code&gt;)&lt;/strong&gt;，程序会同时产生100个线程，但是只能有一个线程拥有写锁，其他的99个线程均&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;处于&lt;strong&gt;等待状态&lt;/strong&gt;，线程不会sleep，会循环获取锁(自旋锁Spinlock)。\n&lt;ul&gt;\n&lt;li&gt;阻塞的线程还来参与操作系统的抢占式调度，很不科学！为什么不先排好队，用一个线程呢（这也是协程干的事）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;或者有起始的&lt;strong&gt;加锁开销&lt;/strong&gt;(通常是对互斥锁：①线程会从sleep（加锁）——&amp;gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；②互斥锁在sleep时会陷入到内核态，需要昂贵的系统调用；线程向操作系统请求被挂起是通过一个系统调用，在linux上的实现就是futex)。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;(一般也是&lt;strong&gt;非阻塞&lt;/strong&gt;)： 将100个线程根据一定的先后次序&lt;strong&gt;合并成一个线程&lt;/strong&gt;(也可能是多个线程？)， 就可以避免锁的产生，从而减少操作系统对线程调用的开销。但是，当线程之间对资源的依赖关系比较复杂的时候，程序的编写就会&lt;strong&gt;十分复杂&lt;/strong&gt;。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;协程&lt;/strong&gt;(coroutine)： 实现异步编程的一种方式，是在线程之下的一个单位。协程是语言层面控制数据流的一种“调度”（处理公共资源的时候，相当于&lt;strong&gt;用户态的锁&lt;/strong&gt;）， 线程是操作系统层面的“调度”（处理公共资源，使用&lt;strong&gt;操作系统或者硬件的锁(即Mutex或者Spinlock)&lt;/strong&gt;）。协程的调度是编译器通过组织运算顺序实现的（通过生成器（等同于一个状态机）实现），线程是通过操作系统来进行抢占式调度的。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B\&#34;&gt;协程wiki&lt;/a&gt;：协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/332113890/answer/1052024052\&#34;&gt;互斥锁（mutex）的底层原理是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/50185085/answer/1342613525\&#34;&gt;出于什么样的原因，诞生了「协程」这一概念？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;所以，异步编程是可以直接用复杂的代码结构直接写出来的。比如上面的例子就是在一个线程里面去依次读写100次。而Rust的&lt;code&gt;async/.await&lt;/code&gt;解决方案做的工作是 &lt;strong&gt;“将复杂的异步代码 ===&amp;gt; 利用语法糖 ===&amp;gt; 转化为类似于同步的代码(更容易coding)”&lt;/strong&gt;  即 &lt;strong&gt;“用同步的语义解决异步问题”&lt;/strong&gt; 。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rust-yi-bu&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。&lt;br&gt;\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用&lt;code&gt;async/.await&lt;/code&gt;解决方案。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34; Rust 异步并发（一）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;rust&#34;,&#34;slug&#34;:&#34;PUCwH47Rx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/PUCwH47Rx/&#34;},{&#34;name&#34;:&#34;异步编程&#34;,&#34;slug&#34;:&#34;hDYBWTXHUV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/hDYBWTXHUV/&#34;}],&#34;date&#34;:&#34;2020-11-22 23:07:53&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/rust-yi-bu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:187000,&#34;words&#34;:907,&#34;minutes&#34;:4},&#34;description&#34;:&#34;前一段时间看了一些关于Rust的异步编程相关的知识，受益匪浅，故做此记录。\nRust异步编程是Rust语言中十分重要特性。现在Rust中的异步编程采用async/.await解决方案。\n\n1. 为什么需要异步编程？\n刚开始一直有一个疑问：既...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B\&#34;&gt;1. 为什么需要异步编程？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;一个自说自话的地方。&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;一只在毕业边缘挣扎的秃头怪。&lt;/p&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;p&gt;coding~&lt;br&gt;\n以及一切有趣的事情们~&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;p&gt;thubzy15@foxmail.com&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-11-22 17:21:05&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:14000,&#34;words&#34;:67,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n一个自说自话的地方。\n👨‍💻 博主是谁\n一只在毕业边缘挣扎的秃头怪。\n⛹ 兴趣爱好\ncoding~\n以及一切有趣的事情们~\n📬 联系我呀\nthubzy15@foxmail.c...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;从&lt;strong&gt;今天&lt;/strong&gt;开始记录学习和生活。&lt;/p&gt;\n&lt;p&gt;我也是一个懒惰的小博主啦~😋&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;2020112-yi-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;2020.11.22 伊始&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;随便写写&#34;,&#34;slug&#34;:&#34;xMGkC-iLRF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://Busy-Bob.github.io/tag/xMGkC-iLRF/&#34;}],&#34;date&#34;:&#34;2020-11-22 16:45:04&#34;,&#34;dateFormat&#34;:&#34;2020-11-22&#34;,&#34;feature&#34;:&#34;https://Busy-Bob.github.io/post-images/2020112-yi-shi.jpg&#34;,&#34;link&#34;:&#34;https://Busy-Bob.github.io/post/2020112-yi-shi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:4000,&#34;words&#34;:24,&#34;minutes&#34;:1},&#34;description&#34;:&#34;从今天开始记录学习和生活。\n我也是一个懒惰的小博主啦~😋\n&#34;,&#34;toc&#34;:&#34;&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


<script src=" /media/js/cool.js"></script>


</html>